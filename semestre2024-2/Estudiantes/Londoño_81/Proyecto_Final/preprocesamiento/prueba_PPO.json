[
  {
    "full_name": "CategoryTheory.Equivalence.invFunIdAssoc_hom_app",
    "file_path": "Mathlib/CategoryTheory/Equivalence.lean",
    "teorema": "lemma CategoryTheory.Equivalence.invFunIdAssoc_hom_app (C : Type u₁) (D : Type u₂) (E : Type u₃) (F : D ⥤ E) (X : D) (e : C ≌ D) : (e.invFunIdAssoc F).hom.app X = F.map (e.counit.app X) := by"
  },
  {
    "full_name": "ENNReal.le_rpow_one_div_iff",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "theorem ENNReal.le_rpow_one_div_iff (x : ℝ≥0∞) (y : ℝ≥0∞) (z : ℝ) : x ≤ y ^ (1 / z) ↔ x ^ z ≤ y := by"
  },
  {
    "full_name": "Combinatorics.Line.apply_of_ne_none",
    "file_path": "Mathlib/Combinatorics/HalesJewett.lean",
    "teorema": "theorem Combinatorics.Line.apply_of_ne_none (i : ι) (l : Line α ι) (x : α) (α : Type u_1) (ι : Type u_2) : some ((fun x i => (l.idxFun i).getD x) x i) = l.idxFun i := by"
  },
  {
    "full_name": "CancelDenoms.cancel_factors_lt",
    "file_path": "Mathlib/Tactic/CancelDenoms/Core.lean",
    "teorema": "lemma CancelDenoms.cancel_factors_lt (a : α) (ad : α) (b : α) (bd : α) (gcd : α) (α : Type u_1) : (a < b) = (1 / gcd * (bd * a') < 1 / gcd * (ad * b')) := by"
  },
  {
    "full_name": "Batteries.BinomialHeap.Imp.Heap.WF.tail?",
    "file_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "teorema": "lemma Batteries.BinomialHeap.Imp.Heap.WF.tail? (le : α → α → Bool) (s : Heap α) (tl : Heap α) (α : Type u_1) : Heap.tail? le s = some tl → WF le 0 tl := by"
  },
  {
    "full_name": "Ideal.span_singleton_eq_span_singleton",
    "file_path": "Mathlib/RingTheory/Ideal/Basic.lean",
    "teorema": "lemma Ideal.span_singleton_eq_span_singleton (x : α) (y : α) (α : Type u) : span {x} = span {y} ↔ Associated x y := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.comap_ofFunction",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean",
    "teorema": "lemma MeasureTheory.OuterMeasure.comap_ofFunction (f : β → α) (m : Set α → ℝ≥0∞) (α : Type u_1) (β : Type ?u.25201) : (fun s => m (f '' s)) ∅ = 0 := by"
  },
  {
    "full_name": "IsGroupHom.inv_ker_one'",
    "file_path": "Mathlib/Deprecated/Subgroup.lean",
    "teorema": "lemma IsGroupHom.inv_ker_one' (G : Type u_1) (H : Type u_2) (a : G) (b : G) (f : G → H) : f (a⁻¹ * b) = 1 := by"
  },
  {
    "full_name": "Convex.thickening",
    "file_path": "Mathlib/Analysis/Convex/Normed.lean",
    "teorema": "lemma Convex.thickening (E : Type u_2) (s : Set E) (δ : ℝ) : Convex ℝ (Metric.thickening δ s) := by"
  },
  {
    "full_name": "SetTheory.PGame.zero_lf_inv'",
    "file_path": "Mathlib/SetTheory/Game/Basic.lean",
    "teorema": "theorem SetTheory.PGame.zero_lf_inv' (xL : xl → PGame) (xR : xr → PGame) (xl : Type u_1) (xr : Type u_1) : 0 ⧏ (mk xl xr xL xR).inv' := by"
  },
  {
    "full_name": "NNReal.le_inv_iff_mul_le",
    "file_path": "Mathlib/Data/NNReal/Basic.lean",
    "teorema": "lemma NNReal.le_inv_iff_mul_le (p : ℝ≥0) (r : ℝ≥0) : r ≤ p⁻¹ ↔ r * p ≤ 1 := by"
  },
  {
    "full_name": "MeasureTheory.integrable_of_intervalIntegral_norm_bounded",
    "file_path": "Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean",
    "teorema": "lemma MeasureTheory.integrable_of_intervalIntegral_norm_bounded (E : Type u_2) (f : ℝ → E) (μ : Measure ℝ) : Integrable f μ := by"
  },
  {
    "full_name": "IntermediateField.separable_of_mem_isSeparable",
    "file_path": "Mathlib/FieldTheory/SeparableDegree.lean",
    "teorema": "lemma IntermediateField.separable_of_mem_isSeparable (E : Type v) (F : Type u) (x : E) : (minpoly F x).Separable := by"
  },
  {
    "full_name": "CochainComplex.mk'_d_1_0",
    "file_path": "Mathlib/Algebra/Homology/HomologicalComplex.lean",
    "teorema": "theorem CochainComplex.mk'_d_1_0 (V : Type u) (X₀ : V) (X₁ : V) (d₀ : X₀ ⟶ X₁) (succ : (S : ShortComplex V) → (X₄ : V) ×' (d₂ : S.X₃ ⟶ X₄) ×' S.g ≫ d₂ = 0) : (mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').d 0 1 = d₀ := by"
  },
  {
    "full_name": "Equiv.Perm.prod_comp'",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "theorem Equiv.Perm.prod_comp' (f : α → α → β) (s : Finset α) (α : Type u_3) (β : Type u_4) (σ : Equiv.Perm α) : ∏ x ∈ s, f (σ x) x = ∏ x ∈ s, f x ((Equiv.symm σ) x) := by"
  },
  {
    "full_name": "Finmap.erase_toFinmap",
    "file_path": "Mathlib/Data/Finmap.lean",
    "teorema": "theorem Finmap.erase_toFinmap (a : α) (s : AList β) (α : Type u) (β : α → Type v) : erase a ⟦s⟧ = ⟦AList.erase a s⟧ := by"
  },
  {
    "full_name": "Filter.HasBasis.to_hasBasis'",
    "file_path": "Mathlib/Order/Filter/Bases.lean",
    "teorema": "theorem Filter.HasBasis.to_hasBasis' (l : Filter α) (p : ι → Prop) (s : ι → Set α) (α : Type u_1) (ι : Sort u_4) : l.HasBasis p' s' := by"
  },
  {
    "full_name": "FreeAlgebra.toTensor_ι",
    "file_path": "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean",
    "teorema": "lemma FreeAlgebra.toTensor_ι (M : Type u_2) (R : Type u_1) (m : M) : toTensor (ι R m) = (TensorAlgebra.ι R) m := by"
  },
  {
    "full_name": "Algebra.map_leftMulMatrix_localization",
    "file_path": "Mathlib/RingTheory/Localization/NormTrace.lean",
    "teorema": "lemma Algebra.map_leftMulMatrix_localization (M : Submonoid R) (R : Type u_1) (Rₘ : Type u_3) (S : Type u_2) (Sₘ : Type u_4) (a : S) (b : Basis ι R S) (ι : Type u_5) : (algebraMap R Rₘ).mapMatrix ((leftMulMatrix b) a) = (leftMulMatrix (Basis.localizationLocalization Rₘ M Sₘ b)) ((algebraMap S Sₘ) a) := by"
  },
  {
    "full_name": "Polynomial.Monic.degree_mul_comm",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "teorema": "theorem Polynomial.Monic.degree_mul_comm (R : Type u) (p : R[X]) (q : R[X]) : (p * q).degree = (q * p).degree := by"
  },
  {
    "full_name": "List.head_cyclicPermutations",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "teorema": "theorem List.head_cyclicPermutations (l : List α) (α : Type u) : l.cyclicPermutations.head ⋯ = l := by"
  },
  {
    "full_name": "Cardinal.lift_natCast",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "lemma Cardinal.lift_natCast (n : ℕ) : lift.{u, v} ↑n = ↑n := by"
  },
  {
    "full_name": "Algebra.trace_prod",
    "file_path": "Mathlib/RingTheory/Trace.lean",
    "teorema": "theorem Algebra.trace_prod (R : Type u_1) (S : Type u_2) (T : Type u_3) (p : S × T) : (trace R (S × T)) p = ((trace R S).coprod (trace R T)) p := by"
  },
  {
    "full_name": "Order.pred_eq_iff_covBy",
    "file_path": "Mathlib/Order/SuccPred/Basic.lean",
    "teorema": "theorem Order.pred_eq_iff_covBy (a : α) (b : α) (α : Type u_1) : pred b = a → a ⋖ b := by"
  },
  {
    "full_name": "Set.wellFoundedOn_iff",
    "file_path": "Mathlib/Order/WellFoundedSet.lean",
    "teorema": "theorem Set.wellFoundedOn_iff (r : α → α → Prop) (s : Set α) (α : Type u_2) : s.WellFoundedOn r ↔ WellFounded fun a b => r a b ∧ a ∈ s ∧ b ∈ s := by"
  },
  {
    "full_name": "ExteriorAlgebra.ι_range_disjoint_one",
    "file_path": "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean",
    "teorema": "lemma ExteriorAlgebra.ι_range_disjoint_one (R : Type u1) : Disjoint (LinearMap.range (ι R)) 1 := by"
  },
  {
    "full_name": "MulOpposite.unop_list_prod",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "theorem MulOpposite.unop_list_prod (l : List Mᵐᵒᵖ) : unop l.prod = (map unop l).reverse.prod := by"
  },
  {
    "full_name": "MeasureTheory.integrable_add_iff_integrable_left",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "theorem MeasureTheory.integrable_add_iff_integrable_left (f : α → β) (g : α → β) (α : Type u_1) (β : Type u_2) (μ : Measure α) : Integrable (g + f) μ ↔ Integrable g μ := by"
  },
  {
    "full_name": "PowerSeries.ker_coeff_eq_max_ideal",
    "file_path": "Mathlib/RingTheory/PowerSeries/Inverse.lean",
    "teorema": "lemma PowerSeries.ker_coeff_eq_max_ideal (k : Type u_2) : x✝ ∈ RingHom.ker (constantCoeff k) ↔ x✝ ∈ maximalIdeal k⟦X⟧ := by"
  },
  {
    "full_name": "Setoid.card_classes_ker_le",
    "file_path": "Mathlib/Data/Setoid/Partition.lean",
    "teorema": "theorem Setoid.card_classes_ker_le (f : α → β) (α : Type u_2) (β : Type u_3) : Fintype.card ↑(ker f).classes ≤ Fintype.card β := by"
  },
  {
    "full_name": "FiberPrebundle.mem_pretrivializationAt_source",
    "file_path": "Mathlib/Topology/FiberBundle/Basic.lean",
    "teorema": "theorem FiberPrebundle.mem_pretrivializationAt_source (B : Type u_2) (E : B → Type u_5) (F : Type u_3) (a : FiberPrebundle F E) (b : B) (x : E b) : { proj := b, snd := x } ∈ (a.pretrivializationAt b).source := by"
  },
  {
    "full_name": "Finset.noncommProd_singleton",
    "file_path": "Mathlib/Data/Finset/NoncommProd.lean",
    "teorema": "theorem Finset.noncommProd_singleton (a : α) (f : α → β) (α : Type u_3) (β : Type u_4) : (↑{a}).Pairwise fun a b => Commute (f a) (f b) := by"
  },
  {
    "full_name": "NFA.toDFA_correct",
    "file_path": "Mathlib/Computability/NFA.lean",
    "teorema": "lemma NFA.toDFA_correct (M : NFA α σ) (α : Type u) (σ : Type v) : M.toDFA.accepts = M.accepts := by"
  },
  {
    "full_name": "FractionalIdeal.count_mul",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Factorization.lean",
    "teorema": "theorem FractionalIdeal.count_mul (I : FractionalIdeal R⁰ K) (K : Type u_2) (R : Type u_1) (v : HeightOneSpectrum R) : count K v (I * I') = count K v I + count K v I' := by"
  },
  {
    "full_name": "Booleanisation.lift_le_lift",
    "file_path": "Mathlib/Order/Booleanisation.lean",
    "teorema": "theorem Booleanisation.lift_le_lift (a : α) (b : α) (α : Type u_1) : lift a ≤ lift b → a ≤ b := by"
  },
  {
    "full_name": "PowerBasis.equivAdjoinSimple_symm_aeval",
    "file_path": "Mathlib/FieldTheory/Adjoin.lean",
    "teorema": "lemma PowerBasis.equivAdjoinSimple_symm_aeval (K : Type u_1) (L : Type u_2) (f : K[X]) (pb : PowerBasis K L) : pb.equivAdjoinSimple.symm ((aeval pb.gen) f) = (aeval (AdjoinSimple.gen K pb.gen)) f := by"
  },
  {
    "full_name": "Fin.zero_add",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.zero_add (k : Fin n) (n : ℕ) : 0 + k = k := by"
  },
  {
    "full_name": "List.get_attach",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "lemma List.get_attach (L : List α) (i : Fin L.attach.length) (α : Type u) : ↑(L.attach.get i) = L.get ⟨↑i, ⋯⟩ := by"
  },
  {
    "full_name": "Polynomial.associated_of_dvd_of_natDegree_le",
    "file_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
    "teorema": "lemma Polynomial.associated_of_dvd_of_natDegree_le (K : Type u_1) (q : K[X]) : IsUnit q.leadingCoeff := by"
  },
  {
    "full_name": "Configuration.HasLines.exists_bijective_of_card_eq",
    "file_path": "Mathlib/Combinatorics/Configuration.lean",
    "teorema": "lemma Configuration.HasLines.exists_bijective_of_card_eq (L : Type u_2) (P : Type u_1) : ∃ f, Function.Bijective f ∧ ∀ (l : L), pointCount P l = lineCount L (f l) := by"
  },
  {
    "full_name": "CategoryTheory.Idempotents.split_iff_of_iso",
    "file_path": "Mathlib/CategoryTheory/Idempotents/Basic.lean",
    "teorema": "theorem CategoryTheory.Idempotents.split_iff_of_iso (C : Type u_1) (X : C) (p : X ⟶ X) : (∃ Y i e, i ≫ e = 𝟙 Y ∧ e ≫ i = p) ↔ ∃ Y' i' e', i' ≫ e' = 𝟙 Y' ∧ e' ≫ i' = p' := by"
  },
  {
    "full_name": "Cardinal.mk_bounded_subset_le",
    "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
    "teorema": "theorem Cardinal.mk_bounded_subset_le (c : Cardinal.{u}) (s : Set α) (α : Type u) : #{ t // t ⊆ s ∧ #↑t ≤ c } ≤ max #↑s ℵ₀ ^ c := by"
  },
  {
    "full_name": "Matrix.transpose_nonsing_inv",
    "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
    "teorema": "lemma Matrix.transpose_nonsing_inv (A : Matrix n n α) (n : Type u') (α : Type v) : A⁻¹ᵀ = Aᵀ⁻¹ := by"
  },
  {
    "full_name": "Fin.cons_rev",
    "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean",
    "teorema": "theorem Fin.cons_rev (a : α) (f : Fin n → α) (i : Fin (n + 1)) (n : ℕ) (α : Type u_1) : cons a f i.rev = snoc (f ∘ rev) a i := by"
  },
  {
    "full_name": "Nat.fib_dvd",
    "file_path": "Mathlib/Data/Nat/Fib/Basic.lean",
    "teorema": "theorem Nat.fib_dvd (m : ℕ) (n : ℕ) : fib m ∣ fib n := by"
  },
  {
    "full_name": "CategoryTheory.MorphismProperty.LeftFraction.map_ofHom",
    "file_path": "Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean",
    "teorema": "theorem CategoryTheory.MorphismProperty.LeftFraction.map_ofHom (C : Type u_1) (D : Type u_2) (L : C ⥤ D) (W : MorphismProperty C) (X : C) (Y : C) (f : X ⟶ Y) (hL : W.IsInvertedBy L) : (ofHom W f).map L hL = L.map f := by"
  },
  {
    "full_name": "FiniteField.isSquare_iff",
    "file_path": "Mathlib/FieldTheory/Finite/Basic.lean",
    "teorema": "lemma FiniteField.isSquare_iff (F : Type u_3) (a : F) : IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 := by"
  },
  {
    "full_name": "Seminorm.ball_finset_sup_eq_iInter",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "theorem Seminorm.ball_finset_sup_eq_iInter (E : Type u_7) (p : ι → Seminorm 𝕜 E) (r : ℝ) (s : Finset ι) (x : E) (ι : Type u_12) (𝕜 : Type u_3) : (s.sup p).ball x r = ⋂ i ∈ s, (p i).ball x r := by"
  },
  {
    "full_name": "Filter.EventuallyLE.mul_le_mul'",
    "file_path": "Mathlib/Order/Filter/Ring.lean",
    "teorema": "lemma Filter.EventuallyLE.mul_le_mul' (f₁ : α → β) (f₂ : α → β) (g₁ : α → β) (g₂ : α → β) (l : Filter α) (α : Type u) (β : Type v) : f₁ * g₁ ≤ᶠ[l] f₂ * g₂ := by"
  },
  {
    "full_name": "CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_sieve₁",
    "file_path": "Mathlib/CategoryTheory/Sites/OneHypercover.lean",
    "teorema": "theorem CategoryTheory.GrothendieckTopology.Cover.preOneHypercover_sieve₁ (C : Type u) (J : GrothendieckTopology C) (S : J.Cover X) (W : C) (X : C) (f₁ : S.Arrow) (f₂ : S.Arrow) (p₁ : W ⟶ f₁.Y) (p₂ : W ⟶ f₂.Y) : S.preOneHypercover.sieve₁ p₁ p₂ = ⊤ := by"
  },
  {
    "full_name": "Polynomial.nextCoeff_ne_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "lemma Polynomial.nextCoeff_ne_zero (R : Type u) (p : R[X]) : p.nextCoeff ≠ 0 ↔ p.natDegree ≠ 0 ∧ p.coeff (p.natDegree - 1) ≠ 0 := by"
  },
  {
    "full_name": "Mon_.mul_rightUnitor",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Mon_.lean",
    "teorema": "theorem Mon_.mul_rightUnitor (C : Type u₁) (M : Mon_ C) : (tensor_μ C (M.X, 𝟙_ C) (M.X, 𝟙_ C) ≫ (M.mul ⊗ (λ_ (𝟙_ C)).hom)) ≫ (ρ_ M.X).hom = ((ρ_ M.X).hom ⊗ (ρ_ M.X).hom) ≫ M.mul := by"
  },
  {
    "full_name": "slope_vadd_const",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean",
    "teorema": "theorem slope_vadd_const (E : Type u_2) (PE : Type u_3) (c : PE) (f : k → E) (k : Type u_1) : (slope fun x => f x +ᵥ c) = slope f := by"
  },
  {
    "full_name": "Set.le_chainHeight_add_nat_iff",
    "file_path": "Mathlib/Order/Height.lean",
    "teorema": "theorem Set.le_chainHeight_add_nat_iff (l : List α) (m : ℕ) (n : ℕ) (s : Set α) (α : Type u_1) : ↑n ≤ s.chainHeight + ↑m ↔ ∃ l ∈ s.subchain, n ≤ l.length + m := by"
  },
  {
    "full_name": "antisymm_iff",
    "file_path": "Mathlib/Order/RelClasses.lean",
    "teorema": "lemma antisymm_iff (a : α) (b : α) (r : α → α → Prop) (α : Type u) : a = b → r a b ∧ r b a := by"
  },
  {
    "full_name": "Finpartition.parts_top_subset",
    "file_path": "Mathlib/Order/Partition/Finpartition.lean",
    "teorema": "theorem Finpartition.parts_top_subset (a : α) (α : Type u_1) : ⊤.parts ⊆ {a} := by"
  },
  {
    "full_name": "CategoryTheory.Functor.quasiIso'_of_map_quasiIso'",
    "file_path": "Mathlib/Algebra/Homology/QuasiIso.lean",
    "teorema": "lemma CategoryTheory.Functor.quasiIso'_of_map_quasiIso' (A : Type u_2) (B : Type u_3) (C : HomologicalComplex A c) (D : HomologicalComplex A c) (F : A ⥤ B) (c : ComplexShape ι) (f : C ⟶ D) (i : ι) (ι : Type u_1) : IsIso (F.map ((homology'Functor A c i).map f)) := by"
  },
  {
    "full_name": "MeasureTheory.IsFundamentalDomain.essSup_measure_restrict",
    "file_path": "Mathlib/MeasureTheory/Group/FundamentalDomain.lean",
    "teorema": "theorem MeasureTheory.IsFundamentalDomain.essSup_measure_restrict (f : α → ℝ≥0∞) (s : Set α) (α : Type u_3) (μ : Measure α) : essSup f (μ.restrict s) = essSup f μ := by"
  },
  {
    "full_name": "Ideal.sup_mul_eq_of_coprime_right",
    "file_path": "Mathlib/RingTheory/Ideal/Operations.lean",
    "teorema": "theorem Ideal.sup_mul_eq_of_coprime_right (I : Ideal R) (J : Ideal R) (K : Ideal R) (R : Type u) : I ⊔ J * K = I ⊔ J := by"
  },
  {
    "full_name": "LinearMap.continuous_of_nonzero_on_open",
    "file_path": "Mathlib/Topology/Algebra/Module/FiniteDimension.lean",
    "teorema": "theorem LinearMap.continuous_of_nonzero_on_open (E : Type v) (l : E →ₗ[𝕜] 𝕜) (𝕜 : Type u) : Continuous ⇑l := by"
  },
  {
    "full_name": "MeasureTheory.zero_convolution",
    "file_path": "Mathlib/Analysis/Convolution.lean",
    "teorema": "lemma MeasureTheory.zero_convolution (E : Type uE) (F : Type uF) (G : Type uG) (L : E →L[𝕜] E' →L[𝕜] F) (g : G → E') (μ : Measure G) (𝕜 : Type u𝕜) : 0 ⋆[L, μ] g = 0 := by"
  },
  {
    "full_name": "Real.deriv_negMulLog",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
    "teorema": "theorem Real.deriv_negMulLog (x : ℝ) : deriv negMulLog x = -log x - 1 := by"
  },
  {
    "full_name": "CategoryTheory.TwoSquare.GuitartExact.vComp_iff_of_equivalences",
    "file_path": "Mathlib/CategoryTheory/GuitartExact/VerticalComposition.lean",
    "teorema": "theorem CategoryTheory.TwoSquare.GuitartExact.vComp_iff_of_equivalences (C₁ : Type u_1) (C₂ : Type u_2) (D₁ : Type u_4) (D₂ : Type u_5) (H₁ : C₁ ⥤ D₁) (H₂ : C₂ ⥤ D₂) (L₁ : C₁ ⥤ C₂) (R₁ : D₁ ⥤ D₂) (w : TwoSquare H₁ L₁ R₁ H₂) : (w.vComp w'.hom).GuitartExact ↔ w.GuitartExact := by"
  },
  {
    "full_name": "Polynomial.mkDerivation_X",
    "file_path": "Mathlib/Algebra/Polynomial/Derivation.lean",
    "teorema": "lemma Polynomial.mkDerivation_X (A : Type u_2) (R : Type u_1) (a : A) : ((mkDerivation R) a) X = a := by"
  },
  {
    "full_name": "Filter.principal_singleton",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.principal_singleton (a : α) (s : Set α) (α : Type u) : s ∈ 𝓟 {a} ↔ s ∈ pure a := by"
  },
  {
    "full_name": "ArithmeticFunction.IsMultiplicative.mul",
    "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean",
    "teorema": "lemma ArithmeticFunction.IsMultiplicative.mul (R : Type u_1) (f : ArithmeticFunction R) (g : ArithmeticFunction R) : (f * g).IsMultiplicative := by"
  },
  {
    "full_name": "LinearMap.range_inl",
    "file_path": "Mathlib/LinearAlgebra/Prod.lean",
    "teorema": "lemma LinearMap.range_inl (M : Type v) (M₂ : Type w) (R : Type u) : range (inl R M M₂) = ker (snd R M M₂) := by"
  },
  {
    "full_name": "LowerSet.coe_iSup₂",
    "file_path": "Mathlib/Order/UpperLower/Basic.lean",
    "teorema": "lemma LowerSet.coe_iSup₂ (f : (i : ι) → κ i → LowerSet α) (α : Type u_1) (ι : Sort u_4) (κ : ι → Sort u_5) : ↑(⨆ i, ⨆ j, f i j) = ⋃ i, ⋃ j, ↑(f i j) := by"
  },
  {
    "full_name": "List.kreplace_nodupKeys",
    "file_path": "Mathlib/Data/List/Sigma.lean",
    "teorema": "lemma List.kreplace_nodupKeys (a : α) (b : β a) (l : List (Sigma β)) (α : Type u) (β : α → Type v) : (kreplace a b l).NodupKeys ↔ l.NodupKeys := by"
  },
  {
    "full_name": "AkraBazziRecurrence.eventually_atTop_sumTransform_ge",
    "file_path": "Mathlib/Computability/AkraBazzi/AkraBazzi.lean",
    "teorema": "theorem AkraBazziRecurrence.eventually_atTop_sumTransform_ge (a : α → ℝ) (b : α → ℝ) (g : ℝ → ℝ) (r : α → ℕ → ℕ) (α : Type u_1) : ∃ c > 0, ∀ᶠ (n : ℕ) in atTop, ∀ (i : α), c * g ↑n ≤ sumTransform (p a b) g (r i n) n := by"
  },
  {
    "full_name": "iSup₂_disjoint_iff",
    "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean",
    "teorema": "lemma iSup₂_disjoint_iff (a : α) (f : (i : ι) → κ i → α) (α : Type u) (ι : Sort w) (κ : ι → Sort w') : Disjoint (⨆ i, ⨆ j, f i j) a ↔ ∀ (i : ι) (j : κ i), Disjoint (f i j) a := by"
  },
  {
    "full_name": "Polynomial.degree_map_eq_iff",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Lemmas.lean",
    "teorema": "lemma Polynomial.degree_map_eq_iff (R : Type u) (S : Type v) (f : R →+* S) (p : R[X]) : (map f p).degree = p.degree ↔ f p.leadingCoeff ≠ 0 ∨ p = 0 := by"
  },
  {
    "full_name": "prodXSubSMul.smul",
    "file_path": "Mathlib/Algebra/Polynomial/GroupRingAction.lean",
    "teorema": "theorem prodXSubSMul.smul (G : Type u_2) (R : Type u_3) (g : G) (x : R) : g • (X - C (ofQuotientStabilizer G x g')) = X - C (ofQuotientStabilizer G x (g • g')) := by"
  },
  {
    "full_name": "OreLocalization.mul_div_one",
    "file_path": "Mathlib/RingTheory/OreLocalization/Basic.lean",
    "teorema": "lemma OreLocalization.mul_div_one (R : Type u_1) (S : Submonoid R) (p : R) (r : R) (s : ↥S) : p /ₒ s * (r /ₒ 1) = p * r /ₒ s := by"
  },
  {
    "full_name": "Submonoid.coe_mul_self_eq",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Pointwise.lean",
    "teorema": "theorem Submonoid.coe_mul_self_eq (M : Type u_3) (s : Submonoid M) : ↑s * ↑s = ↑s := by"
  },
  {
    "full_name": "Ordinal.principal_mul_two",
    "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
    "teorema": "lemma Ordinal.principal_mul_two (a : Ordinal.{u_1}) (b : Ordinal.{u_1}) : (fun x x_1 => x * x_1) a b < 2 := by"
  },
  {
    "full_name": "Rel.preimage_top",
    "file_path": "Mathlib/Data/Rel.lean",
    "teorema": "theorem Rel.preimage_top (s : Set β) (β : Type u_2) : ⊤.preimage s = Set.univ := by"
  },
  {
    "full_name": "aemeasurable_union_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean",
    "teorema": "lemma aemeasurable_union_iff (f : α → β) (s : Set α) (t : Set α) (α : Type u_2) (β : Type u_3) (μ : Measure α) : AEMeasurable f (μ.restrict (s ∪ t)) ↔ AEMeasurable f (μ.restrict s) ∧ AEMeasurable f (μ.restrict t) := by"
  },
  {
    "full_name": "TopologicalSpace.NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent",
    "file_path": "Mathlib/Topology/NoetherianSpace.lean",
    "teorema": "theorem TopologicalSpace.NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent (Z : Set α) (α : Type u_1) : ∃ o, IsOpen o ∧ o ≠ ∅ ∧ o ≤ Z := by"
  },
  {
    "full_name": "List.Ico.filter_le_of_top_le",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "teorema": "lemma List.Ico.filter_le_of_top_le (k : ℕ) (l : ℕ) : ¬decide (l ≤ k) = true := by"
  },
  {
    "full_name": "Submodule.map_unop_mul",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "lemma Submodule.map_unop_mul (M : Submodule R Aᵐᵒᵖ) (N : Submodule R Aᵐᵒᵖ) (R : Type u) : map (↑(opLinearEquiv R)) (map (↑(opLinearEquiv R).symm) (M * N)) = map (↑(opLinearEquiv R)) (map (↑(opLinearEquiv R).symm) N * map (↑(opLinearEquiv R).symm) M) := by"
  },
  {
    "full_name": "MeasureTheory.measure_union_add_inter₀'",
    "file_path": "Mathlib/MeasureTheory/Measure/NullMeasurable.lean",
    "teorema": "lemma MeasureTheory.measure_union_add_inter₀' (s : Set α) (t : Set α) (α : Type u_2) (μ : Measure α) : μ (s ∪ t) + μ (s ∩ t) = μ s + μ t := by"
  },
  {
    "full_name": "Complex.abs_cpow_inv_nat",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "theorem Complex.abs_cpow_inv_nat (n : ℕ) (x : ℂ) : abs (x ^ (↑n)⁻¹) = abs x ^ (↑n)⁻¹ := by"
  },
  {
    "full_name": "Nat.add_pos_iff_pos_or_pos",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "theorem Nat.add_pos_iff_pos_or_pos (m : ℕ) (n : ℕ) : 0 < m + n ↔ 0 < m ∨ 0 < n := by"
  },
  {
    "full_name": "Finset.nonempty_Ico",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "teorema": "lemma Finset.nonempty_Ico (a : α) (b : α) (α : Type u_2) : (Ico a b).Nonempty ↔ a < b := by"
  },
  {
    "full_name": "not_summable_of_ratio_norm_eventually_ge",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "lemma not_summable_of_ratio_norm_eventually_ge (f : ℕ → α) (α : Type u_4) : ¬Summable f := by"
  },
  {
    "full_name": "MultilinearMap.map_update_sum",
    "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean",
    "teorema": "theorem MultilinearMap.map_update_sum (M₁ : ι → Type v₁) (M₂ : Type v₂) (R : Type uR) (f : MultilinearMap R M₁ M₂) (g : α → M₁ i) (i : ι) (m : (i : ι) → M₁ i) (t : Finset α) (α : Type u_2) (ι : Type uι) : f (update m i (∑ a ∈ t, g a)) = ∑ a ∈ t, f (update m i (g a)) := by"
  },
  {
    "full_name": "Ordinal.log_eq_zero",
    "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
    "teorema": "theorem Ordinal.log_eq_zero (b : Ordinal.{u_1}) (o : Ordinal.{u_1}) : log b o = 0 := by"
  },
  {
    "full_name": "MeasureTheory.Measure.snd_prod",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "lemma MeasureTheory.Measure.snd_prod (α : Type u_1) (β : Type u_3) (μ : Measure α) (ν : Measure β) : (μ.prod ν).snd = ν := by"
  },
  {
    "full_name": "UpperHalfPlane.dist_triangle",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean",
    "teorema": "lemma UpperHalfPlane.dist_triangle (a : ℍ) (b : ℍ) (c : ℍ) : dist a c ≤ dist a b + dist b c := by"
  },
  {
    "full_name": "Matrix.Pivot.listTransvecCol_mul_last_row_drop",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Transvection.lean",
    "teorema": "lemma Matrix.Pivot.listTransvecCol_mul_last_row_drop (M : Matrix (Fin r ⊕ Unit) (Fin r ⊕ Unit) 𝕜) (i : Fin r ⊕ Unit) (k : ℕ) (r : ℕ) (𝕜 : Type u_3) : ((List.drop k (listTransvecCol M)).prod * M) (inr ()) i = M (inr ()) i := by"
  },
  {
    "full_name": "TrivSqZeroExt.map_comp_map",
    "file_path": "Mathlib/Algebra/TrivSqZeroExt.lean",
    "teorema": "theorem TrivSqZeroExt.map_comp_map (M : Type v) (N : Type u_3) (P : Type u_4) (R : Type u) (f : M →ₗ[R'] N) (g : N →ₗ[R'] P) : map (g ∘ₗ f) = (map g).comp (map f) := by"
  },
  {
    "full_name": "Dense.biUnion_uniformity_ball",
    "file_path": "Mathlib/Topology/UniformSpace/Basic.lean",
    "teorema": "lemma Dense.biUnion_uniformity_ball (U : Set (α × α)) (s : Set α) (α : Type ua) : ⋃ x ∈ s, ball x U = univ := by"
  },
  {
    "full_name": "units_smul_eq_self_iff",
    "file_path": "Mathlib/LinearAlgebra/Ray.lean",
    "teorema": "theorem units_smul_eq_self_iff (M : Type u_2) (R : Type u_1) (u : Rˣ) (v : Module.Ray R M) : u • v = v ↔ 0 < ↑u := by"
  },
  {
    "full_name": "List.nodup_permutations'Aux_iff",
    "file_path": "Mathlib/Data/List/Perm.lean",
    "teorema": "theorem List.nodup_permutations'Aux_iff (s : List α) (x : α) (α : Type u_1) : (permutations'Aux x s).Nodup ↔ x ∉ s := by"
  },
  {
    "full_name": "Finite.card_le_of_injective",
    "file_path": "Mathlib/Data/Finite/Card.lean",
    "teorema": "lemma Finite.card_le_of_injective (α : Type u_1) (β : Type u_2) : Nat.card α ≤ Nat.card β := by"
  },
  {
    "full_name": "EllipticCurve.ofJ1728_j",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean",
    "teorema": "lemma EllipticCurve.ofJ1728_j (R : Type u) : (ofJ1728 R).j = 1728 := by"
  },
  {
    "full_name": "LieModule.mem_weightSpace",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "lemma LieModule.mem_weightSpace (L : Type u_3) (M : Type u_4) (R : Type u_2) (m : M) (χ : L → R) : m ∈ weightSpace M χ ↔ ∀ (x : L), ∃ k, (((toEnd R L M) x - χ x • 1) ^ k) m = 0 := by"
  },
  {
    "full_name": "IsClosed.exists_closed_singleton",
    "file_path": "Mathlib/Topology/Separation.lean",
    "teorema": "theorem IsClosed.exists_closed_singleton (S : Set X) (X : Type u_1) : ∃ x ∈ S, IsClosed {x} := by"
  },
  {
    "full_name": "Polynomial.cyclotomic_expand_eq_cyclotomic_mul",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean",
    "teorema": "lemma Polynomial.cyclotomic_expand_eq_cyclotomic_mul (R : Type u_1) (n : ℕ) (p : ℕ) : (expand R p) (cyclotomic n R) = cyclotomic (n * p) R * cyclotomic n R := by"
  },
  {
    "full_name": "StrictAnti.prod_map",
    "file_path": "Mathlib/Order/Monotone/Basic.lean",
    "teorema": "lemma StrictAnti.prod_map (a : α × β) (b : α × β) (f : α → γ) (g : β → δ) (α : Type u) (β : Type v) (γ : Type w) (δ : Type u_2) : a < b → Prod.map f g b < Prod.map f g a := by"
  },
  {
    "full_name": "PiLp.norm_equiv_symm_const",
    "file_path": "Mathlib/Analysis/NormedSpace/PiLp.lean",
    "teorema": "lemma PiLp.norm_equiv_symm_const (b : β) (p : ℝ≥0∞) (β : Type u_5) (ι : Type u_2) : ↑(↑(Fintype.card ι) ^ (1 / p).toReal * ‖b‖₊) = ↑↑(Fintype.card ι) ^ (1 / p).toReal * ‖b‖ := by"
  },
  {
    "full_name": "Mathlib.Meta.NormNum.isInt_eq_false",
    "file_path": "Mathlib/Tactic/NormNum/Eq.lean",
    "teorema": "lemma Mathlib.Meta.NormNum.isInt_eq_false (n✝ : ℤ) (n✝¹ : ℤ) : ¬↑n✝¹ = ↑n✝ := by"
  },
  {
    "full_name": "PosSMulReflectLT.of_pos",
    "file_path": "Mathlib/Algebra/Order/Module/Defs.lean",
    "teorema": "theorem PosSMulReflectLT.of_pos (b₁ : β) (b₂ : β) (β : Type u_2) : b₁ < b₂ := by"
  },
  {
    "full_name": "toIcoDiv_add_left",
    "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean",
    "teorema": "theorem toIcoDiv_add_left (a : α) (b : α) (hp : 0 < p) (p : α) (α : Type u_1) : toIcoDiv hp a (p + b) = toIcoDiv hp a b + 1 := by"
  },
  {
    "full_name": "AkraBazziRecurrence.GrowsPolynomially.of_isTheta",
    "file_path": "Mathlib/Computability/AkraBazzi/GrowsPolynomially.lean",
    "teorema": "lemma AkraBazziRecurrence.GrowsPolynomially.of_isTheta (f : ℝ → ℝ) : GrowsPolynomially f := by"
  },
  {
    "full_name": "IsOrderRightAdjoint.orderIso_comp",
    "file_path": "Mathlib/Order/SemiconjSup.lean",
    "teorema": "theorem IsOrderRightAdjoint.orderIso_comp (e : β ≃o γ) (f : α → β) (g : β → α) (y : γ) (α : Type u_1) (β : Type u_2) (γ : Type u_3) : IsLUB {x | (⇑e ∘ f) x ≤ y} ((g ∘ ⇑e.symm) y) := by"
  },
  {
    "full_name": "List.mem_dedup",
    "file_path": "Mathlib/Data/List/Dedup.lean",
    "teorema": "lemma List.mem_dedup (a : α) (l : List α) (α : Type u) : a ∈ l.dedup ↔ a ∈ l := by"
  },
  {
    "full_name": "HasDerivAt.mul_const",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean",
    "teorema": "theorem HasDerivAt.mul_const (c : 𝕜 → 𝔸) (d : 𝔸) (u : 𝕜 → 𝕜') (x : 𝕜) (𝔸 : Type u_3) (𝕜 : Type u) : HasDerivAt (fun y => c y * d) (c' * d) x := by"
  },
  {
    "full_name": "MeasureTheory.lmarginal_update_of_mem",
    "file_path": "Mathlib/MeasureTheory/Integral/Marginal.lean",
    "teorema": "theorem MeasureTheory.lmarginal_update_of_mem (f : ((i : δ) → π i) → ℝ≥0∞) (i : δ) (x : (i : δ) → π i) (y : π i) (δ : Type u_1) (μ : (i : δ) → Measure (π i)) (π : δ → Type u_3) : (∫⋯∫⁻_s, f ∂μ) (update x i y) = (∫⋯∫⁻_s, f ∂μ) x := by"
  },
  {
    "full_name": "Set.Icc_eq_singleton_iff",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Icc_eq_singleton_iff (a : α) (b : α) (c : α) (α : Type u_1) : Icc a b = {c} ↔ a = c ∧ b = c := by"
  },
  {
    "full_name": "Sym.ofVector_cons",
    "file_path": "Mathlib/Data/Sym/Basic.lean",
    "teorema": "theorem Sym.ofVector_cons (a : α) (n : ℕ) (v : Vector α n) (α : Type u_1) : ofVector (a ::ᵥ v) = a ::ₛ ofVector v := by"
  },
  {
    "full_name": "List.le_findIdx_of_not",
    "file_path": "Mathlib/Data/List/Indexes.lean",
    "teorema": "lemma List.le_findIdx_of_not (i : ℕ) (p : α → Bool) (xs : List α) (α : Type u) : i ≤ findIdx p xs := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_zero",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "lemma MeasureTheory.lintegral_zero (α : Type u_1) (μ : Measure α) : ∫⁻ (x : α), 0 ∂μ = 0 := by"
  },
  {
    "full_name": "Complex.coe_basisOneI",
    "file_path": "Mathlib/Data/Complex/Module.lean",
    "teorema": "lemma Complex.coe_basisOneI (i : Fin 2) (j : Fin 2) : (basisOneI.repr (![1, I] i)) j = (Finsupp.single i 1) j := by"
  },
  {
    "full_name": "Finset.noncommProd_commute",
    "file_path": "Mathlib/Data/Finset/NoncommProd.lean",
    "teorema": "theorem Finset.noncommProd_commute (comm : (↑s).Pairwise fun a b => Commute (f a) (f b)) (f : α → β) (s : Finset α) (y : β) (α : Type u_3) (β : Type u_4) : Commute y (s.noncommProd f comm) := by"
  },
  {
    "full_name": "Finset.Ioc_subset_Iic_self",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "teorema": "theorem Finset.Ioc_subset_Iic_self (a : α) (b : α) (α : Type u_2) : Ioc a b ⊆ Iic b := by"
  },
  {
    "full_name": "ExteriorAlgebra.ι_ne_one",
    "file_path": "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean",
    "teorema": "lemma ExteriorAlgebra.ι_ne_one (M : Type u2) (R : Type u1) (x : M) : (ι R) x ≠ 1 := by"
  },
  {
    "full_name": "CategoryTheory.MorphismProperty.IsInvertedBy.unop",
    "file_path": "Mathlib/CategoryTheory/MorphismProperty/IsInvertedBy.lean",
    "teorema": "lemma CategoryTheory.MorphismProperty.IsInvertedBy.unop (C : Type u) (L : Cᵒᵖ ⥤ Dᵒᵖ) (X : C) (Y : C) (f : X ⟶ Y) : IsIso (L.unop.map f) := by"
  },
  {
    "full_name": "Metric.mem_ball_comm",
    "file_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
    "teorema": "theorem Metric.mem_ball_comm (x : α) (y : α) (α : Type u) (ε : ℝ) : x ∈ ball y ε ↔ y ∈ ball x ε := by"
  },
  {
    "full_name": "lp.coeFn_sum",
    "file_path": "Mathlib/Analysis/NormedSpace/lpSpace.lean",
    "teorema": "lemma lp.coeFn_sum (E : α → Type u_2) (f : ι → ↥(lp E p)) (p : ℝ≥0∞) (s : Finset ι) (α : Type u_1) (ι : Type u_3) : ↑(∑ i ∈ s, f i) = ∑ i ∈ s, ↑(f i) := by"
  },
  {
    "full_name": "isLUB_iff_sSup_eq",
    "file_path": "Mathlib/Order/CompleteLattice.lean",
    "teorema": "theorem isLUB_iff_sSup_eq (a : α) (s : Set α) (α : Type u_1) : sSup s = a → IsLUB s a := by"
  },
  {
    "full_name": "denselyOrdered_orderDual",
    "file_path": "Mathlib/Order/Basic.lean",
    "teorema": "theorem denselyOrdered_orderDual (α : Type u_2) : DenselyOrdered αᵒᵈ → DenselyOrdered α := by"
  },
  {
    "full_name": "range_two_mul",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "theorem range_two_mul (a : α✝) (α : Type u_5) : (Set.range fun x => 2 * x) = {a | Even a} := by"
  },
  {
    "full_name": "AlgebraicGeometry.Scheme.map_basicOpen",
    "file_path": "Mathlib/AlgebraicGeometry/Restrict.lean",
    "teorema": "lemma AlgebraicGeometry.Scheme.map_basicOpen (U : Opens ↑↑X.toPresheafedSpace) (X : Scheme) (r : ↑Γ(X ∣_ᵤ U, ⊤)) : ιOpens U ''ᵁ (X ∣_ᵤ U).basicOpen r = X.basicOpen r := by"
  },
  {
    "full_name": "PMF.pure_bind",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Monad.lean",
    "teorema": "lemma PMF.pure_bind (a : α) (f : α → PMF β) (α : Type u_1) (β : Type u_2) : (pure a).bind f = f a := by"
  },
  {
    "full_name": "MeasureTheory.Measure.rnDeriv_withDensity_left",
    "file_path": "Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean",
    "teorema": "lemma MeasureTheory.Measure.rnDeriv_withDensity_left (f : α → ℝ≥0∞) (α : Type u_1) (μ : Measure α) (ν : Measure α) : (μ.withDensity f).rnDeriv ν =ᶠ[ae ν] fun x => f x * μ.rnDeriv ν x := by"
  },
  {
    "full_name": "lp.norm_apply_le_norm",
    "file_path": "Mathlib/Analysis/NormedSpace/lpSpace.lean",
    "teorema": "lemma lp.norm_apply_le_norm (E : α → Type u_2) (f : ↥(lp E p)) (i : α) (p : ℝ≥0∞) (α : Type u_1) : ‖↑f i‖ ≤ ‖f‖ := by"
  },
  {
    "full_name": "Concept.ext",
    "file_path": "Mathlib/Order/Concept.lean",
    "teorema": "lemma Concept.ext (c : Concept α β r) (d : Concept α β r) (r : α → β → Prop) (α : Type u_2) (β : Type u_3) : c = d := by"
  },
  {
    "full_name": "SemidirectProduct.map_inr",
    "file_path": "Mathlib/GroupTheory/SemidirectProduct.lean",
    "teorema": "lemma SemidirectProduct.map_inr (G : Type u_2) (G₁ : Type u_5) (N : Type u_1) (N₁ : Type u_4) (f₁ : N →* N₁) (f₂ : G →* G₁) (g : G) (h : ∀ (g : G), f₁.comp (MulEquiv.toMonoidHom (φ g)) = (MulEquiv.toMonoidHom (φ₁ (f₂ g))).comp f₁) (φ : G →* MulAut N) (φ₁ : G₁ →* MulAut N₁) : (map f₁ f₂ h) (inr g) = inr (f₂ g) := by"
  },
  {
    "full_name": "convex_iff_ordConnected",
    "file_path": "Mathlib/Analysis/Convex/Basic.lean",
    "teorema": "theorem convex_iff_ordConnected (s : Set 𝕜) (𝕜 : Type u_1) : Convex 𝕜 s ↔ s.OrdConnected := by"
  },
  {
    "full_name": "Basis.flag_le_ker_coord_iff",
    "file_path": "Mathlib/LinearAlgebra/Basis/Flag.lean",
    "teorema": "theorem Basis.flag_le_ker_coord_iff (M : Type u_2) (R : Type u_1) (b : Basis (Fin n) R M) (k : Fin (n + 1)) (l : Fin n) (n : ℕ) : b.flag k ≤ LinearMap.ker (b.coord l) ↔ k ≤ l.castSucc := by"
  },
  {
    "full_name": "ConjAct.orbitRel_conjAct",
    "file_path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean",
    "teorema": "lemma ConjAct.orbitRel_conjAct (G : Type u_3) (g : G) (h : G) : (orbitRel (ConjAct G) G).Rel g h = IsConj g h := by"
  },
  {
    "full_name": "IsPreconnected.eq_or_eq_neg_of_sq_eq",
    "file_path": "Mathlib/Topology/Algebra/Field.lean",
    "teorema": "theorem IsPreconnected.eq_or_eq_neg_of_sq_eq (S : Set α) (f : α → 𝕜) (g : α → 𝕜) (α : Type u_2) (𝕜 : Type u_3) : EqOn f g S ∨ EqOn f (-g) S := by"
  },
  {
    "full_name": "Polynomial.not_irreducible_C",
    "file_path": "Mathlib/Algebra/Polynomial/FieldDivision.lean",
    "teorema": "theorem Polynomial.not_irreducible_C (R : Type u) (x : R) : ¬Irreducible (C x) := by"
  },
  {
    "full_name": "EisensteinSeries.r1_eq",
    "file_path": "Mathlib/NumberTheory/ModularForms/EisensteinSeries/UniformConvergence.lean",
    "teorema": "lemma EisensteinSeries.r1_eq (z : ℍ) : r1 z = 1 / ((z.re / z.im) ^ 2 + 1) := by"
  },
  {
    "full_name": "Metric.glueDist_swap",
    "file_path": "Mathlib/Topology/MetricSpace/Gluing.lean",
    "teorema": "theorem Metric.glueDist_swap (X : Type u) (Y : Type v) (Z : Type w) (val✝ : Y) (val✝¹ : X) (Φ : Z → X) (Ψ : Z → Y) (ε : ℝ) : glueDist Ψ Φ ε (Sum.inl val✝¹).swap (Sum.inr val✝).swap = glueDist Φ Ψ ε (Sum.inl val✝¹) (Sum.inr val✝) := by"
  },
  {
    "full_name": "Real.isConjExponent_iff_eq_conjExponent",
    "file_path": "Mathlib/Data/Real/ConjExponents.lean",
    "teorema": "lemma Real.isConjExponent_iff_eq_conjExponent (p : ℝ) (q : ℝ) : p⁻¹ + q⁻¹ = 1 := by"
  },
  {
    "full_name": "NNReal.tendsto_sum_nat_add",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "lemma NNReal.tendsto_sum_nat_add (f : ℕ → ℝ≥0) : Tendsto (fun i => ∑' (k : ℕ), f (k + i)) atTop (𝓝 0) := by"
  },
  {
    "full_name": "List.formPerm_apply_get_length",
    "file_path": "Mathlib/GroupTheory/Perm/List.lean",
    "teorema": "lemma List.formPerm_apply_get_length (x : α) (xs : List α) (α : Type u_1) : xs.length < (x :: xs).length := by"
  },
  {
    "full_name": "Polynomial.natDegree_C_add",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "theorem Polynomial.natDegree_C_add (R : Type u) (a : R) (p : R[X]) : (C a + p).natDegree = p.natDegree := by"
  },
  {
    "full_name": "AffineSubspace.wOppSide_iff_exists_left",
    "file_path": "Mathlib/Analysis/Convex/Side.lean",
    "teorema": "theorem AffineSubspace.wOppSide_iff_exists_left (P : Type u_4) (R : Type u_1) (p₁ : P) (s : AffineSubspace R P) (x : P) (y : P) : s.WOppSide x y ↔ x ∈ s ∨ ∃ p₂ ∈ s, SameRay R (x -ᵥ p₁) (p₂ -ᵥ y) := by"
  },
  {
    "full_name": "Int.neg_pred",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "teorema": "theorem Int.neg_pred (a : ℤ) : -a.pred = (-a).succ := by"
  },
  {
    "full_name": "FractionalIdeal.coe_spanSingleton",
    "file_path": "Mathlib/RingTheory/FractionalIdeal/Operations.lean",
    "teorema": "lemma FractionalIdeal.coe_spanSingleton (P : Type u_2) (R : Type u_1) (S : Submonoid R) (x : P) : ↑(spanSingleton S x) = span R {x} := by"
  },
  {
    "full_name": "MeasureTheory.setLIntegral_tilted",
    "file_path": "Mathlib/MeasureTheory/Measure/Tilted.lean",
    "teorema": "theorem MeasureTheory.setLIntegral_tilted (f : α → ℝ) (g : α → ℝ≥0∞) (s : Set α) (α : Type u_1) (μ : Measure α) : ∫⁻ (x : α) in s, g x ∂μ.tilted f = ∫⁻ (x : α) in s, ENNReal.ofReal (rexp (f x) / ∫ (x : α), rexp (f x) ∂μ) * g x ∂μ := by"
  },
  {
    "full_name": "isPathConnected_iff_eq",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "teorema": "theorem isPathConnected_iff_eq (F : Set X) (X : Type u_1) (x : X) : IsPathConnected F ↔ ∃ x ∈ F, pathComponentIn x F = F := by"
  },
  {
    "full_name": "Metric.Sigma.fst_eq_of_dist_lt_one",
    "file_path": "Mathlib/Topology/MetricSpace/Gluing.lean",
    "teorema": "theorem Metric.Sigma.fst_eq_of_dist_lt_one (E : ι → Type u_2) (x : (i : ι) × E i) (y : (i : ι) × E i) (ι : Type u_1) : x.fst = y.fst := by"
  },
  {
    "full_name": "Polynomial.reverse_natDegree",
    "file_path": "Mathlib/Algebra/Polynomial/Reverse.lean",
    "teorema": "theorem Polynomial.reverse_natDegree (R : Type u_1) (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree := by"
  },
  {
    "full_name": "IsometryEquiv.image_closedBall",
    "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean",
    "teorema": "lemma IsometryEquiv.image_closedBall (h : α ≃ᵢ β) (r : ℝ) (x : α) (α : Type u) (β : Type v) : ⇑h '' Metric.closedBall x r = Metric.closedBall (h x) r := by"
  },
  {
    "full_name": "CategoryTheory.Limits.CoconeMorphism.ext",
    "file_path": "Mathlib/CategoryTheory/Limits/Cones.lean",
    "teorema": "theorem CategoryTheory.Limits.CoconeMorphism.ext (C : Type u₃) (F : J ⥤ C) (J : Type u₁) (c : Cocone F) (f : c ⟶ c') (g : c ⟶ c') : f = g := by"
  },
  {
    "full_name": "Function.Periodic.const_sub",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "theorem Function.Periodic.const_sub (a : α) (c : α) (f : α → β) (x : α) (α : Type u_1) (β : Type u_2) : (fun x => f (a - x)) (x + c) = (fun x => f (a - x)) x := by"
  },
  {
    "full_name": "ENNReal.toReal_eq_toReal_iff",
    "file_path": "Mathlib/Data/ENNReal/Basic.lean",
    "teorema": "lemma ENNReal.toReal_eq_toReal_iff (x : ℝ≥0∞) (y : ℝ≥0∞) : x.toReal = y.toReal ↔ x = y ∨ x = 0 ∧ y = ⊤ ∨ x = ⊤ ∧ y = 0 := by"
  },
  {
    "full_name": "RCLike.smul_re",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "theorem RCLike.smul_re (K : Type u_1) (r : ℝ) (z : K) : re (r • z) = r * re z := by"
  },
  {
    "full_name": "Set.encard_eq_two",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "theorem Set.encard_eq_two (s : Set α) (α : Type u_1) : s.encard = 2 ↔ ∃ x y, x ≠ y ∧ s = {x, y} := by"
  },
  {
    "full_name": "MeasureTheory.FiniteMeasure.injective_toWeakDualBCNN",
    "file_path": "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean",
    "teorema": "theorem MeasureTheory.FiniteMeasure.injective_toWeakDualBCNN : Injective toWeakDualBCNN := by"
  },
  {
    "full_name": "Nat.digits_lt_base",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "teorema": "theorem Nat.digits_lt_base (b : ℕ) (d : ℕ) : d < b := by"
  },
  {
    "full_name": "Matrix.exp_neg",
    "file_path": "Mathlib/Analysis/NormedSpace/MatrixExponential.lean",
    "teorema": "theorem Matrix.exp_neg (A : Matrix m m 𝔸) (m : Type u_2) (𝔸 : Type u_6) (𝕂 : Type u_1) : exp 𝕂 (-A) = (exp 𝕂 A)⁻¹ := by"
  },
  {
    "full_name": "Nat.le_div_two_iff_mul_two_le",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "teorema": "theorem Nat.le_div_two_iff_mul_two_le (m : ℕ) (n : ℕ) : m ≤ n / 2 ↔ ↑m * 2 ≤ ↑n := by"
  },
  {
    "full_name": "Int.floor_neg",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem Int.floor_neg (a : α) (z : ℤ) (α : Type u_2) : z ≤ ⌊-a⌋ ↔ z ≤ -⌈a⌉ := by"
  },
  {
    "full_name": "MeasureTheory.Measure.prod_sum",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "theorem MeasureTheory.Measure.prod_sum (m : ι → Measure α) (α : Type u_1) (ι : Type u_7) : (sum m).prod (sum m') = sum fun p => (m p.1).prod (m' p.2) := by"
  },
  {
    "full_name": "Nat.dist_cast_rat",
    "file_path": "Mathlib/Topology/Instances/Rat.lean",
    "teorema": "lemma Nat.dist_cast_rat (x : ℕ) (y : ℕ) : dist ↑x ↑y = dist x y := by"
  },
  {
    "full_name": "Profinite.finiteCoproduct.ι_injective",
    "file_path": "Mathlib/Topology/Category/Profinite/Limits.lean",
    "teorema": "theorem Profinite.finiteCoproduct.ι_injective (X : α → Profinite) (a : α) (α : Type w) : Function.Injective ⇑(ι X a) := by"
  },
  {
    "full_name": "Turing.ListBlank.ext",
    "file_path": "Mathlib/Computability/TuringMachine.lean",
    "teorema": "lemma Turing.ListBlank.ext (L₁ : ListBlank Γ) (L₂ : ListBlank Γ) (Γ : Type u_1) : (∀ (i_1 : ℕ), L₁.nth i_1 = L₂.nth i_1) → L₁ = L₂ := by"
  },
  {
    "full_name": "Surreal.Multiplication.P1_of_ih",
    "file_path": "Mathlib/SetTheory/Surreal/Multiplication.lean",
    "teorema": "lemma Surreal.Multiplication.P1_of_ih (x : PGame) (y : PGame) : (x * y).Numeric := by"
  },
  {
    "full_name": "IntermediateField.isSplittingField_iSup",
    "file_path": "Mathlib/FieldTheory/Adjoin.lean",
    "teorema": "lemma IntermediateField.isSplittingField_iSup (K : Type u_3) (L : Type u_4) (p : ι → K[X]) (s : Finset ι) (t : ι → IntermediateField K L) (ι : Type u_5) : IsSplittingField K (↥(⨆ i ∈ s, t i)) (∏ i ∈ s, p i) := by"
  },
  {
    "full_name": "Real.sInf_le_sSup",
    "file_path": "Mathlib/Data/Real/Archimedean.lean",
    "teorema": "lemma Real.sInf_le_sSup (s : Set ℝ) : sInf s ≤ sSup s := by"
  },
  {
    "full_name": "LieModule.isCompl_weightSpace_zero_posFittingComp",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "theorem LieModule.isCompl_weightSpace_zero_posFittingComp (L : Type u_3) (M : Type u_4) (R : Type u_2) : IsCompl (weightSpace M 0) (posFittingComp R L M) := by"
  },
  {
    "full_name": "Fintype.mem_piFinset",
    "file_path": "Mathlib/Data/Fintype/Pi.lean",
    "teorema": "lemma Fintype.mem_piFinset (f : (a : α) → δ a) (t : (a : α) → Finset (δ a)) (α : Type u_1) (δ : α → Type u_3) : f ∈ piFinset t ↔ ∀ (a : α), f a ∈ t a := by"
  },
  {
    "full_name": "Set.image_id_eq",
    "file_path": "Mathlib/Data/Set/Image.lean",
    "teorema": "theorem Set.image_id_eq : image id = id := by"
  },
  {
    "full_name": "Complex.Gamma_integrand_deriv_integrable_A",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean",
    "teorema": "lemma Complex.Gamma_integrand_deriv_integrable_A (X : ℝ) (s : ℂ) : IntervalIntegrable (fun x => -(↑(rexp (-x)) * ↑x ^ s)) volume 0 X := by"
  },
  {
    "full_name": "Traversable.foldl_toList",
    "file_path": "Mathlib/Control/Fold.lean",
    "teorema": "theorem Traversable.foldl_toList (f : α → β → α) (t : Type u → Type u) (x : α) (xs : t β) (α : Type u) (β : Type u) : foldl f x xs = List.foldl f x (toList xs) := by"
  },
  {
    "full_name": "Polynomial.trinomial_leading_coeff'",
    "file_path": "Mathlib/Algebra/Polynomial/UnitTrinomial.lean",
    "teorema": "lemma Polynomial.trinomial_leading_coeff' (R : Type u_1) (k : ℕ) (m : ℕ) (n : ℕ) (u : R) (v : R) (w : R) : (trinomial k m n u v w).coeff n = w := by"
  },
  {
    "full_name": "AddSubgroup.norm_normedMk_le",
    "file_path": "Mathlib/Analysis/Normed/Group/Quotient.lean",
    "teorema": "theorem AddSubgroup.norm_normedMk_le (M : Type u_1) (S : AddSubgroup M) (m : M) : ‖S.normedMk m‖ ≤ 1 * ‖m‖ := by"
  },
  {
    "full_name": "EuclideanGeometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean",
    "teorema": "theorem EuclideanGeometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi (P : Type u_2) (p1 : P) (p2 : P) (p3 : P) (p4 : P) (p5 : P) : ∠ p1 p5 p2 = ∠ p3 p5 p4 := by"
  },
  {
    "full_name": "Multiset.eq_union_right",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.eq_union_right (s : Multiset α) (t : Multiset α) (α : Type u_1) : s ∪ t = t := by"
  },
  {
    "full_name": "EReal.inv_pos_of_pos_ne_top",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "theorem EReal.inv_pos_of_pos_ne_top (a : EReal) : 0 < a⁻¹ := by"
  },
  {
    "full_name": "LinearMap.charpoly_natDegree",
    "file_path": "Mathlib/LinearAlgebra/Charpoly/Basic.lean",
    "teorema": "lemma LinearMap.charpoly_natDegree (M : Type v) (R : Type u) (f : M →ₗ[R] M) : f.charpoly.natDegree = finrank R M := by"
  },
  {
    "full_name": "Batteries.BinomialHeap.Imp.Heap.WF.merge'",
    "file_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "teorema": "lemma Batteries.BinomialHeap.Imp.Heap.WF.merge' (le : α✝ → α✝ → Bool) (n : Nat) (s₁ : Heap α✝) (s₂ : Heap α✝) : WF le n (merge le s₁ s₂) ∧ ((s₁.rankGT n ↔ s₂.rankGT n) → (merge le s₁ s₂).rankGT n) := by"
  },
  {
    "full_name": "Filter.HasBasis.equicontinuousAt_iff",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "theorem Filter.HasBasis.equicontinuousAt_iff (F : ι → X → α) (X : Type u_3) (p₁ : κ₁ → Prop) (p₂ : κ₂ → Prop) (s₁ : κ₁ → Set X) (s₂ : κ₂ → Set (α × α)) (x₀ : X) (α : Type u_7) (ι : Type u_1) (κ₁ : Type u_13) (κ₂ : Type u_14) : EquicontinuousAt F x₀ ↔ ∀ (k₂ : κ₂), p₂ k₂ → ∃ k₁, p₁ k₁ ∧ ∀ x ∈ s₁ k₁, ∀ (i : ι), (F i x₀, F i x) ∈ s₂ k₂ := by"
  },
  {
    "full_name": "bddBelow_closure",
    "file_path": "Mathlib/Topology/Order/OrderClosed.lean",
    "teorema": "lemma bddBelow_closure (s : Set α) (α : Type u) : BddBelow (closure s) ↔ BddBelow s := by"
  },
  {
    "full_name": "Subring.closure_induction'",
    "file_path": "Mathlib/Algebra/Ring/Subring/Basic.lean",
    "teorema": "theorem Subring.closure_induction' (R : Type u) (a : R) (ha : a ∈ closure s) (p : (x : R) → x ∈ closure s → Prop) (s : Set R) : p a ha := by"
  },
  {
    "full_name": "MvPowerSeries.coeff_C_mul",
    "file_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean",
    "teorema": "theorem MvPowerSeries.coeff_C_mul (R : Type u_2) (a : R) (n : σ →₀ ℕ) (σ : Type u_1) (φ : MvPowerSeries σ R) : (coeff R n) ((C σ R) a * φ) = a * (coeff R n) φ := by"
  },
  {
    "full_name": "PMF.toOuterMeasure_apply_eq_zero_iff",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Basic.lean",
    "teorema": "theorem PMF.toOuterMeasure_apply_eq_zero_iff (p : PMF α) (s : Set α) (α : Type u_1) : p.toOuterMeasure s = 0 ↔ Disjoint p.support s := by"
  },
  {
    "full_name": "ModularForm.slash_action_eq'_iff",
    "file_path": "Mathlib/NumberTheory/ModularForms/SlashActions.lean",
    "teorema": "lemma ModularForm.slash_action_eq'_iff (f : ℍ → ℂ) (k : ℤ) (z : ℍ) (Γ : Subgroup SL(2, ℤ)) (γ : ↥Γ) : (f ∣[k] γ) z = f z ↔ f (γ • z) = (↑(↑↑↑γ 1 0) * ↑z + ↑(↑↑↑γ 1 1)) ^ k * f z := by"
  },
  {
    "full_name": "List.map_permutationsAux2'",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "teorema": "lemma List.map_permutationsAux2' (f : List α → β) (g : α → α') (r : List β) (t : α) (ts : List α) (ys : List α) (α : Type u_1) (β : Type u_2) : map g' (permutationsAux2 t ts r ys f).2 = (permutationsAux2 (g t) (map g ts) (map g' r) (map g ys) f').2 := by"
  },
  {
    "full_name": "MeasureTheory.ae_restrict_union_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "theorem MeasureTheory.ae_restrict_union_iff (p : α → Prop) (s : Set α) (t : Set α) (α : Type u_2) (μ : Measure α) : (∀ᵐ (x : α) ∂μ.restrict (s ∪ t), p x) ↔ (∀ᵐ (x : α) ∂μ.restrict s, p x) ∧ ∀ᵐ (x : α) ∂μ.restrict t, p x := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.rnDeriv_def'",
    "file_path": "Mathlib/Probability/Kernel/RadonNikodym.lean",
    "teorema": "theorem ProbabilityTheory.kernel.rnDeriv_def' (α : Type u_1) (γ : Type u_2) (η : ↥(kernel α γ)) (κ : ↥(kernel α γ)) : rnDeriv κ η = fun a x => ENNReal.ofReal (rnDerivAux κ (κ + η) a x) / ENNReal.ofReal (1 - rnDerivAux κ (κ + η) a x) := by"
  },
  {
    "full_name": "ProbabilityTheory.eq_condKernel_of_measure_eq_compProd",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Unique.lean",
    "teorema": "lemma ProbabilityTheory.eq_condKernel_of_measure_eq_compProd (Ω : Type u_3) (α : Type u_1) (κ : ↥(kernel α Ω)) (ρ : Measure (α × Ω)) : ∀ᵐ (x : α) ∂ρ.fst, κ x = ρ.condKernel x := by"
  },
  {
    "full_name": "Ordinal.blsub_eq_zero_iff",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "lemma Ordinal.blsub_eq_zero_iff (f : (a : Ordinal.{u_4}) → a < o → Ordinal.{max u_5 u_4}) (o : Ordinal.{u_4}) : o.blsub f = 0 ↔ o = 0 := by"
  },
  {
    "full_name": "t0Space_iff_uniformity'",
    "file_path": "Mathlib/Topology/UniformSpace/Separation.lean",
    "teorema": "theorem t0Space_iff_uniformity' (α : Type u) : T0Space α ↔ Pairwise fun x y => ∃ r ∈ 𝓤 α, (x, y) ∉ r := by"
  },
  {
    "full_name": "ConvexOn.smul''",
    "file_path": "Mathlib/Analysis/Convex/Mul.lean",
    "teorema": "theorem ConvexOn.smul'' (E : Type u_2) (F : Type u_3) (f : 𝕜 → E) (g : 𝕜 → F) (s : Set 𝕜) (𝕜 : Type u_1) : ConcaveOn 𝕜 s (f • g) := by"
  },
  {
    "full_name": "BoxIntegral.Box.biUnion_coe_eq_coe",
    "file_path": "Mathlib/Analysis/BoxIntegral/Box/Basic.lean",
    "teorema": "lemma BoxIntegral.Box.biUnion_coe_eq_coe (I : WithBot (Box ι)) (J : Box ι) (ι : Type u_1) : ⋃ J, ⋃ (_ : ↑J = I), ↑J = ↑I := by"
  },
  {
    "full_name": "BoxIntegral.Prepartition.mem_iUnion",
    "file_path": "Mathlib/Analysis/BoxIntegral/Partition/Basic.lean",
    "teorema": "theorem BoxIntegral.Prepartition.mem_iUnion (I : Box ι) (J : Box ι) (x : ι → ℝ) (ι : Type u_1) (π : Prepartition I) : x ∈ π.iUnion ↔ ∃ J ∈ π, x ∈ J := by"
  },
  {
    "full_name": "Submodule.comm_trans_rTensorOne",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Submodule.lean",
    "teorema": "lemma Submodule.comm_trans_rTensorOne (M : Submodule R S) (R : Type u) (S : Type v) : TensorProduct.comm R ↥⊥ ↥M ≪≫ₗ M.rTensorOne = M.lTensorOne := by"
  },
  {
    "full_name": "CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_π",
    "file_path": "Mathlib/CategoryTheory/Limits/FunctorCategory.lean",
    "teorema": "lemma CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_π (C : Type u) (F : J ⥤ K ⥤ C) (J : Type u₁) (K : Type u₂) (j : J) (k : K) : (limitObjIsoLimitCompEvaluation F k).hom ≫ limit.π (F ⋙ (evaluation K C).obj k) j = (limit.π F j).app k := by"
  },
  {
    "full_name": "Nat.gcd_mul_left_add_left",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "teorema": "lemma Nat.gcd_mul_left_add_left (k : ℕ) (m : ℕ) (n : ℕ) : (n * k + m).gcd n = m.gcd n := by"
  },
  {
    "full_name": "UniformInducing.of_comp_iff",
    "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean",
    "teorema": "theorem UniformInducing.of_comp_iff (f : α → β) (g : β → γ) (α : Type u) (β : Type v) (γ : Type w) : UniformInducing (g ∘ f) ↔ UniformInducing f := by"
  },
  {
    "full_name": "Ordnode.Bounded.to_sep",
    "file_path": "Mathlib/Data/Ordmap/Ordset.lean",
    "teorema": "theorem Ordnode.Bounded.to_sep (t₁ : Ordnode α) (t₂ : Ordnode α) (α : Type u_1) : All (fun y => All (fun z => y < z) t₂) t₁ := by"
  },
  {
    "full_name": "IsBoundedBilinearMap.contDiff",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma IsBoundedBilinearMap.contDiff (E : Type uE) (F : Type uF) (G : Type uG) (b : E × F → G) (n : ℕ∞) (𝕜 : Type u_1) : ContDiff 𝕜 n b := by"
  },
  {
    "full_name": "ContinuousLinearEquiv.comp_right_differentiableWithinAt_iff",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean",
    "teorema": "lemma ContinuousLinearEquiv.comp_right_differentiableWithinAt_iff (E : Type u_2) (F : Type u_3) (G : Type u_4) (L : Filter E) (f : F → G) (iso : E ≃L[𝕜] F) (s : Set F) (x : E) (𝕜 : Type u_1) : DifferentiableWithinAt 𝕜 (f ∘ ⇑iso) (⇑iso ⁻¹' s) x ↔ DifferentiableWithinAt 𝕜 f s (iso x) := by"
  },
  {
    "full_name": "CategoryTheory.Adjunction.leftAdjointUniq_trans_app",
    "file_path": "Mathlib/CategoryTheory/Adjunction/Unique.lean",
    "teorema": "theorem CategoryTheory.Adjunction.leftAdjointUniq_trans_app (C : Type u_1) (D : Type u_2) (F : C ⥤ D) (G : D ⥤ C) (adj1 : F ⊣ G) (adj2 : F' ⊣ G) (adj3 : F'' ⊣ G) (x : C) : (adj1.leftAdjointUniq adj2).hom.app x ≫ (adj2.leftAdjointUniq adj3).hom.app x = (adj1.leftAdjointUniq adj3).hom.app x := by"
  },
  {
    "full_name": "ContinuousMap.continuous_comp_left",
    "file_path": "Mathlib/Topology/CompactOpen.lean",
    "teorema": "lemma ContinuousMap.continuous_comp_left (K : Set X) (U : Set Z) (X : Type u_2) (Y : Type u_3) (Z : Type u_4) (f : C(X, Y)) : IsOpen {x | MapsTo (⇑(x.comp f)) K U} := by"
  },
  {
    "full_name": "CategoryTheory.NatTrans.CommShift.app_shift",
    "file_path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
    "teorema": "theorem CategoryTheory.NatTrans.CommShift.app_shift (A : Type u_5) (C : Type u_1) (D : Type u_2) (F₁ : C ⥤ D) (F₂ : C ⥤ D) (X : C) (a : A) (τ : F₁ ⟶ F₂) : τ.app ((shiftFunctor C a).obj X) = (F₁.commShiftIso a).hom.app X ≫ (shiftFunctor D a).map (τ.app X) ≫ (F₂.commShiftIso a).inv.app X := by"
  },
  {
    "full_name": "Prod.ext_iff",
    "file_path": "Mathlib/Data/Prod/Basic.lean",
    "teorema": "lemma Prod.ext_iff (p : α × β) (q : α × β) (α : Type u_1) (β : Type u_2) : p = q ↔ p.fst = q.fst ∧ p.snd = q.snd := by"
  },
  {
    "full_name": "List.count_singleton",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Count.lean",
    "teorema": "theorem List.count_singleton (a : α) (α : Type u_1) : count a [a] = 1 := by"
  },
  {
    "full_name": "Substring.Valid.bsize",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "lemma Substring.Valid.bsize : x✝.bsize = utf8Len x✝.toString.data := by"
  },
  {
    "full_name": "MeasureTheory.integral_zero",
    "file_path": "Mathlib/MeasureTheory/Integral/Bochner.lean",
    "teorema": "theorem MeasureTheory.integral_zero (α : Type u_1) (μ : Measure α) : ∫ (x : α), 0 ∂μ = 0 := by"
  },
  {
    "full_name": "MeasureTheory.integrable_withDensity_iff_integrable_smul'",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.integrable_withDensity_iff_integrable_smul' (E : Type u_5) (f : α → ℝ≥0∞) (g : α → E) (α : Type u_1) (μ : Measure α) : Integrable g (μ.withDensity f) ↔ Integrable (fun x => (f x).toReal • g x) μ := by"
  },
  {
    "full_name": "Finset.inv_smul_finset_distrib",
    "file_path": "Mathlib/Data/Finset/Pointwise.lean",
    "teorema": "lemma Finset.inv_smul_finset_distrib (a : α) (s : Finset α) (α : Type u_2) : (a • s)⁻¹ = op a⁻¹ • s⁻¹ := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.isEquivalence_imp",
    "file_path": "Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean",
    "teorema": "lemma CategoryTheory.LocalizerMorphism.isEquivalence_imp (D₁ : Type u₄) (D₂ : Type u₅) (G : D₁ ⥤ D₂) : G'.IsEquivalence := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_pos_iff_support",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "theorem MeasureTheory.lintegral_pos_iff_support (f : α → ℝ≥0∞) (α : Type u_1) (μ : Measure α) : 0 < ∫⁻ (a : α), f a ∂μ ↔ 0 < μ (support f) := by"
  },
  {
    "full_name": "Matrix.cons_add",
    "file_path": "Mathlib/Data/Fin/VecNotation.lean",
    "teorema": "lemma Matrix.cons_add (n : ℕ) (v : Fin n → α) (w : Fin n.succ → α) (x : α) (α : Type u) : vecCons x v + w = vecCons (x + vecHead w) (v + vecTail w) := by"
  },
  {
    "full_name": "SimpleGraph.Walk.dropUntil_copy",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "lemma SimpleGraph.Walk.dropUntil_copy (G : SimpleGraph V) (V : Type u) (p : G.Walk v w) (u : V) (v : V) (w : V) : u ∈ p.support := by"
  },
  {
    "full_name": "Nat.Partrec.Code.eval_prec_succ",
    "file_path": "Mathlib/Computability/PartrecCode.lean",
    "teorema": "lemma Nat.Partrec.Code.eval_prec_succ (a : ℕ) (cf : Code) (cg : Code) (k : ℕ) : (cf.prec cg).eval (Nat.pair a k.succ) = do let ih ← (cf.prec cg).eval (Nat.pair a k) cg.eval (Nat.pair a (Nat.pair k ih)) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_π_π",
    "file_path": "Mathlib/CategoryTheory/Limits/Fubini.lean",
    "teorema": "lemma CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_π_π (C : Type u) (G : J × K ⥤ C) (J : Type v) (K : Type v) (j : J) (k : K) : (limitCurrySwapCompLimIsoLimitCurryCompLim G).hom ≫ limit.π (curry.obj G ⋙ lim) j ≫ limit.π ((curry.obj G).obj j) k = limit.π (curry.obj (Prod.swap K J ⋙ G) ⋙ lim) k ≫ limit.π ((curry.obj (Prod.swap K J ⋙ G)).obj k) j := by"
  },
  {
    "full_name": "Bool.coe_false",
    "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean",
    "teorema": "theorem Bool.coe_false : (false = true) = False := by"
  },
  {
    "full_name": "Rat.normalize.reduced'",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.normalize.reduced' (den : Nat) (g : Nat) (num : Int) : (num / ↑g).natAbs.Coprime (den / g) := by"
  },
  {
    "full_name": "List.asString_inj",
    "file_path": "Mathlib/Data/String/Basic.lean",
    "teorema": "theorem List.asString_inj (l : List Char) : l = l' := by"
  },
  {
    "full_name": "SimpleGraph.IsSRGWith.compl_is_regular",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean",
    "teorema": "lemma SimpleGraph.IsSRGWith.compl_is_regular (k : ℕ) (n : ℕ) : Gᶜ.IsRegularOfDegree (n - k - 1) := by"
  },
  {
    "full_name": "Complex.differentiableOn_tsum_of_summable_norm",
    "file_path": "Mathlib/Analysis/Complex/LocallyUniformLimit.lean",
    "teorema": "lemma Complex.differentiableOn_tsum_of_summable_norm (E : Type u_1) (F : ι → ℂ → E) (U : Set ℂ) (ι : Type u_2) : DifferentiableOn ℂ (fun w => ∑' (i : ι), F i w) U := by"
  },
  {
    "full_name": "Matrix.Represents.add",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/LinearMap.lean",
    "teorema": "lemma Matrix.Represents.add (A : Matrix ι ι R) (M : Type u_2) (R : Type u_3) (b : ι → M) (f : Module.End R M) (ι : Type u_1) : Represents b (A + A') (f + f') := by"
  },
  {
    "full_name": "le_of_forall_one_lt_div_le",
    "file_path": "Mathlib/Algebra/Order/Group/DenselyOrdered.lean",
    "teorema": "lemma le_of_forall_one_lt_div_le (a : α) (b : α) (α : Type u_1) (ε : α) : a * ε ≤ b := by"
  },
  {
    "full_name": "Directed.exists_mem_subset_of_finset_subset_biUnion",
    "file_path": "Mathlib/Data/Set/Finite.lean",
    "teorema": "theorem Directed.exists_mem_subset_of_finset_subset_biUnion (f : ι → Set α) (s : Finset α) (α : Type u_1) (ι : Type u_2) : ∃ i, ↑s ⊆ f i := by"
  },
  {
    "full_name": "CategoryTheory.Limits.colimitLimitToLimitColimit_injective",
    "file_path": "Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean",
    "teorema": "lemma CategoryTheory.Limits.colimitLimitToLimitColimit_injective (F : J × K ⥤ Type v) (J : Type u₁) (K : Type u₂) : Function.Injective (colimitLimitToLimitColimit F) := by"
  },
  {
    "full_name": "PowerSeries.order_monomial",
    "file_path": "Mathlib/RingTheory/PowerSeries/Order.lean",
    "teorema": "lemma PowerSeries.order_monomial (R : Type u_1) (a : R) (n : ℕ) : ((monomial R n) a).order = if a = 0 then ⊤ else ↑n := by"
  },
  {
    "full_name": "AlgEquiv.arrowCongr_comp",
    "file_path": "Mathlib/Algebra/Algebra/Equiv.lean",
    "teorema": "theorem AlgEquiv.arrowCongr_comp (A₁ : Type uA₁) (A₂ : Type uA₂) (A₃ : Type uA₃) (R : Type uR) (e₁ : A₁ ≃ₐ[R] A₁') (e₂ : A₂ ≃ₐ[R] A₂') (e₃ : A₃ ≃ₐ[R] A₃') (f : A₁ →ₐ[R] A₂) (g : A₂ →ₐ[R] A₃) : (e₁.arrowCongr e₃) (g.comp f) = ((e₂.arrowCongr e₃) g).comp ((e₁.arrowCongr e₂) f) := by"
  },
  {
    "full_name": "ProbabilityTheory.measure_ge_le_exp_mul_mgf",
    "file_path": "Mathlib/Probability/Moments.lean",
    "teorema": "lemma ProbabilityTheory.measure_ge_le_exp_mul_mgf (X : Ω → ℝ) (t : ℝ) (Ω : Type u_1) (ε : ℝ) (μ : Measure Ω) : (μ {ω | ε ≤ X ω}).toReal ≤ rexp (-t * ε) * mgf X μ t := by"
  },
  {
    "full_name": "FirstOrder.Language.realize_noTopOrder_iff",
    "file_path": "Mathlib/ModelTheory/Order.lean",
    "teorema": "lemma FirstOrder.Language.realize_noTopOrder_iff (M : Type w') : M ⊨ Language.order.noTopOrderSentence ↔ NoTopOrder M := by"
  },
  {
    "full_name": "CategoryTheory.GrothendieckTopology.W_adj_unit_app",
    "file_path": "Mathlib/CategoryTheory/Sites/Localization.lean",
    "teorema": "theorem CategoryTheory.GrothendieckTopology.W_adj_unit_app (A : Type u_2) (C : Type u_1) (G : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A) (J : GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) (adj : G ⊣ sheafToPresheaf J A) : J.W (adj.unit.app P) := by"
  },
  {
    "full_name": "Vector.tendsto_cons",
    "file_path": "Mathlib/Topology/List.lean",
    "teorema": "theorem Vector.tendsto_cons (a : α) (l : Vector α n) (n : ℕ) (α : Type u_1) : Tendsto (fun p => p.1 ::ᵥ p.2) (𝓝 a ×ˢ 𝓝 l) (𝓝 (a ::ᵥ l)) := by"
  },
  {
    "full_name": "Ideal.map_includeRight_eq",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean",
    "teorema": "theorem Ideal.map_includeRight_eq (A : Type u_2) (B : Type u_3) (I : Ideal B) (R : Type u_1) : Submodule.restrictScalars R (map includeRight I) = LinearMap.range (LinearMap.lTensor A (Submodule.restrictScalars R I).subtype) := by"
  },
  {
    "full_name": "MvPFunctor.M.bisim'",
    "file_path": "Mathlib/Data/PFunctor/Multivariate/M.lean",
    "teorema": "theorem MvPFunctor.M.bisim' (P : MvPFunctor.{u} (n + 1)) (n : ℕ) (x : P.M α) (y : P.M α) (α : TypeVec.{u} n) : x = y := by"
  },
  {
    "full_name": "Nat.even_or_odd'",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "theorem Nat.even_or_odd' (n : ℕ) : ∃ k, n = 2 * k ∨ n = 2 * k + 1 := by"
  },
  {
    "full_name": "AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_add_smoothingFn",
    "file_path": "Mathlib/Computability/AkraBazzi/AkraBazzi.lean",
    "teorema": "theorem AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_add_smoothingFn (p : ℝ) : (fun x => ‖deriv (fun z => z ^ p * (1 + ε z)) x‖) =Θ[atTop] fun z => z ^ (p - 1) := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_comm",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "teorema": "lemma InnerProductGeometry.angle_comm (V : Type u_1) (x : V) (y : V) : angle x y = angle y x := by"
  },
  {
    "full_name": "Subsemigroup.mem_sSup_of_directed_on",
    "file_path": "Mathlib/Algebra/Group/Subsemigroup/Membership.lean",
    "teorema": "lemma Subsemigroup.mem_sSup_of_directed_on (M : Type u_2) (S : Set (Subsemigroup M)) (x : M) : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by"
  },
  {
    "full_name": "Multiset.card_join",
    "file_path": "Mathlib/Data/Multiset/Bind.lean",
    "teorema": "theorem Multiset.card_join : card (join 0) = (map (⇑card) 0).sum := by"
  },
  {
    "full_name": "convexHull_union",
    "file_path": "Mathlib/Analysis/Convex/Join.lean",
    "teorema": "theorem convexHull_union (E : Type u_3) (s : Set E) (t : Set E) (𝕜 : Type u_2) : (convexHull 𝕜) (s ∪ t) = convexJoin 𝕜 ((convexHull 𝕜) s) ((convexHull 𝕜) t) := by"
  },
  {
    "full_name": "t2_iff_ultrafilter",
    "file_path": "Mathlib/Topology/Separation.lean",
    "teorema": "theorem t2_iff_ultrafilter (X : Type u_1) : (∀ {x y : X}, (𝓝 x ⊓ 𝓝 y).NeBot → x = y) ↔ ∀ {x y : X} (f : Ultrafilter X), ↑f ≤ 𝓝 x → ↑f ≤ 𝓝 y → x = y := by"
  },
  {
    "full_name": "Part.inter_get_eq",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "theorem Part.inter_get_eq (a : Part α) (b : Part α) (hab : (a ∩ b).Dom) (α : Type u_1) : (a ∩ b).get hab = a.get ⋯ ∩ b.get ⋯ := by"
  },
  {
    "full_name": "CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean",
    "teorema": "lemma CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv (C : Type u) (X : C) (Y : C) (b : BinaryBicone X Y) (hb : b.IsBilimit) : (hb.isLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit X Y)).inv = desc b.inl b.inr := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.sup",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.Integrable.sup (f : α → β) (g : α → β) (α : Type u_1) (β : Type u_5) (μ : Measure α) : Integrable (f ⊔ g) μ := by"
  },
  {
    "full_name": "iSup_const",
    "file_path": "Mathlib/Order/CompleteLattice.lean",
    "teorema": "lemma iSup_const (a : α) (α : Type u_1) : ⨆ x, a = a := by"
  },
  {
    "full_name": "Pell.y_dvd_iff",
    "file_path": "Mathlib/NumberTheory/PellMatiyasevic.lean",
    "teorema": "theorem Pell.y_dvd_iff : False := by"
  },
  {
    "full_name": "Nat.floorRoot_def",
    "file_path": "Mathlib/Data/Nat/Factorization/Root.lean",
    "teorema": "lemma Nat.floorRoot_def (a : ℕ) (n : ℕ) : n.floorRoot a = if n = 0 ∨ a = 0 then 0 else (a.factorization ⌊/⌋ n).prod fun x x_1 => x ^ x_1 := by"
  },
  {
    "full_name": "HasDerivWithinAt.comp_hasFDerivWithinAt_of_eq",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean",
    "teorema": "lemma HasDerivWithinAt.comp_hasFDerivWithinAt_of_eq (E : Type w) (f : E → 𝕜') (h₂ : 𝕜' → 𝕜') (s : Set E) (x : E) (𝕜 : Type u) : HasFDerivWithinAt (h₂ ∘ f) (h₂' • f') s x := by"
  },
  {
    "full_name": "hasMellin_sub",
    "file_path": "Mathlib/Analysis/MellinTransform.lean",
    "teorema": "lemma hasMellin_sub (E : Type u_1) (f : ℝ → E) (g : ℝ → E) (s : ℂ) : MellinConvergent (fun t => f t - g t) s := by"
  },
  {
    "full_name": "Order.Ideal.PrimePair.I_isPrime",
    "file_path": "Mathlib/Order/PrimeIdeal.lean",
    "teorema": "theorem Order.Ideal.PrimePair.I_isPrime (IF : PrimePair P) (P : Type u_1) : IsPFilter (↑IF.I)ᶜ := by"
  },
  {
    "full_name": "Int.addRight_one_isCycle",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean",
    "teorema": "theorem Int.addRight_one_isCycle (n : ℤ) : (Equiv.addRight 1 ^ n) 0 = n := by"
  },
  {
    "full_name": "AffineIsometryEquiv.vadd_vsub",
    "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean",
    "teorema": "theorem AffineIsometryEquiv.vadd_vsub (V : Type u_2) (V₂ : Type u_5) (g : V → V₂) : Isometry g := by"
  },
  {
    "full_name": "Polynomial.degree_modByMonic_lt",
    "file_path": "Mathlib/Algebra/Polynomial/Div.lean",
    "teorema": "theorem Polynomial.degree_modByMonic_lt (R : Type u) (p : R[X]) (q : R[X]) : (p %ₘ q).degree < q.degree := by"
  },
  {
    "full_name": "Nat.Primes.coe_pnat_injective",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "teorema": "lemma Nat.Primes.coe_pnat_injective (p : Primes) (q : Primes) : ↑p = ↑q := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.fst_map_id_prod",
    "file_path": "Mathlib/Probability/Kernel/Composition.lean",
    "teorema": "lemma ProbabilityTheory.kernel.fst_map_id_prod (f : β → γ) (α : Type u_1) (β : Type u_2) (γ : Type u_6) (κ : ↥(kernel α β)) : fst (map κ (fun a => (a, f a)) ⋯) = κ := by"
  },
  {
    "full_name": "volume_regionBetween_eq_lintegral",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean",
    "teorema": "theorem volume_regionBetween_eq_lintegral (f : α → ℝ) (g : α → ℝ) (s : Set α) (α : Type u_1) (μ : Measure α) : (μ.prod volume) (regionBetween f g s) = ∫⁻ (y : α) in s, ofReal ((g - f) y) ∂μ := by"
  },
  {
    "full_name": "WittVector.ghostComponent_zero_verschiebungFun",
    "file_path": "Mathlib/RingTheory/WittVector/Verschiebung.lean",
    "teorema": "theorem WittVector.ghostComponent_zero_verschiebungFun (R : Type u_1) (x : 𝕎 R) : (ghostComponent 0) x.verschiebungFun = 0 := by"
  },
  {
    "full_name": "Real.sin_three_mul",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Real.sin_three_mul (x : ℝ) : sin (3 * x) = 3 * sin x - 4 * sin x ^ 3 := by"
  },
  {
    "full_name": "MeasureTheory.snormEssSup_zero",
    "file_path": "Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean",
    "teorema": "lemma MeasureTheory.snormEssSup_zero (α : Type u_1) (μ : Measure α) : snormEssSup 0 μ = 0 := by"
  },
  {
    "full_name": "contDiff_zero_fun",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma contDiff_zero_fun (E : Type uE) (m : ℕ) (x : E) (𝕜 : Type u_1) : Differentiable 𝕜 (iteratedFDeriv 𝕜 m fun x => 0) := by"
  },
  {
    "full_name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring_injective",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "teorema": "theorem NonUnitalSemiring.toNonUnitalNonAssocSemiring_injective (R : Type u) : Function.Injective (@toNonUnitalNonAssocSemiring R) := by"
  },
  {
    "full_name": "TopologicalSpace.IsTopologicalBasis.sigma",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "theorem TopologicalSpace.IsTopologicalBasis.sigma (E : ι → Type u_2) (s : (i : ι) → Set (Set (E i))) (ι : Type u_1) : IsTopologicalBasis (⋃ i, (fun u => Sigma.mk i '' u) '' s i) := by"
  },
  {
    "full_name": "MeasureTheory.Lp.ext_iff",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "theorem MeasureTheory.Lp.ext_iff (E : Type u_2) (f : ↥(Lp E p μ)) (g : ↥(Lp E p μ)) (p : ℝ≥0∞) (α : Type u_1) (μ : Measure α) : ↑↑f =ᶠ[ae μ] ↑↑g := by"
  },
  {
    "full_name": "Complex.interior_setOf_le_im",
    "file_path": "Mathlib/Analysis/Complex/ReImTopology.lean",
    "teorema": "theorem Complex.interior_setOf_le_im (a : ℝ) : interior {z | a ≤ z.im} = {z | a < z.im} := by"
  },
  {
    "full_name": "Batteries.RBNode.Balanced.ins",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "teorema": "theorem Batteries.RBNode.Balanced.ins (cmp : α → α → Ordering) (v : α) (α : Type u_1) : RedRed (nil.isRed = red) (ins cmp v nil) 0 := by"
  },
  {
    "full_name": "Filter.exists_eventually_atBot",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "theorem Filter.exists_eventually_atBot (r : α → β → Prop) (α : Type u_3) (β : Type u_4) : (∃ b, ∀ᶠ (a : α) in atBot, r a b) ↔ ∀ᶠ (a₀ : α) in atBot, ∃ b, ∀ a ≤ a₀, r a b := by"
  },
  {
    "full_name": "Matroid.Base.inter_basis_iff_compl_inter_basis_dual",
    "file_path": "Mathlib/Data/Matroid/Dual.lean",
    "teorema": "theorem Matroid.Base.inter_basis_iff_compl_inter_basis_dual (B : Set α) (M : Matroid α) (X : Set α) (α : Type u_1) : M.Basis (B ∩ X) X ↔ M✶.Basis (M.E \\ B ∩ (M.E \\ X)) (M.E \\ X) := by"
  },
  {
    "full_name": "Rat.not_countably_generated_nhds_infty_opc",
    "file_path": "Mathlib/Topology/Instances/RatLemmas.lean",
    "teorema": "theorem Rat.not_countably_generated_nhds_infty_opc : ¬(𝓝 ∞).IsCountablyGenerated := by"
  },
  {
    "full_name": "List.takeWhile_cons_of_neg",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "theorem List.takeWhile_cons_of_neg (l : List α) (p : α → Bool) (x : α) (α : Type u) : takeWhile p (x :: l) = [] := by"
  },
  {
    "full_name": "ZNum.ofInt'_neg",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "theorem ZNum.ofInt'_neg (n : ℕ) : ofInt' ↑(n + 1) = -ofInt' -[n+1] := by"
  },
  {
    "full_name": "Con.sup_def",
    "file_path": "Mathlib/GroupTheory/Congruence/Basic.lean",
    "teorema": "theorem Con.sup_def (M : Type u_1) (c : Con M) (d : Con M) : c ⊔ d = conGen (⇑c ⊔ ⇑d) := by"
  },
  {
    "full_name": "Part.some_ne_none",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.some_ne_none (x : α) (α : Type u_1) : some x ≠ none := by"
  },
  {
    "full_name": "Rack.toEnvelGroup.mapAux.well_def",
    "file_path": "Mathlib/Algebra/Quandle.lean",
    "teorema": "lemma Rack.toEnvelGroup.mapAux.well_def (G : Type u_2) (R : Type u_1) (f : R →◃ Quandle.Conj G) : mapAux f (a✝.mul b✝) = mapAux f (a'✝.mul b'✝) := by"
  },
  {
    "full_name": "Set.left_mem_Ioc",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.left_mem_Ioc (a : α) (b : α) (α : Type u_1) : a ∈ Ioc a b ↔ False := by"
  },
  {
    "full_name": "Finset.affineCombination_vsub",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean",
    "teorema": "lemma Finset.affineCombination_vsub (P : Type u_3) (k : Type u_1) (p : ι → P) (s : Finset ι) (w₁ : ι → k) (w₂ : ι → k) (ι : Type u_4) : (affineCombination k s p) w₁ -ᵥ (affineCombination k s p) w₂ = (s.weightedVSub p) (w₁ - w₂) := by"
  },
  {
    "full_name": "Matrix.isUnit_det_transpose",
    "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
    "teorema": "lemma Matrix.isUnit_det_transpose : IsUnit Aᵀ.det := by"
  },
  {
    "full_name": "Submodule.ker_inclusion",
    "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean",
    "teorema": "lemma Submodule.ker_inclusion (M : Type u_6) (R : Type u_1) (h : p ≤ p') (p : Submodule R M) : ker (inclusion h) = ⊥ := by"
  },
  {
    "full_name": "MvPFunctor.M.bisim_lemma",
    "file_path": "Mathlib/Data/PFunctor/Multivariate/M.lean",
    "teorema": "lemma MvPFunctor.M.bisim_lemma : ∃ g₁', := by"
  },
  {
    "full_name": "SimpleGraph.dart_edge_eq_mk'_iff'",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Dart.lean",
    "teorema": "lemma SimpleGraph.dart_edge_eq_mk'_iff' (G : SimpleGraph V) (V : Type u_1) : ∀ {d : G.Dart} {u v : V}, d.edge = s(u, v) ↔ d.toProd.1 = u ∧ d.toProd.2 = v ∨ d.toProd.1 = v ∧ d.toProd.2 = u := by"
  },
  {
    "full_name": "Monotone.seq_lt_seq_of_lt_of_le",
    "file_path": "Mathlib/Order/Iterate.lean",
    "teorema": "theorem Monotone.seq_lt_seq_of_lt_of_le (n : ℕ) (x : ℕ → α) (y : ℕ → α) (α : Type u_1) : x n < y n := by"
  },
  {
    "full_name": "Cardinal.lift_le_nat_iff",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "lemma Cardinal.lift_le_nat_iff (a : Cardinal.{u}) (n : ℕ) : lift.{v, u} a ≤ ↑n ↔ a ≤ ↑n := by"
  },
  {
    "full_name": "Profinite.NobelingProof.GoodProducts.finsupp_sum_mem_span_eval",
    "file_path": "Mathlib/Topology/Category/Profinite/Nobeling.lean",
    "teorema": "lemma Profinite.NobelingProof.GoodProducts.finsupp_sum_mem_span_eval (C : Set (I → Bool)) (I : Type u) (a : I) (c : Products I →₀ ℤ) (s : Finset I) : (c.sum fun a_1 b => e (π C fun x => x ∈ s) a * b • Products.eval (π C fun x => x ∈ s) a_1) ∈ := by"
  },
  {
    "full_name": "FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1",
    "file_path": "Mathlib/Analysis/Analytic/Inverse.lean",
    "teorema": "theorem FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1 (a : ℝ) (n : ℕ) (p : ℕ → ℝ) (r : ℝ) : ∑ k ∈ Ico 2 (n + 1), a ^ k * ∑ c ∈ {c | 1 < c.length}.toFinset, r ^ c.length * ∏ j : Fin c.length, p (c.blocksFun j) = ∑ k ∈ Ico 2 (n + 1), := by"
  },
  {
    "full_name": "Matrix.det_succ_row_zero",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
    "teorema": "theorem Matrix.det_succ_row_zero (A : Matrix (Fin n.succ) (Fin n.succ) R) (R : Type v) (n : ℕ) : A.det = ∑ j : Fin n.succ, (-1) ^ ↑j * A 0 j * (A.submatrix Fin.succ j.succAbove).det := by"
  },
  {
    "full_name": "Real.cos_sq_le_one",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "lemma Real.cos_sq_le_one (x : ℝ) : cos x ^ 2 ≤ 1 := by"
  },
  {
    "full_name": "Finset.gcd_union",
    "file_path": "Mathlib/Algebra/GCDMonoid/Finset.lean",
    "teorema": "lemma Finset.gcd_union (f : β → α) (s₂ : Finset β) (α : Type u_2) (β : Type u_3) : (∅ ∪ s₂).gcd f = GCDMonoid.gcd (∅.gcd f) (s₂.gcd f) := by"
  },
  {
    "full_name": "Real.sqrt_sq",
    "file_path": "Mathlib/Data/Real/Sqrt.lean",
    "teorema": "lemma Real.sqrt_sq (x : ℝ) : √(x ^ 2) = x := by"
  },
  {
    "full_name": "Finset.insert_sdiff_cancel",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "theorem Finset.insert_sdiff_cancel (a : α) (s : Finset α) (α : Type u_1) : insert a s \\ s = {a} := by"
  },
  {
    "full_name": "ContMDiff.codRestrict_sphere",
    "file_path": "Mathlib/Geometry/Manifold/Instances/Sphere.lean",
    "teorema": "theorem ContMDiff.codRestrict_sphere (E : Type u_1) (F : Type u_2) (H : Type u_3) (I : ModelWithCorners ℝ F H) (M : Type u_4) (f : M → E) (hf : ContMDiff I 𝓘(ℝ, E) m f) (m : ℕ∞) (n : ℕ) : ContMDiff I 𝓘(ℝ, EuclideanSpace ℝ (Fin n)) m (Set.codRestrict f (sphere 0 1) hf') := by"
  },
  {
    "full_name": "Module.End.IsSemisimple.minpoly_squarefree",
    "file_path": "Mathlib/LinearAlgebra/Semisimple.lean",
    "teorema": "theorem Module.End.IsSemisimple.minpoly_squarefree (K : Type u_3) (M : Type u_2) (f : End K M) : IsRadical (minpoly K f) := by"
  },
  {
    "full_name": "four_functions_theorem",
    "file_path": "Mathlib/Combinatorics/SetFamily/FourFunctions.lean",
    "teorema": "theorem four_functions_theorem (f₁ : α → β) (f₂ : α → β) (f₃ : α → β) (f₄ : α → β) (s : Finset α) (t : Finset α) (α : Type u_1) (β : Type u_2) : (∑ a ∈ s, f₁ a) * ∑ a ∈ t, f₂ a ≤ (∑ a ∈ s ⊼ t, f₃ a) * ∑ a ∈ s ⊻ t, f₄ a := by"
  },
  {
    "full_name": "CategoryTheory.GrothendieckTopology.WEqualsLocallyBijective.mk'",
    "file_path": "Mathlib/CategoryTheory/Sites/LocallyBijective.lean",
    "teorema": "theorem CategoryTheory.GrothendieckTopology.WEqualsLocallyBijective.mk' (A : Type u') (C : Type u) (J : GrothendieckTopology C) (P : Cᵒᵖ ⥤ A) (Q : Cᵒᵖ ⥤ A) (f : P ⟶ Q) : J.W f ↔ Presheaf.IsLocallyInjective J f ∧ Presheaf.IsLocallySurjective J f := by"
  },
  {
    "full_name": "LinearMap.BilinForm.isCompl_orthogonal_of_restrict_nondegenerate",
    "file_path": "Mathlib/LinearAlgebra/BilinearForm/Orthogonal.lean",
    "teorema": "theorem LinearMap.BilinForm.isCompl_orthogonal_of_restrict_nondegenerate (B : BilinForm K V) (K : Type u_6) (V : Type u_5) (W : Submodule K V) : IsCompl W (B.orthogonal W) := by"
  },
  {
    "full_name": "WeierstrassCurve.Affine.equation_negAdd",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean",
    "teorema": "theorem WeierstrassCurve.Affine.equation_negAdd (F : Type u) (W : Affine F) (x₁ : F) (x₂ : F) (y₁ : F) (y₂ : F) : W.Equation (W.addX x₁ x₂ (W.slope x₁ x₂ y₁ y₂)) (W.negAddY x₁ x₂ y₁ (W.slope x₁ x₂ y₁ y₂)) := by"
  },
  {
    "full_name": "mul_eq_of_eq_inv_mul₀",
    "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
    "teorema": "lemma mul_eq_of_eq_inv_mul₀ (G₀ : Type u_3) (a : G₀) (b : G₀) (c : G₀) : a * b = c := by"
  },
  {
    "full_name": "RingHom.rangeS_top_iff_surjective",
    "file_path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
    "teorema": "lemma RingHom.rangeS_top_iff_surjective (R : Type u) (S : Type v) (f : R →+* S) : ↑f.rangeS = ↑⊤ ↔ Set.range ⇑f = Set.univ := by"
  },
  {
    "full_name": "Real.rpow_add_nat'",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "lemma Real.rpow_add_nat' (n : ℕ) (x : ℝ) (y : ℝ) : x ^ (y + ↑n) = x ^ y * x ^ n := by"
  },
  {
    "full_name": "IsPGroup.comap_of_ker_isPGroup",
    "file_path": "Mathlib/GroupTheory/PGroup.lean",
    "teorema": "lemma IsPGroup.comap_of_ker_isPGroup (G : Type u_1) (H : Subgroup G) (K : Type u_2) (p : ℕ) (ϕ : K →* G) : IsPGroup p ↥(Subgroup.comap ϕ H) := by"
  },
  {
    "full_name": "Equiv.piCongr'_symm_apply_symm_apply",
    "file_path": "Mathlib/Logic/Equiv/Basic.lean",
    "teorema": "lemma Equiv.piCongr'_symm_apply_symm_apply (W : α → Sort w) (Z : β → Sort z) (b : β) (f : (b : β) → Z b) (h₁ : α ≃ β) (h₂ : (b : β) → W (h₁.symm b) ≃ Z b) (α : Sort u_1) (β : Sort u_2) : (h₁.piCongr' h₂).symm f (h₁.symm b) = (h₂ b).symm (f b) := by"
  },
  {
    "full_name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop",
    "file_path": "Mathlib/Analysis/Analytic/Composition.lean",
    "teorema": "theorem FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop : Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop := by"
  },
  {
    "full_name": "CategoryTheory.congrArg_mpr_hom_right",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "lemma CategoryTheory.congrArg_mpr_hom_right (C : Type u₁) (X : C) (Y : C) (p : X ⟶ Y) : ⋯.mpr p = p ≫ eqToHom ⋯ := by"
  },
  {
    "full_name": "Irrational.neg",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "lemma Irrational.neg (x : ℝ) : Irrational (- -x) := by"
  },
  {
    "full_name": "CategoryTheory.shift_shiftFunctorCompIsoId_inv_app",
    "file_path": "Mathlib/CategoryTheory/Shift/Basic.lean",
    "teorema": "lemma CategoryTheory.shift_shiftFunctorCompIsoId_inv_app (A : Type u_1) (m : A) (n : A) : m + n = 0 := by"
  },
  {
    "full_name": "SimpleGraph.Walk.reverseAux_append",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "theorem SimpleGraph.Walk.reverseAux_append (G : SimpleGraph V) (V : Type u) (p : G.Walk u v) (q : G.Walk u w) (r : G.Walk w x) (u : V) (v : V) (w : V) (x : V) : (p.reverseAux q).append r = p.reverseAux (q.append r) := by"
  },
  {
    "full_name": "MeromorphicAt.pow",
    "file_path": "Mathlib/Analysis/Analytic/Meromorphic.lean",
    "teorema": "lemma MeromorphicAt.pow (f : 𝕜 → 𝕜) (n : ℕ) (x : 𝕜) (𝕜 : Type u_1) : MeromorphicAt (f ^ n) x := by"
  },
  {
    "full_name": "Submodule.sup_orthogonal_of_completeSpace",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Projection.lean",
    "teorema": "theorem Submodule.sup_orthogonal_of_completeSpace (E : Type u_2) (K : Submodule 𝕜 E) (𝕜 : Type u_1) : K ⊔ Kᗮ = ⊤ := by"
  },
  {
    "full_name": "Rat.cast_div_of_ne_zero",
    "file_path": "Mathlib/Data/Rat/Cast/Defs.lean",
    "teorema": "lemma Rat.cast_div_of_ne_zero (p : ℚ) (q : ℚ) : ↑(p / q) = ↑p / ↑q := by"
  },
  {
    "full_name": "Complex.abs_cpow_of_ne_zero",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "lemma Complex.abs_cpow_of_ne_zero (w : ℂ) (z : ℂ) : abs (z ^ w) = abs z ^ w.re / rexp (z.arg * w.im) := by"
  },
  {
    "full_name": "AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff",
    "file_path": "Mathlib/Algebra/Order/Rearrangement.lean",
    "teorema": "lemma AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff (f : ι → α) (g : ι → β) (s : Finset ι) (α : Type u_2) (β : Type u_3) (ι : Type u_1) (σ : Perm ι) : ∑ i ∈ s, f i • g i < ∑ i ∈ s, f i • g (σ i) ↔ ¬AntivaryOn f (g ∘ ⇑σ) ↑s := by"
  },
  {
    "full_name": "CategoryTheory.CatCommSq.hInv_hInv",
    "file_path": "Mathlib/CategoryTheory/CatCommSq.lean",
    "teorema": "theorem CategoryTheory.CatCommSq.hInv_hInv (B : C₃ ≌ C₄) (C₁ : Type u_1) (C₂ : Type u_2) (C₃ : Type u_3) (C₄ : Type u_4) (L : C₁ ⥤ C₃) (R : C₂ ⥤ C₄) (T : C₁ ≌ C₂) (h : CatCommSq T.functor L R B.functor) : hInv T.symm R L B.symm (hInv T L R B h) = h := by"
  },
  {
    "full_name": "Matrix.charmatrix_apply_natDegree",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean",
    "teorema": "theorem Matrix.charmatrix_apply_natDegree (M : Matrix n n R) (R : Type u) (i : n) (j : n) (n : Type v) : (M.charmatrix i j).natDegree = if i = j then 1 else 0 := by"
  },
  {
    "full_name": "ModelWithCorners.extChartAt_transDiffeomorph_target",
    "file_path": "Mathlib/Geometry/Manifold/Diffeomorph.lean",
    "teorema": "theorem ModelWithCorners.extChartAt_transDiffeomorph_target (E : Type u_2) (H : Type u_5) (I : ModelWithCorners 𝕜 E H) (M : Type u_9) (e : E ≃ₘ⟮𝓘(𝕜, E), 𝓘(𝕜, E')⟯ E') (x : M) (𝕜 : Type u_1) : (extChartAt (I.transDiffeomorph e) x).target = ⇑e.symm ⁻¹' (extChartAt I x).target := by"
  },
  {
    "full_name": "MeasureTheory.Measure.measurePreserving_div_left",
    "file_path": "Mathlib/MeasureTheory/Group/Measure.lean",
    "teorema": "lemma MeasureTheory.Measure.measurePreserving_div_left (G : Type u_2) (g : G) (μ : Measure G) : MeasurePreserving (fun t => g / t) μ μ := by"
  },
  {
    "full_name": "CochainComplex.HomComplex.Cochain.congr_v",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean",
    "teorema": "lemma CochainComplex.HomComplex.Cochain.congr_v (C : Type u) (F : CochainComplex C ℤ) (G : CochainComplex C ℤ) (hpq : p + n = q) (n : ℤ) (p : ℤ) (q : ℤ) (z₁ : Cochain F G n) (z₂ : Cochain F G n) : z₁.v p q hpq = z₂.v p q hpq := by"
  },
  {
    "full_name": "IsClosed.vadd_right_of_isCompact",
    "file_path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean",
    "teorema": "theorem IsClosed.vadd_right_of_isCompact (P : Type u_3) (V : Type u_2) (s : Set V) (t : Set P) : IsClosed (s +ᵥ t) := by"
  },
  {
    "full_name": "geom_sum_eq",
    "file_path": "Mathlib/Algebra/GeomSum.lean",
    "teorema": "lemma geom_sum_eq (n : ℕ) (x : α) (α : Type u) : ∑ i ∈ range n, x ^ i = (x ^ n - 1) / (x - 1) := by"
  },
  {
    "full_name": "iteratedDerivWithin_sub",
    "file_path": "Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean",
    "teorema": "theorem iteratedDerivWithin_sub (F : Type u_2) (f : 𝕜 → F) (g : 𝕜 → F) (n : ℕ) (s : Set 𝕜) (x : 𝕜) (𝕜 : Type u_1) : iteratedDerivWithin n (f - g) s x = iteratedDerivWithin n f s x - iteratedDerivWithin n g s x := by"
  },
  {
    "full_name": "PartialHomeomorph.map_extend_symm_nhdsWithin_range",
    "file_path": "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean",
    "teorema": "lemma PartialHomeomorph.map_extend_symm_nhdsWithin_range (E : Type u_2) (H : Type u_4) (I : ModelWithCorners 𝕜 E H) (M : Type u_3) (f : PartialHomeomorph M H) (y : M) (𝕜 : Type u_1) : map (↑(f.extend I).symm) (𝓝[range ↑I] ↑(f.extend I) y) = 𝓝 y := by"
  },
  {
    "full_name": "CategoryTheory.factorThruImage_comp_imageUnopOp_inv",
    "file_path": "Mathlib/CategoryTheory/Abelian/Opposite.lean",
    "teorema": "theorem CategoryTheory.factorThruImage_comp_imageUnopOp_inv (A : Cᵒᵖ) (B : Cᵒᵖ) (g : A ⟶ B) : factorThruImage g ≫ (imageUnopOp g).inv = (image.ι g.unop).op := by"
  },
  {
    "full_name": "affineIndependent_equiv",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean",
    "teorema": "theorem affineIndependent_equiv (P : Type u_3) (e : ι ≃ ι') (k : Type u_1) (p : ι' → P) (ι : Type u_4) : AffineIndependent k (p ∘ ⇑e) ↔ AffineIndependent k p := by"
  },
  {
    "full_name": "List.Ico.eq_nil_of_le",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "teorema": "lemma List.Ico.eq_nil_of_le (m : ℕ) (n : ℕ) : Ico n m = [] := by"
  },
  {
    "full_name": "Polynomial.natSepDegree_X",
    "file_path": "Mathlib/FieldTheory/SeparableDegree.lean",
    "teorema": "lemma Polynomial.natSepDegree_X : X.natSepDegree = 1 := by"
  },
  {
    "full_name": "Polynomial.isUnit_of_self_mul_dvd_separable",
    "file_path": "Mathlib/FieldTheory/Separable.lean",
    "teorema": "lemma Polynomial.isUnit_of_self_mul_dvd_separable (R : Type u) (q : R[X]) : IsUnit q := by"
  },
  {
    "full_name": "Disjoint.le_of_codisjoint",
    "file_path": "Mathlib/Order/Disjoint.lean",
    "teorema": "lemma Disjoint.le_of_codisjoint (a : α) (c : α) (α : Type u_1) : a ≤ c := by"
  },
  {
    "full_name": "MvPolynomial.totalDegree_finset_prod",
    "file_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
    "teorema": "lemma MvPolynomial.totalDegree_finset_prod (R : Type u) (f : ι → MvPolynomial σ R) (s : Finset ι) (ι : Type u_3) (σ : Type u_1) : (s.prod f).totalDegree ≤ ∑ i ∈ s, (f i).totalDegree := by"
  },
  {
    "full_name": "Set.directedOn_iUnion",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "theorem Set.directedOn_iUnion (f : ι → Set α) (r : α → α → Prop) (α : Type u_1) (ι : Sort u_4) : DirectedOn r (⋃ x, f x) := by"
  },
  {
    "full_name": "CategoryTheory.ShortComplex.HomologyMapData.congr_left_φH",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/Homology.lean",
    "teorema": "lemma CategoryTheory.ShortComplex.HomologyMapData.congr_left_φH (C : Type u) (S₁ : ShortComplex C) (S₂ : ShortComplex C) (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) (γ₁ : HomologyMapData φ h₁ h₂) (γ₂ : HomologyMapData φ h₁ h₂) (φ : S₁ ⟶ S₂) : γ₁.left.φH = γ₂.left.φH := by"
  },
  {
    "full_name": "TrivSqZeroExt.hasSum_expSeries_of_smul_comm",
    "file_path": "Mathlib/Analysis/NormedSpace/TrivSqZeroExt.lean",
    "teorema": "lemma TrivSqZeroExt.hasSum_expSeries_of_smul_comm (M : Type u_4) (R : Type u_3) (e : R) (x : tsze R M) (𝕜 : Type u_1) : HasSum (fun n => (expSeries 𝕜 (tsze R M) n) fun x_1 => x) (inl e + inr (e • x.snd)) := by"
  },
  {
    "full_name": "one_lt_finprod'",
    "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean",
    "teorema": "theorem one_lt_finprod' (M : Type u_7) (f : ι → M) (ι : Type u_3) : 1 < ∏ᶠ (i : ι), f i := by"
  },
  {
    "full_name": "Seminorm.closedBall_smul_closedBall",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "lemma Seminorm.closedBall_smul_closedBall (E : Type u_7) (p : Seminorm 𝕜 E) (r₁ : ℝ) (r₂ : ℝ) (𝕜 : Type u_3) : Metric.closedBall 0 r₁ • p.closedBall 0 r₂ ⊆ p.closedBall 0 (r₁ * r₂) := by"
  },
  {
    "full_name": "Mon_.Mon_tensor_one_mul",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Mon_.lean",
    "teorema": "theorem Mon_.Mon_tensor_one_mul (C : Type u₁) (M : Mon_ C) (N : Mon_ C) : ((λ_ (𝟙_ C)).inv ≫ (M.one ⊗ N.one)) ▷ (M.X ⊗ N.X) ≫ tensor_μ C (M.X, N.X) (M.X, N.X) ≫ (M.mul ⊗ N.mul) = (λ_ (M.X ⊗ N.X)).hom := by"
  },
  {
    "full_name": "Int.toNat_add_toNat_neg_eq_nnnorm",
    "file_path": "Mathlib/Analysis/NormedSpace/Int.lean",
    "teorema": "lemma Int.toNat_add_toNat_neg_eq_nnnorm (n : ℤ) : ↑n.toNat + ↑(-n).toNat = ‖n‖₊ := by"
  },
  {
    "full_name": "Sym2.out_snd_mem",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "teorema": "lemma Sym2.out_snd_mem (e : Sym2 α) (α : Type u_1) : e = s((Quot.out e).2, (Quot.out e).1) := by"
  },
  {
    "full_name": "AlgebraicGeometry.Spec.map_eqToHom",
    "file_path": "Mathlib/AlgebraicGeometry/Scheme.lean",
    "teorema": "lemma AlgebraicGeometry.Spec.map_eqToHom (R : CommRingCat) (S : CommRingCat) (e : R = S) : map (eqToHom e) = eqToHom ⋯ := by"
  },
  {
    "full_name": "Complex.isTheta_cpow_rpow",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean",
    "teorema": "lemma Complex.isTheta_cpow_rpow (f : α → ℂ) (g : α → ℂ) (l : Filter α) (α : Type u_1) : (let_fun this := fun x => abs (f x) ^ (g x).re / 1; this) =ᶠ[l] := by"
  },
  {
    "full_name": "MeasurableEmbedding.absolutelyContinuous_map",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
    "teorema": "lemma MeasurableEmbedding.absolutelyContinuous_map (f : α → β) (α : Type u_1) (β : Type u_2) (μ : Measure α) (ν : Measure α) : Measure.map f μ ≪ Measure.map f ν := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.sup_apply",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/Operations.lean",
    "teorema": "theorem MeasureTheory.OuterMeasure.sup_apply (m₁ : OuterMeasure α) (m₂ : OuterMeasure α) (s : Set α) (α : Type u_1) : (m₁ ⊔ m₂) s = m₁ s ⊔ m₂ s := by"
  },
  {
    "full_name": "LieModuleEquiv.symm_symm",
    "file_path": "Mathlib/Algebra/Lie/Basic.lean",
    "teorema": "lemma LieModuleEquiv.symm_symm (L : Type v) (M : Type w) (N : Type w₁) (R : Type u) (e : M ≃ₗ⁅R,L⁆ N) : e.symm.symm = e := by"
  },
  {
    "full_name": "LinearMap.polyCharpolyAux_map_eq_charpoly",
    "file_path": "Mathlib/Algebra/Module/LinearMap/Polynomial.lean",
    "teorema": "theorem LinearMap.polyCharpolyAux_map_eq_charpoly (L : Type u_2) (M : Type u_3) (R : Type u_1) (b : Basis ι R L) (bₘ : Basis ιM R M) (x : L) (ι : Type u_5) (ιM : Type u_7) (φ : L →ₗ[R] Module.End R M) : Polynomial.map (MvPolynomial.eval ⇑(b.repr x)) (φ.polyCharpolyAux b bₘ) = charpoly (φ x) := by"
  },
  {
    "full_name": "Fin.castOrderIso_toEquiv",
    "file_path": "Mathlib/Order/Fin.lean",
    "teorema": "lemma Fin.castOrderIso_toEquiv (h : n = m) (m : ℕ) (n : ℕ) : (castOrderIso h).toEquiv = Equiv.cast ⋯ := by"
  },
  {
    "full_name": "MeasurableSpace.generateFrom_iUnion_countablePartition",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
    "teorema": "lemma MeasurableSpace.generateFrom_iUnion_countablePartition (m : MeasurableSpace α) (α : Type u_3) : generateFrom (⋃ n, countablePartition α n) = m := by"
  },
  {
    "full_name": "IsLUB.exists_seq_monotone_tendsto",
    "file_path": "Mathlib/Topology/Order/IsLUB.lean",
    "teorema": "theorem IsLUB.exists_seq_monotone_tendsto (t : Set α) (x : α) (α : Type u_1) : ∃ u, Monotone u ∧ (∀ (n : ℕ), u n ≤ x) ∧ Tendsto u atTop (𝓝 x) ∧ ∀ (n : ℕ), u n ∈ t := by"
  },
  {
    "full_name": "integral_exp_neg_mul_rpow",
    "file_path": "Mathlib/MeasureTheory/Integral/Gamma.lean",
    "teorema": "lemma integral_exp_neg_mul_rpow (b : ℝ) (p : ℝ) : ∫ (x : ℝ) in Ioi 0, rexp (-b * x ^ p) = b ^ (-1 / p) * Gamma (1 / p + 1) := by"
  },
  {
    "full_name": "AlgebraCat.forget₂_map_associator_hom",
    "file_path": "Mathlib/Algebra/Category/AlgebraCat/Monoidal.lean",
    "teorema": "lemma AlgebraCat.forget₂_map_associator_hom (R : Type u) (X : AlgebraCat R) (Y : AlgebraCat R) (Z : AlgebraCat R) : (forget₂ (AlgebraCat R) (ModuleCat R)).map (α_ X Y Z).hom = (α_ ((forget₂ (AlgebraCat R) (ModuleCat R)).obj X) ((forget₂ (AlgebraCat R) (ModuleCat R)).obj Y) ((forget₂ (AlgebraCat R) (ModuleCat R)).obj Z)).hom := by"
  },
  {
    "full_name": "CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_right",
    "file_path": "Mathlib/CategoryTheory/LiftingProperties/Basic.lean",
    "teorema": "lemma CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_right (A : C) (B : C) (C : Type u_1) (X : C) (Y : C) (i : A ⟶ B) (p : X ⟶ Y) : HasLiftingProperty i p ↔ HasLiftingProperty i p' := by"
  },
  {
    "full_name": "SimpleGraph.singletonSubgraph_le_iff",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean",
    "teorema": "theorem SimpleGraph.singletonSubgraph_le_iff (G : SimpleGraph V) (H : G.Subgraph) (V : Type u) (v : V) : G.singletonSubgraph v ≤ H ↔ v ∈ H.verts := by"
  },
  {
    "full_name": "Multiset.le_iff_count",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.le_iff_count (s : Multiset α) (t : Multiset α) (α : Type u_1) : s ≤ t := by"
  },
  {
    "full_name": "PowerSeries.coeff_def",
    "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
    "teorema": "lemma PowerSeries.coeff_def (R : Type u_1) (n : ℕ) (s : Unit →₀ ℕ) : coeff R n = MvPowerSeries.coeff R s := by"
  },
  {
    "full_name": "strictMonoOn_dual_iff",
    "file_path": "Mathlib/Order/Monotone/Basic.lean",
    "teorema": "lemma strictMonoOn_dual_iff (f : α → β) (s : Set α) (α : Type u) (β : Type v) : StrictMonoOn (⇑toDual ∘ f ∘ ⇑ofDual) s ↔ StrictMonoOn f s := by"
  },
  {
    "full_name": "Mathlib.Tactic.Abel.term_smul",
    "file_path": "Mathlib/Tactic/Abel.lean",
    "teorema": "theorem Mathlib.Tactic.Abel.term_smul (a : α) (c : ℕ) (n : ℕ) (x : α) (α : Type u_1) : smul c (term n x a) = term n' x a' := by"
  },
  {
    "full_name": "FiberBundle.totalSpaceMk_closedEmbedding",
    "file_path": "Mathlib/Topology/FiberBundle/Basic.lean",
    "teorema": "theorem FiberBundle.totalSpaceMk_closedEmbedding (B : Type u_2) (x : B) : IsClosed (range (TotalSpace.mk x)) := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.negAddY_eq",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "theorem WeierstrassCurve.Jacobian.negAddY_eq (F : Type v) (P : Fin 3 → F) (Q : Fin 3 → F) (W : Jacobian F) : W.negAddY P Q = ((P y * Q z ^ 3 - Q y * P z ^ 3) * (W.addX P Q * (P z * Q z) ^ 2 - P x * Q z ^ 2 * addZ P Q ^ 2) + P y * Q z ^ 3 * addZ P Q ^ 3) / (P z * Q z) ^ 3 := by"
  },
  {
    "full_name": "SimpleGraph.cliqueFree_iff",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "teorema": "theorem SimpleGraph.cliqueFree_iff (G : SimpleGraph α) (n : ℕ) (α : Type u_1) : G.CliqueFree n ↔ IsEmpty (⊤ ↪g G) := by"
  },
  {
    "full_name": "CategoryTheory.Presieve.isSheafFor_iff_generate",
    "file_path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
    "teorema": "lemma CategoryTheory.Presieve.isSheafFor_iff_generate (C : Type u₁) (P : Cᵒᵖ ⥤ Type w) (R : Presieve X) (X : C) : IsSheafFor P R ↔ IsSheafFor P (generate R).arrows := by"
  },
  {
    "full_name": "Finset.preimage_compl",
    "file_path": "Mathlib/Data/Finset/Preimage.lean",
    "teorema": "theorem Finset.preimage_compl (f : α → β) (s : Finset β) (α : Type u) (β : Type v) : ↑(sᶜ.preimage f ⋯) = ↑(s.preimage f ⋯)ᶜ := by"
  },
  {
    "full_name": "AlgebraicGeometry.isOpenImmersion_isLocalAtTarget",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/OpenImmersion.lean",
    "teorema": "theorem AlgebraicGeometry.isOpenImmersion_isLocalAtTarget : PropertyIsLocalAtTarget @IsOpenImmersion := by"
  },
  {
    "full_name": "MeasureTheory.compl_mem_measurableCylinders",
    "file_path": "Mathlib/MeasureTheory/Constructions/Cylinders.lean",
    "teorema": "lemma MeasureTheory.compl_mem_measurableCylinders (α : ι → Type u_2) (ι : Type u_1) : sᶜ ∈ measurableCylinders α := by"
  },
  {
    "full_name": "IsLocalMaxOn.hasFDerivWithinAt_nonpos",
    "file_path": "Mathlib/Analysis/Calculus/LocalExtr/Basic.lean",
    "teorema": "lemma IsLocalMaxOn.hasFDerivWithinAt_nonpos (E : Type u) (f : E → ℝ) (y : E) : f' y ≤ 0 := by"
  },
  {
    "full_name": "CategoryTheory.ProjectiveResolution.π_f_succ",
    "file_path": "Mathlib/CategoryTheory/Preadditive/ProjectiveResolution.lean",
    "teorema": "lemma CategoryTheory.ProjectiveResolution.π_f_succ (n : ℕ) : n + 1 ≠ 0 := by"
  },
  {
    "full_name": "VectorFourier.fourierIntegral_comp_add_right",
    "file_path": "Mathlib/Analysis/Fourier/FourierTransform.lean",
    "teorema": "lemma VectorFourier.fourierIntegral_comp_add_right (E : Type u_4) (L : V →ₗ[𝕜] W →ₗ[𝕜] 𝕜) (V : Type u_2) (W : Type u_3) (e : AddChar 𝕜 ↥𝕊) (f : V → E) (v₀ : V) (μ : Measure V) (𝕜 : Type u_1) : fourierIntegral e μ L (f ∘ fun v => v + v₀) = fun w => e ((L v₀) w) • fourierIntegral e μ L f w := by"
  },
  {
    "full_name": "ArithmeticFunction.pmul_assoc",
    "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean",
    "teorema": "theorem ArithmeticFunction.pmul_assoc (R : Type u_1) (f₁ : ArithmeticFunction R) (f₂ : ArithmeticFunction R) (f₃ : ArithmeticFunction R) : (f₁.pmul f₂).pmul f₃ = f₁.pmul (f₂.pmul f₃) := by"
  },
  {
    "full_name": "HomologicalComplex.opcyclesToCycles_iCycles",
    "file_path": "Mathlib/Algebra/Homology/HomologySequence.lean",
    "teorema": "theorem HomologicalComplex.opcyclesToCycles_iCycles (C : Type u_1) (K : HomologicalComplex C c) (c : ComplexShape ι) (i : ι) (j : ι) (ι : Type u_2) : K.opcyclesToCycles i j ≫ K.iCycles j = K.fromOpcycles i j := by"
  },
  {
    "full_name": "UniformInducing.cauchy_map_iff",
    "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean",
    "teorema": "theorem UniformInducing.cauchy_map_iff (F : Filter α) (f : α → β) (α : Type u) (β : Type v) : Cauchy (map f F) ↔ Cauchy F := by"
  },
  {
    "full_name": "ZNum.bit1_of_bit1",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "theorem ZNum.bit1_of_bit1 (a : PosNum) : sub' 1 (_root_.bit0 a) = (neg a).bit1 := by"
  },
  {
    "full_name": "monic_descPochhammer",
    "file_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
    "teorema": "lemma monic_descPochhammer (R : Type u) (n : ℕ) : (descPochhammer R n).Monic := by"
  },
  {
    "full_name": "HasStrictFDerivAt.approximates_deriv_on_nhds",
    "file_path": "Mathlib/Analysis/Calculus/InverseFunctionTheorem/FDeriv.lean",
    "teorema": "theorem HasStrictFDerivAt.approximates_deriv_on_nhds (E : Type u_2) (F : Type u_3) (a : E) (c : ℝ≥0) (f : E → F) : ∃ s ∈ 𝓝 a, ApproximatesLinearOn f f' s c := by"
  },
  {
    "full_name": "isLocalStructomorphOn_contDiffGroupoid_iff",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Atlas.lean",
    "teorema": "theorem isLocalStructomorphOn_contDiffGroupoid_iff (E : Type u_2) (H : Type u_3) (I : ModelWithCorners 𝕜 E H) (M : Type u_4) (f : PartialHomeomorph M M') (𝕜 : Type u_1) : LiftPropOn (contDiffGroupoid ⊤ I).IsLocalStructomorphWithinAt (↑f) f.source ↔ SmoothOn I I (↑f) f.source ∧ SmoothOn I I (↑f.symm) f.target := by"
  },
  {
    "full_name": "Nat.ceil_eq_zero",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Nat.ceil_eq_zero (a : α) (α : Type u_2) : ⌈a⌉₊ = 0 ↔ a ≤ 0 := by"
  },
  {
    "full_name": "pow_two",
    "file_path": "Mathlib/Algebra/Group/Defs.lean",
    "teorema": "lemma pow_two (M : Type u_2) (a : M) : a ^ 2 = a * a := by"
  },
  {
    "full_name": "smul_ceilDiv",
    "file_path": "Mathlib/Algebra/Order/Floor/Div.lean",
    "teorema": "lemma smul_ceilDiv (a : α) (b : β) (α : Type u_2) (β : Type u_3) : ∀ (c : β), a • b ⌈/⌉ a ≤ c ↔ b ≤ c := by"
  },
  {
    "full_name": "Ideal.IsHomogeneous.sSup",
    "file_path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean",
    "teorema": "lemma Ideal.IsHomogeneous.sSup (A : Type u_4) (ι : Type u_1) (σ : Type u_2) (ℐ : Set (Ideal A)) (𝒜 : ι → σ) : IsHomogeneous 𝒜 (SupSet.sSup ℐ) := by"
  },
  {
    "full_name": "LieAlgebra.IsKilling.eq_neg_or_eq_of_eq_smul",
    "file_path": "Mathlib/Algebra/Lie/Weights/RootSystem.lean",
    "teorema": "lemma LieAlgebra.IsKilling.eq_neg_or_eq_of_eq_smul (H : LieSubalgebra K L) (K : Type u_1) (L : Type u_2) (α : Weight K (↥H) L) (β : Weight K (↥H) L) : β = -α ∨ β = α := by"
  },
  {
    "full_name": "MeasureTheory.measure_union_lt_top_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean",
    "teorema": "lemma MeasureTheory.measure_union_lt_top_iff (s : Set α) (t : Set α) (α : Type u_1) (μ : Measure α) : μ (s ∪ t) < ⊤ ↔ μ s < ⊤ ∧ μ t < ⊤ := by"
  },
  {
    "full_name": "IsPreconnected.intermediate_value₂_eventually₂",
    "file_path": "Mathlib/Topology/Order/IntermediateValue.lean",
    "teorema": "lemma IsPreconnected.intermediate_value₂_eventually₂ (X : Type u) (f : X → α) (g : X → α) (s : Set X) (α : Type v) : ∃ x ∈ s, f x = g x := by"
  },
  {
    "full_name": "Nat.gcd_add_self_left",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "teorema": "lemma Nat.gcd_add_self_left (m : ℕ) (n : ℕ) : (m + n).gcd n = m.gcd n := by"
  },
  {
    "full_name": "List.mem_zip_inits_tails",
    "file_path": "Mathlib/Data/List/Zip.lean",
    "teorema": "lemma List.mem_zip_inits_tails (init : List α) (l : List α) (tail : List α) (α : Type u) : (init, tail) ∈ l.inits.zip l.tails ↔ init ++ tail = l := by"
  },
  {
    "full_name": "Turing.PartrecToTM2.supports_singleton",
    "file_path": "Mathlib/Computability/TMToPartrec.lean",
    "teorema": "theorem Turing.PartrecToTM2.supports_singleton (S : Finset Λ') (q : Λ') : Supports {q} S ↔ TM2.SupportsStmt S (tr q) := by"
  },
  {
    "full_name": "LiouvilleWith.int_sub_iff",
    "file_path": "Mathlib/NumberTheory/Liouville/LiouvilleWith.lean",
    "teorema": "theorem LiouvilleWith.int_sub_iff (m : ℤ) (p : ℝ) (x : ℝ) : LiouvilleWith p (↑m - x) ↔ LiouvilleWith p x := by"
  },
  {
    "full_name": "Ideal.irreducible_of_irreducible_absNorm",
    "file_path": "Mathlib/RingTheory/Ideal/Norm.lean",
    "teorema": "lemma Ideal.irreducible_of_irreducible_absNorm (I : Ideal S) (S : Type u_1) : IsUnit (absNorm I) := by"
  },
  {
    "full_name": "vectorSpan_insert_eq_vectorSpan",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "theorem vectorSpan_insert_eq_vectorSpan (P : Type u_3) (k : Type u_1) (p : P) (ps : Set P) : vectorSpan k (insert p ps) = vectorSpan k ps := by"
  },
  {
    "full_name": "LinearMap.injective_domRestrict_iff",
    "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean",
    "teorema": "lemma LinearMap.injective_domRestrict_iff (M : Type u_6) (M₂ : Type u_8) (R : Type u_1) (R₂ : Type u_3) (S : Submodule R M) (f : M →ₛₗ[τ₁₂] M₂) (τ₁₂ : R →+* R₂) : Injective ⇑(f.domRestrict S) ↔ S ⊓ ker f = ⊥ := by"
  },
  {
    "full_name": "C_p_pow_dvd_bind₁_rename_wittPolynomial_sub_sum",
    "file_path": "Mathlib/RingTheory/WittVector/StructurePolynomial.lean",
    "teorema": "lemma C_p_pow_dvd_bind₁_rename_wittPolynomial_sub_sum (idx : Type u_2) (n : ℕ) (p : ℕ) (Φ : MvPolynomial idx ℤ) : C ↑(p ^ n) ∣ (bind₁ fun b => (rename fun i => (b, i)) (W_ ℤ n)) Φ - ∑ i ∈ Finset.range n, C (↑p ^ i) * wittStructureInt p Φ i ^ p ^ (n - i) := by"
  },
  {
    "full_name": "SetTheory.PGame.Impartial.nonneg",
    "file_path": "Mathlib/SetTheory/Game/Impartial.lean",
    "teorema": "lemma SetTheory.PGame.Impartial.nonneg : False := by"
  },
  {
    "full_name": "NNReal.ball_zero_eq_Ico'",
    "file_path": "Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean",
    "teorema": "theorem NNReal.ball_zero_eq_Ico' (c : ℝ≥0) : ball 0 ↑c = Ico 0 c := by"
  },
  {
    "full_name": "ContDiffOn.comp",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma ContDiffOn.comp (E : Type uE) (F : Type uF) (G : Type uG) (f : E → F) (g : F → G) (n : ℕ∞) (s : Set E) (𝕜 : Type u_1) : ContDiffOn 𝕜 n (g ∘ f) s := by"
  },
  {
    "full_name": "ProbabilityTheory.mgf_undef",
    "file_path": "Mathlib/Probability/Moments.lean",
    "teorema": "theorem ProbabilityTheory.mgf_undef (X : Ω → ℝ) (t : ℝ) (Ω : Type u_1) (μ : Measure Ω) : mgf X μ t = 0 := by"
  },
  {
    "full_name": "Embedding.map_nhdsWithin_eq",
    "file_path": "Mathlib/Topology/ContinuousOn.lean",
    "teorema": "theorem Embedding.map_nhdsWithin_eq (f : α → β) (s : Set α) (x : α) (α : Type u_1) (β : Type u_2) : map f (𝓝[s] x) = 𝓝[f '' s] f x := by"
  },
  {
    "full_name": "Polynomial.ker_mapRingHom",
    "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean",
    "teorema": "lemma Polynomial.ker_mapRingHom (R : Type u) (S : Type u_1) (f : R →+* S) : LinearMap.ker (mapRingHom f).toSemilinearMap = map C (RingHom.ker f) := by"
  },
  {
    "full_name": "Seminorm.neg_ball",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "lemma Seminorm.neg_ball (E : Type u_7) (p : Seminorm 𝕜 E) (r : ℝ) (x : E) (𝕜 : Type u_3) : -p.ball x r = p.ball (-x) r := by"
  },
  {
    "full_name": "Finset.sigmaLift_nonempty",
    "file_path": "Mathlib/Data/Finset/Sigma.lean",
    "teorema": "theorem Finset.sigmaLift_nonempty (a : (i : ι) × α i) (b : (i : ι) × β i) (f : ⦃i : ι⦄ → α i → β i → Finset (γ i)) (α : ι → Type u_2) (β : ι → Type u_3) (γ : ι → Type u_4) (ι : Type u_1) : (sigmaLift f a b).Nonempty ↔ ∃ (h : a.fst = b.fst), (f (h ▸ a.snd) b.snd).Nonempty := by"
  },
  {
    "full_name": "Affine.Simplex.circumsphere_reindex",
    "file_path": "Mathlib/Geometry/Euclidean/Circumcenter.lean",
    "teorema": "lemma Affine.Simplex.circumsphere_reindex (P : Type u_2) (e : Fin (m + 1) ≃ Fin (n + 1)) (m : ℕ) (n : ℕ) (s : Simplex ℝ P m) : (s.reindex e).circumsphere = s.circumsphere := by"
  },
  {
    "full_name": "Pi.basisFun_repr",
    "file_path": "Mathlib/LinearAlgebra/StdBasis.lean",
    "teorema": "lemma Pi.basisFun_repr (R : Type u_1) (i : η) (x : η → R) (η : Type u_2) : ((basisFun R η).repr x) i = x i := by"
  },
  {
    "full_name": "Set.projIic_eq_self",
    "file_path": "Mathlib/Order/Interval/Set/ProjIcc.lean",
    "teorema": "lemma Set.projIic_eq_self (b : α) (x : α) (α : Type u_1) : projIic b x = ⟨b, ⋯⟩ ↔ b ≤ x := by"
  },
  {
    "full_name": "MeasureTheory.SimpleFunc.nnnorm_approxOn_le",
    "file_path": "Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean",
    "teorema": "theorem MeasureTheory.SimpleFunc.nnnorm_approxOn_le (E : Type u_4) (f : β → E) (hf : Measurable f) (h₀ : y₀ ∈ s) (n : ℕ) (s : Set E) (x : β) (y₀ : E) (β : Type u_2) : ‖↑(approxOn f hf s y₀ h₀ n) x - f x‖₊ ≤ ‖f x - y₀‖₊ := by"
  },
  {
    "full_name": "Multiset.rel_refl_of_refl_on",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.rel_refl_of_refl_on (m : Multiset α) (r : α → α → Prop) (α : Type u_1) : (∀ x ∈ m, r x x) → Rel r m m := by"
  },
  {
    "full_name": "Real.cos_pi_div_four",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
    "teorema": "lemma Real.cos_pi_div_four : cos (π / 4) = √2 / 2 := by"
  },
  {
    "full_name": "zero_le_two",
    "file_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean",
    "teorema": "theorem zero_le_two : 0 ≤ 2 := by"
  },
  {
    "full_name": "UpperHalfPlane.im_inv_neg_coe_pos",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean",
    "teorema": "theorem UpperHalfPlane.im_inv_neg_coe_pos (z : ℍ) : 0 < (-↑z)⁻¹.im := by"
  },
  {
    "full_name": "LieDerivation.coe_ad_apply_eq_ad_apply",
    "file_path": "Mathlib/Algebra/Lie/Derivation/AdjointAction.lean",
    "teorema": "lemma LieDerivation.coe_ad_apply_eq_ad_apply (L : Type u_2) (R : Type u_1) (x : L) : ↑((ad R L) x) = (LieAlgebra.ad R L) x := by"
  },
  {
    "full_name": "newton_seq_dist",
    "file_path": "Mathlib/NumberTheory/Padics/Hensel.lean",
    "teorema": "lemma newton_seq_dist (F : Polynomial ℤ_[p]) (a : ℤ_[p]) (k : ℕ) (n : ℕ) (p : ℕ) : ‖newton_seq k - newton_seq n‖ ≤ ‖Polynomial.eval a (Polynomial.derivative F)‖ * T_gen p F a ^ 2 ^ n := by"
  },
  {
    "full_name": "CategoryTheory.EffectiveEpiFamily.transitive_of_finite",
    "file_path": "Mathlib/CategoryTheory/Sites/Coherent/CoherentTopology.lean",
    "teorema": "theorem CategoryTheory.EffectiveEpiFamily.transitive_of_finite (C : Type u_1) (X : C) (Y : α → C) (Y_n : (a : α) → β a → C) (α : Type) (β : α → Type) (π : (a : α) → Y a ⟶ X) (π_n : (a : α) → (b : β a) → Y_n a b ⟶ Y a) : EffectiveEpiFamily (fun c => Y_n c.fst c.snd) fun c => π_n c.fst c.snd ≫ π c.fst := by"
  },
  {
    "full_name": "Matrix.zpow_bit1",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "teorema": "lemma Matrix.zpow_bit1 (A : M) (n : ℤ) : A ^ bit1 n = A ^ n * A ^ n * A := by"
  },
  {
    "full_name": "MeasureTheory.Measure.exists_measure_inter_spanningSets_pos",
    "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean",
    "teorema": "theorem MeasureTheory.Measure.exists_measure_inter_spanningSets_pos (s : Set α) (α : Type u_1) (μ : Measure α) : (∃ n, 0 < μ (s ∩ spanningSets μ n)) ↔ 0 < μ s := by"
  },
  {
    "full_name": "Set.image_sInter_subset",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "theorem Set.image_sInter_subset (S : Set (Set α)) (f : α → β) (α : Type u_1) (β : Type u_2) : f '' ⋂₀ S ⊆ ⋂ s ∈ S, f '' s := by"
  },
  {
    "full_name": "UniformOnFun.gen_eq_preimage_restrict",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "lemma UniformOnFun.gen_eq_preimage_restrict (S : Set α) (V : Set (β × β)) (α : Type u_1) (β : Type u_2) (𝔖 : Set (Set α)) : UniformOnFun.gen 𝔖 S V = Prod.map (S.restrict ∘ ⇑UniformFun.toFun) (S.restrict ∘ ⇑UniformFun.toFun) ⁻¹' UniformFun.gen (↑S) β V := by"
  },
  {
    "full_name": "MeasureTheory.locallyIntegrable_finset_sum",
    "file_path": "Mathlib/MeasureTheory/Function/LocallyIntegrable.lean",
    "teorema": "lemma MeasureTheory.locallyIntegrable_finset_sum (E : Type u_3) (X : Type u_1) (f : ι → X → E) (s : Finset ι) (ι : Type u_6) (μ : Measure X) : LocallyIntegrable (fun a => ∑ i ∈ s, f i a) μ := by"
  },
  {
    "full_name": "Matrix.charpoly_map",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean",
    "teorema": "lemma Matrix.charpoly_map (M : Matrix n n R) (R : Type u_1) (S : Type u_2) (f : R →+* S) (n : Type u_4) : (M.map ⇑f).charpoly = Polynomial.map f M.charpoly := by"
  },
  {
    "full_name": "Nat.digits_of_lt",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "teorema": "lemma Nat.digits_of_lt (b : ℕ) (x : ℕ) : b.digits x = [x] := by"
  },
  {
    "full_name": "Hyperreal.infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg",
    "file_path": "Mathlib/Data/Real/Hyperreal.lean",
    "teorema": "theorem Hyperreal.infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg (x : ℝ*) (y : ℝ*) : x.InfiniteNeg → ¬y.Infinitesimal → y < 0 → (x * y).InfinitePos := by"
  },
  {
    "full_name": "OpenEmbedding.tendsto_nhds_iff'",
    "file_path": "Mathlib/Topology/Maps.lean",
    "teorema": "lemma OpenEmbedding.tendsto_nhds_iff' (X : Type u_1) (Y : Type u_2) (Z : Type u_3) (f : X → Y) (g : Y → Z) (l : Filter Z) (x : X) : Tendsto (g ∘ f) (𝓝 x) l ↔ Tendsto g (𝓝 (f x)) l := by"
  },
  {
    "full_name": "Polynomial.pow_mul_divByMonic_rootMultiplicity_eq",
    "file_path": "Mathlib/Algebra/Polynomial/Div.lean",
    "teorema": "lemma Polynomial.pow_mul_divByMonic_rootMultiplicity_eq (R : Type u) (a : R) (p : R[X]) : (X - C a) ^ rootMultiplicity a p * (p /ₘ (X - C a) ^ rootMultiplicity a p) = p := by"
  },
  {
    "full_name": "WeierstrassCurve.Affine.evalEval_polynomial_zero",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean",
    "teorema": "theorem WeierstrassCurve.Affine.evalEval_polynomial_zero (R : Type u) (W : Affine R) : evalEval 0 0 W.polynomial = -W.a₆ := by"
  },
  {
    "full_name": "Fin.min_val",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.min_val (a : Fin n) (n : ℕ) : min (↑a) n = ↑a := by"
  },
  {
    "full_name": "not_summable_indicator_mod_of_antitone_of_neg",
    "file_path": "Mathlib/Analysis/SumOverResidueClass.lean",
    "teorema": "lemma not_summable_indicator_mod_of_antitone_of_neg (f : ℕ → ℝ) (k : ZMod m) (m : ℕ) (n : ℕ) : ¬Summable ({n | ↑n = k}.indicator f) := by"
  },
  {
    "full_name": "lcm_dvd_iff",
    "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean",
    "teorema": "lemma lcm_dvd_iff (a : α) (b : α) (c : α) (α : Type u_1) : lcm a b ∣ c ↔ a ∣ c ∧ b ∣ c := by"
  },
  {
    "full_name": "FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos",
    "file_path": "Mathlib/Analysis/Analytic/Inverse.lean",
    "teorema": "lemma FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos (E : Type u_2) (F : Type u_3) (i : E ≃L[𝕜] F) (p : FormalMultilinearSeries 𝕜 E F) (𝕜 : Type u_1) : 0 < (p.rightInv i).radius := by"
  },
  {
    "full_name": "tprod_eq_mul_tprod_ite'",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean",
    "teorema": "lemma tprod_eq_mul_tprod_ite' (b : β) (f : β → α) (n : β) (α : Type u_1) (β : Type u_2) : f n = (if n = b then f n else 1) * update f b 1 n := by"
  },
  {
    "full_name": "CategoryTheory.Preadditive.mono_of_isZero_kernel'",
    "file_path": "Mathlib/CategoryTheory/Preadditive/Basic.lean",
    "teorema": "theorem CategoryTheory.Preadditive.mono_of_isZero_kernel' (C : Type u) (P : C) (X : C) (g : P✝ ⟶ X) : g = 0 := by"
  },
  {
    "full_name": "balancedCoreAux_subset",
    "file_path": "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean",
    "teorema": "lemma balancedCoreAux_subset (E : Type u_2) (s : Set E) (x : E) : x ∈ s := by"
  },
  {
    "full_name": "Equiv.swap_smul_self_smul",
    "file_path": "Mathlib/GroupTheory/Perm/Basic.lean",
    "teorema": "lemma Equiv.swap_smul_self_smul (i : α) (j : α) (x : β) (α : Type u) (β : Type v) : swap i j • swap i j • x = x := by"
  },
  {
    "full_name": "BddBelow.isBoundedUnder",
    "file_path": "Mathlib/Order/LiminfLimsup.lean",
    "teorema": "theorem BddBelow.isBoundedUnder (b : α) (u : β → α) (α : Type u_1) (β : Type u_2) : ∀ (x : β), u x ≥ b := by"
  },
  {
    "full_name": "MeasureTheory.SimpleFunc.ennrealRatEmbed_encode",
    "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean",
    "teorema": "lemma MeasureTheory.SimpleFunc.ennrealRatEmbed_encode (q : ℚ) : ennrealRatEmbed (Encodable.encode q) = ↑(↑q).toNNReal := by"
  },
  {
    "full_name": "Stream'.Seq.not_terminates_iff",
    "file_path": "Mathlib/Data/Seq/Seq.lean",
    "teorema": "theorem Stream'.Seq.not_terminates_iff (s : Seq α) (α : Type u) : ¬s.Terminates ↔ ∀ (n : ℕ), (s.get? n).isSome = true := by"
  },
  {
    "full_name": "MulAction.card_orbit_mul_card_stabilizer_eq_card_group",
    "file_path": "Mathlib/GroupTheory/GroupAction/Quotient.lean",
    "teorema": "theorem MulAction.card_orbit_mul_card_stabilizer_eq_card_group (b : β) (α : Type u) (β : Type v) : Fintype.card ↑(orbit α b) * Fintype.card ↥(stabilizer α b) = Fintype.card α := by"
  },
  {
    "full_name": "MeasureTheory.Measure.addHaar_parallelepiped",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean",
    "teorema": "lemma MeasureTheory.Measure.addHaar_parallelepiped (G : Type u_4) (b : Basis ι ℝ G) (v : ι → G) (ι : Type u_3) : b.addHaar (parallelepiped v) = ENNReal.ofReal |b.det v| := by"
  },
  {
    "full_name": "ContMDiffWithinAt.prod_mk",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Product.lean",
    "teorema": "theorem ContMDiffWithinAt.prod_mk (E : Type u_2) (F : Type u_11) (G : Type u_12) (H : Type u_3) (I : ModelWithCorners 𝕜 E H) (J : ModelWithCorners 𝕜 F G) (M : Type u_4) (N : Type u_13) (f : M → M') (g : M → N') (n : ℕ∞) (s : Set M) (x : M) (𝕜 : Type u_1) : ContMDiffWithinAt I (I'.prod J') n (fun x => (f x, g x)) s x := by"
  },
  {
    "full_name": "Trivialization.coordChange_coordChange",
    "file_path": "Mathlib/Topology/FiberBundle/Trivialization.lean",
    "teorema": "theorem Trivialization.coordChange_coordChange (B : Type u_2) (F : Type u_3) (Z : Type u_5) (b : B) (e₁ : Trivialization F proj) (e₂ : Trivialization F proj) (e₃ : Trivialization F proj) (proj : Z → B) (x : F) : e₂.coordChange e₃ b (e₁.coordChange e₂ b x) = e₁.coordChange e₃ b x := by"
  },
  {
    "full_name": "TensorProduct.LieModule.lie_tmul_right",
    "file_path": "Mathlib/Algebra/Lie/TensorProduct.lean",
    "teorema": "theorem TensorProduct.LieModule.lie_tmul_right (L : Type v) (M : Type w) (N : Type w₁) (R : Type u) (m : M) (n : N) (x : L) : (hasBracketAux x) (m ⊗ₜ[R] n) = ⁅x, m⁆ ⊗ₜ[R] n + m ⊗ₜ[R] ⁅x, n⁆ := by"
  },
  {
    "full_name": "LieModule.coe_linearMap_maxTrivLinearMapEquivLieModuleHom",
    "file_path": "Mathlib/Algebra/Lie/Abelian.lean",
    "teorema": "theorem LieModule.coe_linearMap_maxTrivLinearMapEquivLieModuleHom (L : Type v) (M : Type w) (N : Type w₁) (R : Type u) (f : ↥(maxTrivSubmodule R L (M →ₗ[R] N))) : ↑(maxTrivLinearMapEquivLieModuleHom f) = ↑f := by"
  },
  {
    "full_name": "Ordinal.IsNormal.bsup_eq",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "theorem Ordinal.IsNormal.bsup_eq (f : Ordinal.{u} → Ordinal.{max u v}) (o : Ordinal.{u}) : (o.bsup fun x x_1 => f x) = f o := by"
  },
  {
    "full_name": "EReal.sign_mul",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "lemma EReal.sign_mul (x : EReal) (y : EReal) : sign (x * y) = sign x * sign y := by"
  },
  {
    "full_name": "TopCat.Presheaf.ext",
    "file_path": "Mathlib/Topology/Sheaves/Presheaf.lean",
    "teorema": "lemma TopCat.Presheaf.ext (C : Type u) (P : Presheaf C X) (Q : Presheaf C X) (X : TopCat) (f : P ⟶ Q) (g : P ⟶ Q) : f = g := by"
  },
  {
    "full_name": "Finset.isGLB_mem",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "theorem Finset.isGLB_mem (i : α) (s : Finset α) (α : Type u_2) : i ∈ s := by"
  },
  {
    "full_name": "pow_eq_one_iff_cases",
    "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean",
    "teorema": "theorem pow_eq_one_iff_cases (R : Type u_2) (a : R) (n : ℕ) : a ^ n = 1 ↔ n = 0 ∨ a = 1 ∨ a = -1 ∧ Even n := by"
  },
  {
    "full_name": "CoxeterSystem.simple_mul_simple_cancel_left",
    "file_path": "Mathlib/GroupTheory/Coxeter/Basic.lean",
    "teorema": "theorem CoxeterSystem.simple_mul_simple_cancel_left (B : Type u_1) (M : CoxeterMatrix B) (W : Type u_3) (cs : CoxeterSystem M W) (i : B) (w : W) : cs.simple i * (cs.simple i * w) = w := by"
  },
  {
    "full_name": "Associates.factors_subsingleton",
    "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean",
    "teorema": "theorem Associates.factors_subsingleton (a : Associates α) (α : Type u_1) : a.factors = ⊤ := by"
  },
  {
    "full_name": "Fintype.card_piFinset",
    "file_path": "Mathlib/Data/Fintype/BigOperators.lean",
    "teorema": "lemma Fintype.card_piFinset (s : (i : ι) → Finset (α i)) (α : ι → Type u_6) (ι : Type u_4) : (piFinset s).card = ∏ i : ι, (s i).card := by"
  },
  {
    "full_name": "Ordnode.BalancedSz.symm",
    "file_path": "Mathlib/Data/Ordmap/Ordset.lean",
    "teorema": "theorem Ordnode.BalancedSz.symm (l : ℕ) (r : ℕ) : l + r ≤ 1 → r + l ≤ 1 := by"
  },
  {
    "full_name": "Filter.map_inf",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "theorem Filter.map_inf (f : Filter α) (g : Filter α) (m : α → β) (α : Type u) (β : Type v) : map m (f ⊓ g) = map m f ⊓ map m g := by"
  },
  {
    "full_name": "Set.image2_iUnion_left",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "lemma Set.image2_iUnion_left (f : α → β → γ) (s : ι → Set α) (t : Set β) (α : Type u_1) (β : Type u_2) (γ : Type u_3) (ι : Sort u_4) : image2 f (⋃ i, s i) t = ⋃ i, image2 f (s i) t := by"
  },
  {
    "full_name": "Finset.sdiff_erase",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma Finset.sdiff_erase (a : α) (s : Finset α) (t : Finset α) (α : Type u_1) : s \\ t.erase a = insert a (s \\ t) := by"
  },
  {
    "full_name": "ZMod.valMinAbs_eq_zero",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "teorema": "theorem ZMod.valMinAbs_eq_zero (n : ℕ) (x : ZMod n) : x.valMinAbs = 0 ↔ x = 0 := by"
  },
  {
    "full_name": "Fintype.prod_bool",
    "file_path": "Mathlib/Data/Fintype/BigOperators.lean",
    "teorema": "lemma Fintype.prod_bool (f : Bool → α) (α : Type u_1) : ∏ b : Bool, f b = f true * f false := by"
  },
  {
    "full_name": "Mathlib.Meta.NormNum.isRat_div",
    "file_path": "Mathlib/Tactic/NormNum/Basic.lean",
    "teorema": "theorem Mathlib.Meta.NormNum.isRat_div (x✝ : ℕ) (x✝² : α) (x✝³ : α) (x✝¹ : ℤ) (α : Type u_1) : IsRat (x✝³ / x✝²) x✝¹ x✝ := by"
  },
  {
    "full_name": "ENNReal.rpow_lt_top_iff_of_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "lemma ENNReal.rpow_lt_top_iff_of_pos (x : ℝ≥0∞) (y : ℝ) : x ^ y < ⊤ ↔ x < ⊤ := by"
  },
  {
    "full_name": "AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_nonneg_or_nonpos",
    "file_path": "Mathlib/Computability/AkraBazzi/GrowsPolynomially.lean",
    "teorema": "theorem AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_nonneg_or_nonpos (f : ℝ → ℝ) : (∀ᶠ (x : ℝ) in atTop, 0 ≤ f x) ∨ ∀ᶠ (x : ℝ) in atTop, f x ≤ 0 := by"
  },
  {
    "full_name": "IsBoundedBilinearMap.fderivWithin",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean",
    "teorema": "theorem IsBoundedBilinearMap.fderivWithin (E : Type u_2) (F : Type u_3) (G : Type u_4) (b : E × F → G) (h : IsBoundedBilinearMap 𝕜 b) (p : E × F) (u : Set (E × F)) (𝕜 : Type u_1) : fderivWithin 𝕜 b u p = h.deriv p := by"
  },
  {
    "full_name": "Real.Angle.toReal_nonneg_iff_sign_nonneg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "lemma Real.Angle.toReal_nonneg_iff_sign_nonneg (θ : Angle) : 0 ≤ θ.toReal ↔ 0 ≤ θ.sign := by"
  },
  {
    "full_name": "DirectSum.IsInternal.addSubmonoid_iSup_eq_top",
    "file_path": "Mathlib/Algebra/DirectSum/Basic.lean",
    "teorema": "lemma DirectSum.IsInternal.addSubmonoid_iSup_eq_top (A : ι → AddSubmonoid M) (M : Type u_1) (ι : Type v) : iSup A = ⊤ := by"
  },
  {
    "full_name": "ENNReal.log_pow",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/ENNReal.lean",
    "teorema": "lemma ENNReal.log_pow (n : ℕ) (x : ℝ≥0∞) : (x ^ n).log = ↑↑n * x.log := by"
  },
  {
    "full_name": "List.count_attach",
    "file_path": "Mathlib/Data/List/Count.lean",
    "teorema": "theorem List.count_attach (a : { x // x ∈ l }) (l : List α) (x✝ : x✝¹ ∈ l.attach) (x✝¹ : { x // x ∈ l }) (α : Type u_1) : (x✝¹ == a) = true ↔ (↑x✝¹ == ↑a) = true := by"
  },
  {
    "full_name": "LinearMap.range_zero",
    "file_path": "Mathlib/Algebra/Module/Submodule/Range.lean",
    "teorema": "theorem LinearMap.range_zero : range 0 = ⊥ := by"
  },
  {
    "full_name": "MetricSpace.ext",
    "file_path": "Mathlib/Topology/MetricSpace/Basic.lean",
    "teorema": "lemma MetricSpace.ext (m : MetricSpace α) (α : Type u_3) : m = m' := by"
  },
  {
    "full_name": "Set.image2_image_right",
    "file_path": "Mathlib/Data/Set/NAry.lean",
    "teorema": "theorem Set.image2_image_right (a : α) (b : β) (f : α → γ → δ) (g : β → γ) (s : Set α) (t : Set β) (α : Type u_1) (β : Type u_3) (γ : Type u_5) (δ : Type u_7) : image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t := by"
  },
  {
    "full_name": "IsLindelof.elim_nhds_subcover'",
    "file_path": "Mathlib/Topology/Compactness/Lindelof.lean",
    "teorema": "theorem IsLindelof.elim_nhds_subcover' (U : (x : X) → x ∈ s → Set X) (X : Type u) (s : Set X) (t : Set X) : ∃ t, t.Countable ∧ s ⊆ ⋃ x ∈ t, U ↑x ⋯ := by"
  },
  {
    "full_name": "TopCat.GlueData.isOpen_iff",
    "file_path": "Mathlib/Topology/Gluing.lean",
    "teorema": "theorem TopCat.GlueData.isOpen_iff (D : GlueData) (U : Set ↑D.glued) : IsOpen U ↔ ∀ (i : D.J), IsOpen (⇑(D.ι i) ⁻¹' U) := by"
  },
  {
    "full_name": "Erased.out_mk",
    "file_path": "Mathlib/Data/Erased.lean",
    "teorema": "lemma Erased.out_mk (a : α) (α : Sort u_1) : (mk a).out = a := by"
  },
  {
    "full_name": "exists_vector_zero",
    "file_path": "Mathlib/Data/Vector3.lean",
    "teorema": "lemma exists_vector_zero (f : Vector3 α 0 → Prop) (α : Type u_1) : f [] := by"
  },
  {
    "full_name": "negSucc_zsmul",
    "file_path": "Mathlib/Algebra/Group/Defs.lean",
    "teorema": "lemma negSucc_zsmul (G : Type u_2) (a : G) (n : ℕ) : Int.negSucc n • a = -((n + 1) • a) := by"
  },
  {
    "full_name": "CategoryTheory.Functor.Monoidal.tensorHom_app_snd",
    "file_path": "Mathlib/CategoryTheory/ChosenFiniteProducts/FunctorCategory.lean",
    "teorema": "theorem CategoryTheory.Functor.Monoidal.tensorHom_app_snd (C : Type u_2) (F₁ : J ⥤ C) (F₂ : J ⥤ C) (J : Type u_1) (f : F₁ ⟶ F₁') (g : F₂ ⟶ F₂') (j : J) : (f ⊗ g).app j ≫ snd (F₁'.obj j) (F₂'.obj j) = snd (F₁.obj j) (F₂.obj j) ≫ g.app j := by"
  },
  {
    "full_name": "CategoryTheory.Limits.prod.lift_fst_snd",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
    "teorema": "theorem CategoryTheory.Limits.prod.lift_fst_snd (C : Type u) (X : C) (Y : C) : lift fst snd = 𝟙 (X ⨯ Y) := by"
  },
  {
    "full_name": "DFinsupp.toFinsupp_single",
    "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean",
    "teorema": "lemma DFinsupp.toFinsupp_single (M : Type u_3) (i : ι) (m : M) (ι : Type u_1) : (single i m).toFinsupp = Finsupp.single i m := by"
  },
  {
    "full_name": "StrictConcaveOn.lt_slope_of_hasDerivWithinAt_Iio",
    "file_path": "Mathlib/Analysis/Convex/Deriv.lean",
    "teorema": "lemma StrictConcaveOn.lt_slope_of_hasDerivWithinAt_Iio (f : ℝ → ℝ) (x : ℝ) (y : ℝ) : f' < slope f x y := by"
  },
  {
    "full_name": "lt_compl_self",
    "file_path": "Mathlib/Order/Heyting/Basic.lean",
    "teorema": "theorem lt_compl_self (a : α) (α : Type u_2) : a < aᶜ ↔ a = ⊥ := by"
  },
  {
    "full_name": "Ring.image_closure",
    "file_path": "Mathlib/Deprecated/Subring.lean",
    "teorema": "theorem Ring.image_closure (R : Type u) (S : Type u_1) (f : R →+* S) (s : Set R) : ⇑f '' closure s = closure (⇑f '' s) := by"
  },
  {
    "full_name": "CategoryTheory.Subobject.inf_factors",
    "file_path": "Mathlib/CategoryTheory/Subobject/Lattice.lean",
    "teorema": "theorem CategoryTheory.Subobject.inf_factors (A : C) (B : C) (C : Type u₁) (X : Subobject B) (Y : Subobject B) (f : A ⟶ B) : X.Factors f ∧ Y.Factors f → (X ⊓ Y).Factors f := by"
  },
  {
    "full_name": "Nat.even_xor_odd'",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "lemma Nat.even_xor_odd' (n : ℕ) : ∃ k, Xor' (n = 2 * k) (n = 2 * k + 1) := by"
  },
  {
    "full_name": "LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer",
    "file_path": "Mathlib/Algebra/Lie/Engel.lean",
    "teorema": "theorem LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer (K : LieSubalgebra R L) (L : Type u₂) (R : Type u₁) : ∃ K', IsEngelian R ↥K' ∧ K < K' := by"
  },
  {
    "full_name": "SimpleGraph.Walk.length_edges",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "lemma SimpleGraph.Walk.length_edges (G : SimpleGraph V) (V : Type u) (p : G.Walk u v) (u : V) (v : V) : p.edges.length = p.length := by"
  },
  {
    "full_name": "CategoryTheory.Limits.Sigma.map_id",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Products.lean",
    "teorema": "theorem CategoryTheory.Limits.Sigma.map_id (C : Type u) (f : α → C) (α : Type w₂) : (map fun a => 𝟙 (f a)) = 𝟙 (∐ f) := by"
  },
  {
    "full_name": "Polynomial.exists_forall_norm_le",
    "file_path": "Mathlib/Topology/Algebra/Polynomial.lean",
    "teorema": "theorem Polynomial.exists_forall_norm_le (R : Type u_2) (p : R[X]) : ∀ (y : R), ‖eval (p.coeff 0) p‖ ≤ ‖eval y p‖ := by"
  },
  {
    "full_name": "Pi.mulSingle_comm",
    "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean",
    "teorema": "theorem Pi.mulSingle_comm (I : Type u) (i : I) (x : β) (β : Type u_2) : mulSingle i x i' = mulSingle i' x i := by"
  },
  {
    "full_name": "aux_add",
    "file_path": "Mathlib/Analysis/Convex/Strong.lean",
    "teorema": "theorem aux_add (E : Type u_1) (a : ℝ) (b : ℝ) (f : E → ℝ) (m : ℝ) (x : E) (y : E) : a * (f x + m / 2 * ‖x‖ ^ 2) + b * (f y + m / 2 * ‖y‖ ^ 2) - m / 2 * ‖a • x + b • y‖ ^ 2 = a * f x + b * f y + m / 2 * a * b * ‖x - y‖ ^ 2 := by"
  },
  {
    "full_name": "OrderRingHom.cancel_left",
    "file_path": "Mathlib/Algebra/Order/Hom/Ring.lean",
    "teorema": "lemma OrderRingHom.cancel_left (a : α) (f : β →+*o γ) (g₁ : α →+*o β) (g₂ : α →+*o β) (α : Type u_2) (β : Type u_3) (γ : Type u_4) : f (g₁ a) = f (g₂ a) := by"
  },
  {
    "full_name": "LinearIndependent.image_subtype",
    "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean",
    "teorema": "lemma LinearIndependent.image_subtype (M : Type u_4) (R : Type u_2) (f : M →ₗ[R] M') (s : Set M) (x : M) : LinearIndependent R fun (x : ↑(⇑f '' s)) => ↑x := by"
  },
  {
    "full_name": "OrdinalApprox.lfpApprox_mem_fixedPoints_of_eq",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPointApproximants.lean",
    "teorema": "lemma OrdinalApprox.lfpApprox_mem_fixedPoints_of_eq (c : Ordinal.{u}) (f : α →o α) (x : α) (α : Type u) : lfpApprox f x c ∈ fixedPoints ⇑f := by"
  },
  {
    "full_name": "Substring.Valid.prevn",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "theorem Substring.Valid.prevn (m₁ : List Char) : ∀ (n : Nat), x✝.prevn n { byteIdx := utf8Len m₁ } = { byteIdx := utf8Len (List.drop n m₁) } := by"
  },
  {
    "full_name": "Multiset.count_sub",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.count_sub (a : α) (s : Multiset α) (t : Multiset α) (α : Type u_1) : count a (s - t) = count a s - count a t := by"
  },
  {
    "full_name": "List.prod_map_erase",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "lemma List.prod_map_erase (M : Type u_4) (a : α) (b : α) (f : α → M) (l : List α) (α : Type u_2) : f a * (map f ((b :: l).erase a)).prod = (map f (b :: l)).prod := by"
  },
  {
    "full_name": "SzemerediRegularity.initialBound_le_bound",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Regularity/Bound.lean",
    "teorema": "theorem SzemerediRegularity.initialBound_le_bound (l : ℕ) (ε : ℝ) : 0 < 16 ^ stepBound^[⌊4 / ε ^ 5⌋₊] (initialBound ε l) := by"
  },
  {
    "full_name": "Polynomial.coeff_eq_zero_of_lt_natTrailingDegree",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean",
    "teorema": "lemma Polynomial.coeff_eq_zero_of_lt_natTrailingDegree (R : Type u) (n : ℕ) (p : R[X]) : p.coeff n = 0 := by"
  },
  {
    "full_name": "AddCircle.norm_coe_eq_abs_iff",
    "file_path": "Mathlib/Analysis/Normed/Group/AddCircle.lean",
    "teorema": "lemma AddCircle.norm_coe_eq_abs_iff (p : ℝ) (x : ℝ) : ‖↑x‖ = |x| ↔ |x| ≤ |p| / 2 := by"
  },
  {
    "full_name": "Nat.multinomial_insert",
    "file_path": "Mathlib/Data/Nat/Choose/Multinomial.lean",
    "teorema": "lemma Nat.multinomial_insert (a : α) (f : α → ℕ) (s : Finset α) (α : Type u_1) : multinomial (insert a s) f = (f a + ∑ i ∈ s, f i).choose (f a) * multinomial s f := by"
  },
  {
    "full_name": "Prefunctor.mapPath_comp",
    "file_path": "Mathlib/Combinatorics/Quiver/Path.lean",
    "teorema": "lemma Prefunctor.mapPath_comp (F : V ⥤q W) (V : Type u₁) (W : Type u₂) (a : V) (b : V) (c : V) (e : b✝ ⟶ c) (p : Path a b) (q : Path b b✝) : F.mapPath (p.comp (q.cons e)) = (F.mapPath p).comp (F.mapPath (q.cons e)) := by"
  },
  {
    "full_name": "MeasureTheory.predictablePart_zero",
    "file_path": "Mathlib/Probability/Martingale/Centering.lean",
    "teorema": "theorem MeasureTheory.predictablePart_zero (E : Type u_2) (f : ℕ → Ω → E) (m0 : MeasurableSpace Ω) (Ω : Type u_1) (μ : Measure Ω) (ℱ : Filtration ℕ m0) : predictablePart f ℱ μ 0 = 0 := by"
  },
  {
    "full_name": "List.takeWhile_cons_of_pos",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "theorem List.takeWhile_cons_of_pos (l : List α) (p : α → Bool) (x : α) (α : Type u) : takeWhile p (x :: l) = x :: takeWhile p l := by"
  },
  {
    "full_name": "Zspan.repr_ceil_apply",
    "file_path": "Mathlib/Algebra/Module/Zlattice/Basic.lean",
    "teorema": "theorem Zspan.repr_ceil_apply (E : Type u_1) (K : Type u_3) (b : Basis ι K E) (i : ι) (m : E) (ι : Type u_2) : (b.repr ↑(ceil b m)) i = ↑⌈(b.repr m) i⌉ := by"
  },
  {
    "full_name": "SignType.le_antisymm",
    "file_path": "Mathlib/Data/Sign.lean",
    "teorema": "theorem SignType.le_antisymm (a : SignType) (b : SignType) : a = b := by"
  },
  {
    "full_name": "MvQPF.Fix.rec_unique",
    "file_path": "Mathlib/Data/QPF/Multivariate/Constructions/Fix.lean",
    "teorema": "theorem MvQPF.Fix.rec_unique (F : TypeVec.{u} (n + 1) → Type u) (g : F (α ::: β) → β) (h : Fix F α → β) (n : ℕ) (α : TypeVec.{u} n) (β : Type u) : rec g = h := by"
  },
  {
    "full_name": "IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed",
    "file_path": "Mathlib/Topology/Compactness/Compact.lean",
    "teorema": "lemma IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed (X : Type u) (t : ι → Set X) (ι : Type v) : (⋂ i, t i).Nonempty := by"
  },
  {
    "full_name": "Function.IsFixedPt.apply",
    "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean",
    "teorema": "lemma Function.IsFixedPt.apply (f : α → α) (x : α) (α : Type u) : IsFixedPt f (f x) := by"
  },
  {
    "full_name": "MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part",
    "file_path": "Mathlib/MeasureTheory/Integral/Bochner.lean",
    "teorema": "theorem MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part (f : α → ℝ) (α : Type u_1) (μ : Measure α) : ∫ (a : α), f a ∂μ = (∫⁻ (a : α), ENNReal.ofReal (f a) ∂μ).toReal - (∫⁻ (a : α), ENNReal.ofReal (-f a) ∂μ).toReal := by"
  },
  {
    "full_name": "HomogeneousLocalization.val_sub",
    "file_path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean",
    "teorema": "theorem HomogeneousLocalization.val_sub (A : Type u_3) (R : Type u_2) (x : Submonoid A) (y1 : HomogeneousLocalization 𝒜 x) (y2 : HomogeneousLocalization 𝒜 x) (ι : Type u_1) (𝒜 : ι → Submodule R A) : (y1 - y2).val = y1.val - y2.val := by"
  },
  {
    "full_name": "Set.preimage_const_add_Icc",
    "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean",
    "teorema": "lemma Set.preimage_const_add_Icc (a : α) (b : α) (c : α) (α : Type u_1) : (fun x => a + x) ⁻¹' Icc b c = Icc (b - a) (c - a) := by"
  },
  {
    "full_name": "Nat.floor_eq_iff",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem Nat.floor_eq_iff (a : α) (n : ℕ) (α : Type u_2) : ⌊a⌋₊ = n ↔ ↑n ≤ a ∧ a < ↑n + 1 := by"
  },
  {
    "full_name": "List.IsPrefix.ne_nil",
    "file_path": "Mathlib/Data/List/Infix.lean",
    "teorema": "theorem List.IsPrefix.ne_nil (y : List α) (α : Type u_1) : y ≠ [] := by"
  },
  {
    "full_name": "OreLocalization.add_assoc",
    "file_path": "Mathlib/RingTheory/OreLocalization/Basic.lean",
    "teorema": "theorem OreLocalization.add_assoc (R : Type u_1) (S : Submonoid R) (X : Type u_2) (x : OreLocalization S X) (y : OreLocalization S X) (z : OreLocalization S X) : x + y + z = x + (y + z) := by"
  },
  {
    "full_name": "ENNReal.toReal_le_toReal",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "teorema": "lemma ENNReal.toReal_le_toReal (a : ℝ≥0∞) (b : ℝ≥0∞) : a.toReal ≤ b.toReal ↔ a ≤ b := by"
  },
  {
    "full_name": "Subgroup.mem_ofUnits_iff_toUnits_mem",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Units.lean",
    "teorema": "lemma Subgroup.mem_ofUnits_iff_toUnits_mem (G : Type u_2) (H : Subgroup Gˣ) (x : G) : x ∈ H.ofUnits ↔ toUnits x ∈ H := by"
  },
  {
    "full_name": "Equiv.Perm.card_cycleType_eq_zero",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean",
    "teorema": "lemma Equiv.Perm.card_cycleType_eq_zero (α : Type u_1) (σ : Perm α) : card σ.cycleType = 0 ↔ σ = 1 := by"
  },
  {
    "full_name": "Finite.isDomain_to_isField",
    "file_path": "Mathlib/RingTheory/LittleWedderburn.lean",
    "teorema": "theorem Finite.isDomain_to_isField (D : Type u_1) : IsField D := by"
  },
  {
    "full_name": "Filter.iInf_principal_finite",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "theorem Filter.iInf_principal_finite (f : ι → Set α) (s : Set ι) (α : Type u) (ι : Type w) : ⨅ i ∈ s, 𝓟 (f i) = 𝓟 (⋂ i ∈ s, f i) := by"
  },
  {
    "full_name": "MeasureTheory.Lp.ae_tendsto_of_cauchy_snorm'",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "lemma MeasureTheory.Lp.ae_tendsto_of_cauchy_snorm' (E : Type u_2) (f : ℕ → α → E) (α : Type u_1) (μ : Measure α) : ∀ᵐ (x : α) ∂μ, ∃ l, Tendsto (fun n => f n x) atTop (𝓝 l) := by"
  },
  {
    "full_name": "Ideal.isUnit_iff",
    "file_path": "Mathlib/RingTheory/Ideal/Operations.lean",
    "teorema": "theorem Ideal.isUnit_iff (I : Ideal R) (R : Type u) : ⊤ = I * ⊤ := by"
  },
  {
    "full_name": "List.nodup_enum_map_fst",
    "file_path": "Mathlib/Data/List/Sigma.lean",
    "teorema": "theorem List.nodup_enum_map_fst (l : List α) (α : Type u) : (map Prod.fst l.enum).Nodup := by"
  },
  {
    "full_name": "Projectivization.Subspace.sup_span",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Subspace.lean",
    "teorema": "theorem Projectivization.Subspace.sup_span (K : Type u_1) (S : Set (ℙ K V)) (V : Type u_2) (W : Subspace K V) : W ⊔ span S = span (↑W ∪ S) := by"
  },
  {
    "full_name": "FiniteDimensional.finrank_self",
    "file_path": "Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean",
    "teorema": "lemma FiniteDimensional.finrank_self (R : Type u) : Module.rank R R = ↑1 := by"
  },
  {
    "full_name": "Matrix.mem_range_scalar_iff_commute_stdBasisMatrix",
    "file_path": "Mathlib/Data/Matrix/Basis.lean",
    "teorema": "lemma Matrix.mem_range_scalar_iff_commute_stdBasisMatrix (M : Matrix n n α) (n : Type u_3) (α : Type u_5) : M ∈ Set.range ⇑(scalar n) ↔ ∀ (i j : n), i ≠ j → Commute (stdBasisMatrix i j 1) M := by"
  },
  {
    "full_name": "ProbabilityTheory.gaussianReal_map_add_const",
    "file_path": "Mathlib/Probability/Distributions/Gaussian.lean",
    "teorema": "theorem ProbabilityTheory.gaussianReal_map_add_const (v : ℝ≥0) (y : ℝ) (μ : ℝ) : Measure.map (fun x => x + y) (gaussianReal μ v) = gaussianReal (μ + y) v := by"
  },
  {
    "full_name": "LipschitzWith.pow_end",
    "file_path": "Mathlib/Topology/EMetricSpace/Lipschitz.lean",
    "teorema": "theorem LipschitzWith.pow_end (K : ℝ≥0) (f : Function.End α) (α : Type u) : LipschitzWith (K ^ 0) (f ^ 0) := by"
  },
  {
    "full_name": "YoungDiagram.mk_mem_col_iff",
    "file_path": "Mathlib/Combinatorics/Young/YoungDiagram.lean",
    "teorema": "theorem YoungDiagram.mk_mem_col_iff (i : ℕ) (j : ℕ) (μ : YoungDiagram) : (i, j) ∈ μ.col j ↔ (i, j) ∈ μ := by"
  },
  {
    "full_name": "Finset.geomSum_ofColex_strictMono",
    "file_path": "Mathlib/Combinatorics/Colex.lean",
    "teorema": "theorem Finset.geomSum_ofColex_strictMono (n : ℕ) (s : Finset ℕ) : StrictMono fun s => ∑ k ∈ s.ofColex, n ^ k := by"
  },
  {
    "full_name": "CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj",
    "file_path": "Mathlib/CategoryTheory/Shift/InducedShiftSequence.lean",
    "teorema": "theorem CategoryTheory.Functor.ShiftSequence.induced_shiftIso_hom_app_obj (A : Type u_3) (C : Type u_1) (D : Type u_2) (F : D ⥤ A) (G : C ⥤ A) (L : C ⥤ D) (M : Type u_4) (X : C) (a : M) (e : L ⋙ F ≅ G) (n : M) : (F.shiftIso n a a' ha').hom.app (L.obj X) = (F.shift a).map ((L.commShiftIso n).inv.app X) ≫ (e' a).hom.app ((shiftFunctor C n).obj X) ≫ (G.shiftIso n a a' ha').hom.app X ≫ (e' a').inv.app X := by"
  },
  {
    "full_name": "Polynomial.degree_eq_card_roots",
    "file_path": "Mathlib/Algebra/Polynomial/Splits.lean",
    "teorema": "lemma Polynomial.degree_eq_card_roots (K : Type v) (L : Type w) (i : K →+* L) (p : K[X]) : p.degree = ↑(Multiset.card (map i p).roots) := by"
  },
  {
    "full_name": "UniformOnFun.uniformContinuous_toFun",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "lemma UniformOnFun.uniformContinuous_toFun (α : Type u_1) (𝔖 : Set (Set α)) : UniformContinuous ⇑(toFun 𝔖) := by"
  },
  {
    "full_name": "AlgebraicGeometry.ProjectiveSpectrum.Proj.stalkMap_toSpec",
    "file_path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",
    "teorema": "lemma AlgebraicGeometry.ProjectiveSpectrum.Proj.stalkMap_toSpec (A : Type u_2) (R : Type u_1) (f : A) (f_deg : f ∈ 𝒜 m) (hm : 0 < m) (m : ℕ) (x : ↥(pbo f)) (𝒜 : ℕ → Submodule R A) : awayToΓ 𝒜 f ≫ (Proj.restrict ⋯).ΓToStalk x = RingHom.comp ((specStalkEquiv 𝒜 f x f_deg hm).hom ≫ (Proj.stalkIso' 𝒜 ↑x).toCommRingCatIso.inv ≫ (Proj.restrictStalkIso ⋯ x).inv) (algebraMap (A⁰_ f) ↑((Spec.structureSheaf (A⁰_ f)).presheaf.stalk ((toSpec 𝒜 f).val.base x))) := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_tilted",
    "file_path": "Mathlib/MeasureTheory/Measure/Tilted.lean",
    "teorema": "lemma MeasureTheory.lintegral_tilted (f : α → ℝ) (g : α → ℝ≥0∞) (α : Type u_1) (μ : Measure α) : ∫⁻ (x : α), g x ∂μ.tilted f = ∫⁻ (x : α), ENNReal.ofReal (rexp (f x) / ∫ (x : α), rexp (f x) ∂μ) * g x ∂μ := by"
  },
  {
    "full_name": "Nat.choose_two_right",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "teorema": "theorem Nat.choose_two_right (n : ℕ) : n.choose 2 = n * (n - 1) / 2 := by"
  },
  {
    "full_name": "Vector.replicate_succ_to_snoc",
    "file_path": "Mathlib/Data/Vector/Snoc.lean",
    "teorema": "theorem Vector.replicate_succ_to_snoc (n : ℕ) (val : α) (α : Type u_1) : replicate (n + 1) val = (replicate n val).snoc val := by"
  },
  {
    "full_name": "Computable.list_ofFn",
    "file_path": "Mathlib/Computability/Partrec.lean",
    "teorema": "lemma Computable.list_ofFn (x✝ : ∀ (i : Fin 0), Computable (x✝¹ i)) (x✝¹ : Fin 0 → α → σ) (α : Type u_1) (σ : Type u_4) : Computable fun a => List.ofFn fun i => x✝¹ i a := by"
  },
  {
    "full_name": "IsSquare.pow",
    "file_path": "Mathlib/Algebra/Group/Even.lean",
    "teorema": "theorem IsSquare.pow (a : α) (n : ℕ) (α : Type u_2) : IsSquare a → IsSquare (a ^ n) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.coequalizerComparison_map_desc",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean",
    "teorema": "theorem CategoryTheory.Limits.coequalizerComparison_map_desc (C : Type u) (D : Type u₂) (G : C ⥤ D) (X : C) (Y : C) (Z : C) (f : X ⟶ Y) (g : X ⟶ Y) (h : Y ⟶ Z) : G.map f ≫ G.map h = G.map g ≫ G.map h := by"
  },
  {
    "full_name": "sbtw_one_zero_iff",
    "file_path": "Mathlib/Analysis/Convex/Between.lean",
    "teorema": "lemma sbtw_one_zero_iff (R : Type u_1) (x : R) : Sbtw R 1 x 0 ↔ x ∈ Set.Ioo 0 1 := by"
  },
  {
    "full_name": "CompositionSeries.isMaximal_eraseLast_last",
    "file_path": "Mathlib/Order/JordanHolder.lean",
    "teorema": "lemma CompositionSeries.isMaximal_eraseLast_last (X : Type u) (s : CompositionSeries X) : IsMaximal (eraseLast s).last (last s) := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean",
    "teorema": "theorem MeasureTheory.OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top (m : OuterMeasure α) (s : ℕ → Set α) (α : Type u_1) : m (⋃ n, s n) = ⨆ n, m (s n) := by"
  },
  {
    "full_name": "Batteries.RBNode.lowerBound?_le'",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "teorema": "lemma Batteries.RBNode.lowerBound?_le' (cut : α → Ordering) (lb : Option α) (t : RBNode α) (x : α) (α : Type u_1) : lowerBound? cut t lb = some x → cut x ≠ Ordering.lt := by"
  },
  {
    "full_name": "LieAlgebra.IsKilling.traceForm_eq_zero_of_mem_ker_of_mem_span_coroot",
    "file_path": "Mathlib/Algebra/Lie/Weights/Killing.lean",
    "teorema": "theorem LieAlgebra.IsKilling.traceForm_eq_zero_of_mem_ker_of_mem_span_coroot (H : LieSubalgebra K L) (K : Type u_2) (L : Type u_3) (x : ↥H) (y : ↥H) : ((traceForm K (↥H) L) x) y = 0 := by"
  },
  {
    "full_name": "one_le_pow_mul_abs_eval_div",
    "file_path": "Mathlib/Algebra/Polynomial/DenomsClearable.lean",
    "teorema": "lemma one_le_pow_mul_abs_eval_div (K : Type u_1) (a : ℤ) (b : ℤ) (f : ℤ[X]) : 1 ≤ ↑b ^ f.natDegree * |eval (↑a / ↑b) (Polynomial.map (algebraMap ℤ K) f)| := by"
  },
  {
    "full_name": "ENNReal.iSup_add_iSup",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "lemma ENNReal.iSup_add_iSup (a : ℝ≥0∞) (f : ι → ℝ≥0∞) (g : ι → ℝ≥0∞) (ι : Sort u_4) : iSup f + iSup g = ⨆ a, f a + g a := by"
  },
  {
    "full_name": "le_egauge_smul_right",
    "file_path": "Mathlib/Analysis/Convex/EGauge.lean",
    "teorema": "theorem le_egauge_smul_right (E : Type u_3) (c : 𝕜) (s : Set E) (x : E) (𝕜 : Type u_1) : ↑‖c‖₊ * egauge 𝕜 s x ≤ egauge 𝕜 s (c • x) := by"
  },
  {
    "full_name": "subsingleton_or_nontrivial",
    "file_path": "Mathlib/Logic/Nontrivial/Defs.lean",
    "teorema": "lemma subsingleton_or_nontrivial (α : Type u_3) : Subsingleton α ∨ Nontrivial α := by"
  },
  {
    "full_name": "LinearMap.finiteDimensional_of_det_ne_one",
    "file_path": "Mathlib/LinearAlgebra/Determinant.lean",
    "teorema": "theorem LinearMap.finiteDimensional_of_det_ne_one (M : Type u_2) (𝕜 : Type u_7) : FiniteDimensional 𝕜 M := by"
  },
  {
    "full_name": "Int.even_pow",
    "file_path": "Mathlib/Algebra/Group/Int.lean",
    "teorema": "lemma Int.even_pow (m : ℤ) (n : ℕ) : Even (m ^ n) ↔ Even m ∧ n ≠ 0 := by"
  },
  {
    "full_name": "Zsqrtd.le_antisymm",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "theorem Zsqrtd.le_antisymm (a : ℤ√↑d) (b : ℤ√↑d) (d : ℕ) : (-(a - b)).Nonneg := by"
  },
  {
    "full_name": "LinearMap.rank_comp_le_left",
    "file_path": "Mathlib/LinearAlgebra/Dimension/LinearMap.lean",
    "teorema": "lemma LinearMap.rank_comp_le_left (K : Type u) (V : Type v) (f : V' →ₗ[K] V'') (g : V →ₗ[K] V') : (f ∘ₗ g).rank ≤ f.rank := by"
  },
  {
    "full_name": "ENNReal.rpow_eq_top_of_nonneg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "lemma ENNReal.rpow_eq_top_of_nonneg (x : ℝ≥0∞) (y : ℝ) : x ^ y = ⊤ → x = ⊤ := by"
  },
  {
    "full_name": "PiNat.cylinder_eq_cylinder_of_le_firstDiff",
    "file_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
    "teorema": "theorem PiNat.cylinder_eq_cylinder_of_le_firstDiff (E : ℕ → Type u_1) (n : ℕ) (x : (n : ℕ) → E n) (y : (n : ℕ) → E n) : cylinder x n = cylinder y n := by"
  },
  {
    "full_name": "Function.invFun_eq_of_injective_of_rightInverse",
    "file_path": "Mathlib/Logic/Function/Basic.lean",
    "teorema": "theorem Function.invFun_eq_of_injective_of_rightInverse (b : β) (f : α → β) (g : β → α) (α : Sort u_1) (β : Sort u_2) : f (invFun f b) = f (g b) := by"
  },
  {
    "full_name": "MeasureTheory.tendsto_setToFun_filter_of_dominated_convergence",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "theorem MeasureTheory.tendsto_setToFun_filter_of_dominated_convergence (C : ℝ) (E : Type u_2) (F : Type u_3) (T : Set α → E →L[ℝ] F) (f : α → E) (fs : ι → α → E) (hT : DominatedFinMeasAdditive μ T C) (l : Filter ι) (α : Type u_1) (ι : Type u_7) (μ : Measure α) : Tendsto (fun n => setToFun μ T hT (fs n)) l (𝓝 (setToFun μ T hT f)) := by"
  },
  {
    "full_name": "LieAlgebra.zeroRootSubalgebra_normalizer_eq_self",
    "file_path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
    "teorema": "theorem LieAlgebra.zeroRootSubalgebra_normalizer_eq_self (H : LieSubalgebra R L) (L : Type u_2) (R : Type u_1) : (zeroRootSubalgebra R L H).normalizer = zeroRootSubalgebra R L H := by"
  },
  {
    "full_name": "CategoryTheory.PresheafHom.IsSheafFor.exists_app",
    "file_path": "Mathlib/CategoryTheory/Sites/SheafHom.lean",
    "teorema": "theorem CategoryTheory.PresheafHom.IsSheafFor.exists_app : ∃ φ, := by"
  },
  {
    "full_name": "AdjoinRoot.isRoot_root",
    "file_path": "Mathlib/RingTheory/AdjoinRoot.lean",
    "teorema": "lemma AdjoinRoot.isRoot_root (R : Type u) (f : R[X]) : (Polynomial.map (of f) f).IsRoot (root f) := by"
  },
  {
    "full_name": "CauSeq.abv_pos_of_not_limZero",
    "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean",
    "teorema": "theorem CauSeq.abv_pos_of_not_limZero (abv : β → α) (f : CauSeq β abv) (α : Type u_1) (β : Type u_2) : ∃ K > 0, ∃ i, ∀ j ≥ i, K ≤ abv (↑f j) := by"
  },
  {
    "full_name": "MeasureTheory.norm_condexpIndL1_le",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean",
    "teorema": "theorem MeasureTheory.norm_condexpIndL1_le (G : Type u_5) (hm : m ≤ m0) (m : MeasurableSpace α) (m0 : MeasurableSpace α) (s : Set α) (x : G) (α : Type u_1) (μ : Measure α) : ‖condexpIndL1 hm μ s x‖ ≤ (μ s).toReal * ‖x‖ := by"
  },
  {
    "full_name": "Function.Antiperiodic.add",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "theorem Function.Antiperiodic.add (c₁ : α) (c₂ : α) (f : α → β) (α : Type u_1) (β : Type u_2) : Periodic f (c₁ + c₂) := by"
  },
  {
    "full_name": "MulMemClass.mul_mem_add_closure",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
    "teorema": "theorem MulMemClass.mul_mem_add_closure (M : Type u_1) (R : Type u_4) (S : M) (a : R) (b : R) : a * b ∈ AddSubmonoid.closure ↑S := by"
  },
  {
    "full_name": "Polynomial.IsPrimitive.dvd_of_fraction_map_dvd_fraction_map",
    "file_path": "Mathlib/RingTheory/Polynomial/GaussLemma.lean",
    "teorema": "lemma Polynomial.IsPrimitive.dvd_of_fraction_map_dvd_fraction_map (R : Type u_1) (p : R[X]) (q : R[X]) : p ∣ q := by"
  },
  {
    "full_name": "Nat.swap_mem_divisorsAntidiagonal",
    "file_path": "Mathlib/NumberTheory/Divisors.lean",
    "teorema": "lemma Nat.swap_mem_divisorsAntidiagonal (n : ℕ) (x : ℕ × ℕ) : x.swap ∈ n.divisorsAntidiagonal ↔ x ∈ n.divisorsAntidiagonal := by"
  },
  {
    "full_name": "Representation.asAlgebraHom_single",
    "file_path": "Mathlib/RepresentationTheory/Basic.lean",
    "teorema": "lemma Representation.asAlgebraHom_single (G : Type u_2) (V : Type u_3) (g : G) (k : Type u_1) (r : k) (ρ : Representation k G V) : ρ.asAlgebraHom (Finsupp.single g r) = r • ρ g := by"
  },
  {
    "full_name": "Topology.IsLowerSet.monotone_iff_continuous",
    "file_path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
    "teorema": "theorem Topology.IsLowerSet.monotone_iff_continuous (f : α → β) (α : Type u_1) (β : Type u_2) : Monotone f ↔ Continuous f := by"
  },
  {
    "full_name": "DifferentiableWithinAt.mono",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
    "teorema": "lemma DifferentiableWithinAt.mono (E : Type u_2) (F : Type u_3) (f : E → F) (s : Set E) (x : E) (𝕜 : Type u_1) : DifferentiableWithinAt 𝕜 f s x := by"
  },
  {
    "full_name": "Equiv.toFun_inducedStructureEquiv_Symm",
    "file_path": "Mathlib/ModelTheory/Basic.lean",
    "teorema": "theorem Equiv.toFun_inducedStructureEquiv_Symm (M : Type u_1) (N : Type u_2) : N → M := by"
  },
  {
    "full_name": "UpperHalfPlane.dist_coe_le",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean",
    "teorema": "lemma UpperHalfPlane.dist_coe_le (w : ℍ) (z : ℍ) : dist ↑z ↑(w.center (dist z w)) + dist ↑w ↑(w.center (dist z w)) = w.im * (rexp (dist z w) - 1) := by"
  },
  {
    "full_name": "CategoryTheory.Functor.flip_injective",
    "file_path": "Mathlib/CategoryTheory/Functor/Currying.lean",
    "teorema": "lemma CategoryTheory.Functor.flip_injective (B : Type u₁) (C : Type u₂) (D : Type u₃) (F₁ : B ⥤ C ⥤ D) (F₂ : B ⥤ C ⥤ D) : F₁ = F₂ := by"
  },
  {
    "full_name": "ProbabilityTheory.monotone_defaultRatCDF",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/MeasurableStieltjes.lean",
    "teorema": "theorem ProbabilityTheory.monotone_defaultRatCDF : Monotone defaultRatCDF := by"
  },
  {
    "full_name": "Filter.map₂_mk_eq_prod",
    "file_path": "Mathlib/Order/Filter/NAry.lean",
    "teorema": "lemma Filter.map₂_mk_eq_prod (f : Filter α) (g : Filter β) (α : Type u_1) (β : Type u_3) : map₂ Prod.mk f g = f ×ˢ g := by"
  },
  {
    "full_name": "ULower.up_down",
    "file_path": "Mathlib/Logic/Encodable/Basic.lean",
    "teorema": "theorem ULower.up_down (a : α) (α : Type u_1) : (down a).up = a := by"
  },
  {
    "full_name": "MultilinearMap.bound_of_shell_of_norm_map_coord_zero",
    "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean",
    "teorema": "theorem MultilinearMap.bound_of_shell_of_norm_map_coord_zero (C : ℝ) (E : ι → Type wE) (G : Type wG) (f : MultilinearMap 𝕜 E G) (m : (i : ι) → E i) (ι : Type v) (𝕜 : Type u) : ‖f m‖ ≤ C * ∏ i : ι, ‖m i‖ := by"
  },
  {
    "full_name": "contMDiff_inclusion",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Basic.lean",
    "teorema": "theorem contMDiff_inclusion (E : Type u_2) (H : Type u_3) (I : ModelWithCorners 𝕜 E H) (M : Type u_4) (U : Opens M) (V : Opens M) (h : U ≤ V) (n : ℕ∞) (𝕜 : Type u_1) : ContMDiff I I n (inclusion h) := by"
  },
  {
    "full_name": "Nat.prime_three",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "theorem Nat.prime_three : Prime 3 := by"
  },
  {
    "full_name": "LinearMap.trace_tensorProduct'",
    "file_path": "Mathlib/LinearAlgebra/Trace.lean",
    "teorema": "theorem LinearMap.trace_tensorProduct' (M : Type u_2) (N : Type u_3) (R : Type u_1) (f : M →ₗ[R] M) (g : N →ₗ[R] N) : (trace R (M ⊗[R] N)) (TensorProduct.map f g) = (trace R M) f * (trace R N) g := by"
  },
  {
    "full_name": "Set.Ioo_add_bij",
    "file_path": "Mathlib/Algebra/Order/Interval/Set/Monoid.lean",
    "teorema": "lemma Set.Ioo_add_bij (M : Type u_1) (a : M) (b : M) (d : M) : BijOn (fun x => x + d) (Ioo a b) (Ioo (a + d) (b + d)) := by"
  },
  {
    "full_name": "Set.Ioc_union_Ioi'",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Ioc_union_Ioi' (a : α) (b : α) (c : α) (α : Type u_1) : Ioc a b ∪ Ioi c = Ioi (min a c) := by"
  },
  {
    "full_name": "LucasLehmer.ω_pow_formula",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "teorema": "theorem LucasLehmer.ω_pow_formula : ∃ k, ω ^ 2 ^ (p' + 1) = ↑k * ↑(mersenne (p' + 2)) * ω ^ 2 ^ p' - 1 := by"
  },
  {
    "full_name": "MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "lemma MeasureTheory.Measure.MeasurableSet.nullMeasurableSet_subtype_coe (s : Set α) (t : Set ↑s) (α : Type u_2) (μ : Measure α) : NullMeasurableSet (Subtype.val '' t) μ := by"
  },
  {
    "full_name": "MeasureTheory.Measure.integral_comp_mul_left",
    "file_path": "Mathlib/MeasureTheory/Measure/Haar/NormedSpace.lean",
    "teorema": "lemma MeasureTheory.Measure.integral_comp_mul_left (F : Type u_2) (a : ℝ) (g : ℝ → F) : ∫ (x : ℝ), g (a * x) = |a⁻¹| • ∫ (y : ℝ), g y := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.Point.toAffine_of_equiv",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.Point.toAffine_of_equiv (F : Type v) (P : Fin 3 → F) (Q : Fin 3 → F) (W : Jacobian F) : toAffine W P = toAffine W Q := by"
  },
  {
    "full_name": "Finsupp.sigma_support",
    "file_path": "Mathlib/Data/Finsupp/Basic.lean",
    "teorema": "lemma Finsupp.sigma_support (M : Type u_5) (l : (i : ι) × αs i →₀ M) (αs : ι → Type u_13) (ι : Type u_4) : l.support = l.splitSupport.sigma fun i => (l.split i).support := by"
  },
  {
    "full_name": "List.Nat.mem_antidiagonalTuple",
    "file_path": "Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean",
    "teorema": "theorem List.Nat.mem_antidiagonalTuple (n : ℕ) : Fin.elim0 ∈ antidiagonalTuple 0 n ↔ ∑ i : Fin 0, i.elim0 = n := by"
  },
  {
    "full_name": "MeasureTheory.tendsto_condexp_unique",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean",
    "teorema": "theorem MeasureTheory.tendsto_condexp_unique (F : Type u_2) (f : α → F') (g : α → F') (m : MeasurableSpace α) (α : Type u_1) (μ : Measure α) : μ[f|m] =ᶠ[ae μ] μ[g|m] := by"
  },
  {
    "full_name": "RingHom.codomain_trivial_iff_map_one_eq_zero",
    "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
    "teorema": "theorem RingHom.codomain_trivial_iff_map_one_eq_zero (f : α →+* β) (α : Type u_2) (β : Type u_3) : 0 = 1 ↔ f 1 = 0 := by"
  },
  {
    "full_name": "cfc_nonpos",
    "file_path": "Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean",
    "teorema": "theorem cfc_nonpos (A : Type u_2) (R : Type u_1) (a : A) (f : R → R) : cfc f a ≤ 0 := by"
  },
  {
    "full_name": "RelEmbedding.exists_not_acc_lt_of_not_acc",
    "file_path": "Mathlib/Order/OrderIsoNat.lean",
    "teorema": "lemma RelEmbedding.exists_not_acc_lt_of_not_acc (a : α) (r : α → α → Prop) (α : Type u_1) : ∃ b, ¬Acc r b ∧ r b a := by"
  },
  {
    "full_name": "Set.image_prod_mk_subset_prod_left",
    "file_path": "Mathlib/Data/Set/Prod.lean",
    "teorema": "lemma Set.image_prod_mk_subset_prod_left (a : α) (b : β) (s : Set α) (t : Set β) (α : Type u_1) (β : Type u_2) : (fun a => (a, b)) '' s ⊆ s ×ˢ t := by"
  },
  {
    "full_name": "PMF.map_apply",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Constructions.lean",
    "teorema": "lemma PMF.map_apply (b : β) (f : α → β) (p : PMF α) (α : Type u_1) (β : Type u_2) : (map f p) b = ∑' (a : α), if b = f a then p a else 0 := by"
  },
  {
    "full_name": "LieHom.mem_idealRange",
    "file_path": "Mathlib/Algebra/Lie/Submodule.lean",
    "teorema": "theorem LieHom.mem_idealRange (L : Type v) (R : Type u) (f : L →ₗ⁅R⁆ L') (x : L) : f x ∈ f.idealRange := by"
  },
  {
    "full_name": "SimpleGraph.map_singletonSubgraph",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean",
    "teorema": "lemma SimpleGraph.map_singletonSubgraph (G : SimpleGraph V) (V : Type u) (f : G →g G') (v : V) : Subgraph.map f (G.singletonSubgraph v) = G'.singletonSubgraph (f v) := by"
  },
  {
    "full_name": "Int.even_iff_not_odd",
    "file_path": "Mathlib/Algebra/Ring/Int.lean",
    "teorema": "theorem Int.even_iff_not_odd (n : ℤ) : Even n ↔ ¬Odd n := by"
  },
  {
    "full_name": "vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "theorem vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan (P : Type u_3) (V : Type u_2) (k : Type u_1) (p : P) (s : Set P) (v : V) : v +ᵥ p ∈ spanPoints k s := by"
  },
  {
    "full_name": "HasFDerivWithinAt.mul",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean",
    "teorema": "lemma HasFDerivWithinAt.mul (E : Type u_2) (c : E → 𝔸') (d : E → 𝔸') (s : Set E) (x : E) (𝔸 : Type u_6) : HasFDerivWithinAt (fun y => c y * d y) (c x • d' + d x • c') s x := by"
  },
  {
    "full_name": "Polynomial.mirror_leadingCoeff",
    "file_path": "Mathlib/Algebra/Polynomial/Mirror.lean",
    "teorema": "lemma Polynomial.mirror_leadingCoeff (R : Type u_1) (p : R[X]) : p.mirror.leadingCoeff = p.trailingCoeff := by"
  },
  {
    "full_name": "AddCommGrp.asHom_injective",
    "file_path": "Mathlib/Algebra/Category/Grp/Basic.lean",
    "teorema": "theorem AddCommGrp.asHom_injective (G : AddCommGrp) (h : ↑G) (k : ↑G) : h = k := by"
  },
  {
    "full_name": "bernoulli'_one",
    "file_path": "Mathlib/NumberTheory/Bernoulli.lean",
    "teorema": "lemma bernoulli'_one : bernoulli' 1 = 1 / 2 := by"
  },
  {
    "full_name": "CategoryTheory.induct_on_objects",
    "file_path": "Mathlib/CategoryTheory/IsConnected.lean",
    "teorema": "lemma CategoryTheory.induct_on_objects (J : Type u₁) (j : J) (p : Set J) : j ∈ p := by"
  },
  {
    "full_name": "CategoryTheory.MonoidalCategory.leftUnitor_inv_tensor_id",
    "file_path": "Mathlib/CategoryTheory/Monoidal/CoherenceLemmas.lean",
    "teorema": "theorem CategoryTheory.MonoidalCategory.leftUnitor_inv_tensor_id (C : Type u_1) (X : C) (Y : C) : (λ_ X).inv ⊗ 𝟙 Y = (λ_ (X ⊗ Y)).inv ≫ (α_ (𝟙_ C) X Y).inv := by"
  },
  {
    "full_name": "DFinsupp.neLocus_zero_right",
    "file_path": "Mathlib/Data/DFinsupp/NeLocus.lean",
    "teorema": "lemma DFinsupp.neLocus_zero_right (N : α → Type u_2) (f : Π₀ (a : α), N a) (α : Type u_1) : f.neLocus 0 = f.support := by"
  },
  {
    "full_name": "Ideal.le_toIdeal_homogeneousHull",
    "file_path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean",
    "teorema": "lemma Ideal.le_toIdeal_homogeneousHull (A : Type u_4) (I : Ideal A) (ι : Type u_1) (σ : Type u_2) (𝒜 : ι → σ) : I ≤ (homogeneousHull 𝒜 I).toIdeal := by"
  },
  {
    "full_name": "Fintype.prod_boole",
    "file_path": "Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean",
    "teorema": "lemma Fintype.prod_boole (p : ι → Prop) (ι : Type u_1) : (∏ i : ι, if p i then 1 else 0) = if ∀ (i : ι), p i then 1 else 0 := by"
  },
  {
    "full_name": "LinearMap.range_rangeRestrict",
    "file_path": "Mathlib/Algebra/Module/Submodule/Range.lean",
    "teorema": "theorem LinearMap.range_rangeRestrict (M : Type u_6) (M₂ : Type u_7) (R : Type u_1) (R₂ : Type u_2) (f : M →ₛₗ[τ₁₂] M₂) (τ₁₂ : R →+* R₂) : range f.rangeRestrict = ⊤ := by"
  },
  {
    "full_name": "Orientation.oangle_zero_right",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean",
    "teorema": "lemma Orientation.oangle_zero_right (V : Type u_1) (o : Orientation ℝ V (Fin 2)) (x : V) : o.oangle x 0 = 0 := by"
  },
  {
    "full_name": "List.get_eq_iff",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "theorem List.get_eq_iff (l : List α✝) (n : Fin l.length) (x : α✝) : l.get n = x ↔ l.get? ↑n = some x := by"
  },
  {
    "full_name": "Matrix.mulVec_one",
    "file_path": "Mathlib/Data/Matrix/Basic.lean",
    "teorema": "theorem Matrix.mulVec_one (A : Matrix m n α) (m : Type u_2) (n : Type u_3) (α : Type v) : A *ᵥ 1 = fun i => ∑ j : n, A i j := by"
  },
  {
    "full_name": "Set.le_edist_of_le_infsep",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "teorema": "theorem Set.le_edist_of_le_infsep (d : ℝ) (x : α) (y : α) (α : Type u_1) : d ≤ dist x y := by"
  },
  {
    "full_name": "WeierstrassCurve.Φ_one",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "teorema": "lemma WeierstrassCurve.Φ_one (R : Type r) (W : WeierstrassCurve R) : W.Φ 1 = X := by"
  },
  {
    "full_name": "FiniteField.pow_card",
    "file_path": "Mathlib/FieldTheory/Finite/Basic.lean",
    "teorema": "theorem FiniteField.pow_card (K : Type u_1) (a : K) : a ^ q = a := by"
  },
  {
    "full_name": "Zsqrtd.nonneg_mul",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "theorem Zsqrtd.nonneg_mul (w : ℕ) (x : ℕ) (y : ℕ) (z : ℕ) : ({ re := -↑x, im := ↑y } * { re := ↑z, im := ↑w }).Nonneg := by"
  },
  {
    "full_name": "equicontinuousAt_iff_range",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "theorem equicontinuousAt_iff_range (F : ι → X → α) (X : Type u_3) (x₀ : X) (α : Type u_7) (ι : Type u_1) : EquicontinuousAt F x₀ ↔ EquicontinuousAt Subtype.val x₀ := by"
  },
  {
    "full_name": "Finsupp.iInf_ker_lapply_le_bot",
    "file_path": "Mathlib/LinearAlgebra/Finsupp.lean",
    "teorema": "theorem Finsupp.iInf_ker_lapply_le_bot : ⨅ a, ker (lapply a) ≤ ⊥ := by"
  },
  {
    "full_name": "Path.truncate_self",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "teorema": "theorem Path.truncate_self (X : Type u_1) (a : X) (b : X) (t : ℝ) (γ : Path a b) : γ.extend (min t t) = γ.extend t := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.map_addX",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.map_addX (F : Type v) (P : Fin 3 → R) (Q : Fin 3 → R) (R : Type u) (S : Type u_1) (W : Jacobian F) (f : R →+* S) : addX (map W' f) (⇑f ∘ P) (⇑f ∘ Q) = f (W'.addX P Q) := by"
  },
  {
    "full_name": "Set.ncard_le_one_iff",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "lemma Set.ncard_le_one_iff (s : Set α) (α : Type u_1) : s.ncard ≤ 1 ↔ ∀ {a b : α}, a ∈ s → b ∈ s → a = b := by"
  },
  {
    "full_name": "NNReal.tendsto_rpow_atTop",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean",
    "teorema": "theorem NNReal.tendsto_rpow_atTop (y : ℝ) : Tendsto (fun x => x ^ y) atTop atTop := by"
  },
  {
    "full_name": "pcontinuous_iff'",
    "file_path": "Mathlib/Topology/Partial.lean",
    "teorema": "theorem pcontinuous_iff' (X : Type u_1) (Y : Type u_2) (f : X →. Y) : PContinuous f ↔ ∀ {x : X} {y : Y}, y ∈ f x → PTendsto' f (𝓝 x) (𝓝 y) := by"
  },
  {
    "full_name": "Matrix.det_nonsing_inv_mul_det",
    "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
    "teorema": "theorem Matrix.det_nonsing_inv_mul_det (A : Matrix n n α) (n : Type u') (α : Type v) : A⁻¹.det * A.det = 1 := by"
  },
  {
    "full_name": "Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "lemma Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous (f : β → α) (α : Type u_7) (β : Type u_9) : UniformContinuous f := by"
  },
  {
    "full_name": "List.range_eq_range'",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "theorem List.range_eq_range' (n : Nat) : range' 0 (0 + n) = range' 0 n := by"
  },
  {
    "full_name": "List.mem_mem_ranges_iff_lt_natSum",
    "file_path": "Mathlib/Data/List/Range.lean",
    "teorema": "lemma List.mem_mem_ranges_iff_lt_natSum (l : List ℕ) (n : ℕ) : (∃ s ∈ l.ranges, n ∈ s) ↔ n < Nat.sum l := by"
  },
  {
    "full_name": "Ordinal.fp_family_unbounded",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "teorema": "lemma Ordinal.fp_family_unbounded (a : Ordinal.{max u v}) (f : ι → Ordinal.{max u v} → Ordinal.{max u v}) (s : Set Ordinal.{max u v}) (ι : Type u) : nfpFamily f a ∈ s := by"
  },
  {
    "full_name": "Field.primitive_element_inf_aux_of_finite_intermediateField",
    "file_path": "Mathlib/FieldTheory/PrimitiveElement.lean",
    "teorema": "lemma Field.primitive_element_inf_aux_of_finite_intermediateField (E : Type u_2) (F : Type u_1) (α : E) (β : E) : ∃ γ, F⟮α, β⟯ = F⟮γ⟯ := by"
  },
  {
    "full_name": "antilipschitzWith_lineMap",
    "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean",
    "teorema": "theorem antilipschitzWith_lineMap (Q : Type u_5) (c₁ : 𝕜) (c₂ : 𝕜) (p₁ : Q) (p₂ : Q) (𝕜 : Type u_6) : dist c₁ c₂ ≤ ↑(nndist p₁ p₂)⁻¹ * dist ((lineMap p₁ p₂) c₁) ((lineMap p₁ p₂) c₂) := by"
  },
  {
    "full_name": "exists_setIndependent_isCompl_sSup_atoms",
    "file_path": "Mathlib/Order/CompactlyGenerated/Basic.lean",
    "teorema": "theorem exists_setIndependent_isCompl_sSup_atoms (b : α) (α : Type u_2) : ∃ s, CompleteLattice.SetIndependent s ∧ IsCompl b (sSup s) ∧ ∀ ⦃a : α⦄, a ∈ s → IsAtom a := by"
  },
  {
    "full_name": "sub_div_sub_smul_slope_add_sub_div_sub_smul_slope",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean",
    "teorema": "theorem sub_div_sub_smul_slope_add_sub_div_sub_smul_slope (PE : Type u_3) (a : k) (b : k) (c : k) (f : k → PE) (k : Type u_1) : ((b - a) / (c - a)) • slope f a b + ((c - b) / (c - a)) • slope f b c = slope f a c := by"
  },
  {
    "full_name": "Besicovitch.SatelliteConfig.exists_normalized_aux1",
    "file_path": "Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean",
    "teorema": "theorem Besicovitch.SatelliteConfig.exists_normalized_aux1 (E : Type u_1) (N : ℕ) (a : SatelliteConfig E N τ) (i : Fin N.succ) (j : Fin N.succ) (δ : ℝ) (τ : ℝ) : 1 - δ ≤ ‖a.c i - a.c j‖ := by"
  },
  {
    "full_name": "rightCoset_mem_rightCoset",
    "file_path": "Mathlib/GroupTheory/Coset.lean",
    "teorema": "lemma rightCoset_mem_rightCoset (a : α) (b : α) (s : Subgroup α) (α : Type u_1) : b ∈ op a • ↑s ↔ b ∈ ↑s := by"
  },
  {
    "full_name": "EuclideanGeometry.orthogonalProjection_mem_subspace_eq_self",
    "file_path": "Mathlib/Geometry/Euclidean/Basic.lean",
    "teorema": "theorem EuclideanGeometry.orthogonalProjection_mem_subspace_eq_self (P : Type u_2) (p : ↥s) (s : AffineSubspace ℝ P) : (orthogonalProjection s) ↑p = p := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.add_measure",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.Integrable.add_measure (f : α → β) (α : Type u_1) (β : Type u_2) (μ : Measure α) (ν : Measure α) : Integrable f (μ + ν) := by"
  },
  {
    "full_name": "Function.update_idem",
    "file_path": "Mathlib/Logic/Function/Basic.lean",
    "teorema": "theorem Function.update_idem (a : α) (f : (a : α) → β a) (v : β a) (w : β a) (α : Sort u_2) (β : α → Sort u_1) : update (update f a v) a w = update f a w := by"
  },
  {
    "full_name": "Ordinal.one_lt_omega",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "lemma Ordinal.one_lt_omega : 1 < ω := by"
  },
  {
    "full_name": "CategoryTheory.FintypeCat.Action.pretransitive_of_isConnected",
    "file_path": "Mathlib/CategoryTheory/Galois/Examples.lean",
    "teorema": "lemma CategoryTheory.FintypeCat.Action.pretransitive_of_isConnected (G : Type u) (X : Action FintypeCat (MonCat.of G)) (x : ↑X.V) (y : ↑X.V) : ∃ g, g • x = y := by"
  },
  {
    "full_name": "MeasureTheory.addContent_union_le",
    "file_path": "Mathlib/MeasureTheory/Measure/AddContent.lean",
    "teorema": "theorem MeasureTheory.addContent_union_le (C : Set (Set α)) (m : AddContent C) (s : Set α) (t : Set α) (α : Type u_1) : m (s ∪ t) ≤ m s + m t := by"
  },
  {
    "full_name": "Set.countable_pi",
    "file_path": "Mathlib/Data/Set/Countable.lean",
    "teorema": "theorem Set.countable_pi (s : (a : α) → Set (π a)) (α : Type u) (π : α → Type u_1) : {f | ∀ (a : α), f a ∈ s a}.Countable := by"
  },
  {
    "full_name": "LieAlgebra.IsSemisimple.isSimple_of_isAtom",
    "file_path": "Mathlib/Algebra/Lie/Semisimple/Basic.lean",
    "teorema": "lemma LieAlgebra.IsSemisimple.isSimple_of_isAtom (I : LieIdeal R L) (L : Type u_2) (R : Type u_1) : ∀ (I_1 : LieIdeal R ↥↑I), I_1 = ⊥ ∨ I_1 = ⊤ := by"
  },
  {
    "full_name": "Projectivization.Subspace.span_eq_sInf",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Subspace.lean",
    "teorema": "lemma Projectivization.Subspace.span_eq_sInf (K : Type u_1) (S : Set (ℙ K V)) (V : Type u_2) : span S = sInf {W | S ⊆ ↑W} := by"
  },
  {
    "full_name": "isConformalMap_complex_linear",
    "file_path": "Mathlib/Analysis/Complex/Conformal.lean",
    "teorema": "theorem isConformalMap_complex_linear (E : Type u_1) (map : ℂ →L[ℂ] E) : IsConformalMap (restrictScalars ℝ map) := by"
  },
  {
    "full_name": "LucasLehmer.sMod_lt",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "teorema": "lemma LucasLehmer.sMod_lt (i : ℕ) (p : ℕ) : sMod p i < 2 ^ p - 1 := by"
  },
  {
    "full_name": "ZFSet.toSet_sdiff",
    "file_path": "Mathlib/SetTheory/ZFC/Basic.lean",
    "teorema": "theorem ZFSet.toSet_sdiff (x : ZFSet) (y : ZFSet) : (x \\ y).toSet = x.toSet \\ y.toSet := by"
  },
  {
    "full_name": "ContinuousLinearMap.zero_comp",
    "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean",
    "teorema": "lemma ContinuousLinearMap.zero_comp (M₁ : Type u_4) (M₂ : Type u_6) (R₁ : Type u_1) (R₂ : Type u_2) (f : M₁ →SL[σ₁₂] M₂) (σ₁₂ : R₁ →+* R₂) : comp 0 f = 0 := by"
  },
  {
    "full_name": "Filter.eventually_prod_self_iff",
    "file_path": "Mathlib/Order/Filter/Bases.lean",
    "teorema": "theorem Filter.eventually_prod_self_iff (la : Filter α) (r : α → α → Prop) (α : Type u_1) : (∃ t ∈ la, t ×ˢ t ⊆ {x | (fun x => r x.1 x.2) x}) ↔ ∃ t ∈ la, ∀ x ∈ t, ∀ y ∈ t, r x y := by"
  },
  {
    "full_name": "PiTensorProduct.nonempty_lifts",
    "file_path": "Mathlib/LinearAlgebra/PiTensorProduct.lean",
    "teorema": "theorem PiTensorProduct.nonempty_lifts (R : Type u_4) (s : ι → Type u_7) (x : ⨂[R] (i : ι), s i) (ι : Type u_1) : x.lifts.Nonempty := by"
  },
  {
    "full_name": "Complex.tan_mul_I",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.tan_mul_I (x : ℂ) : tan (x * I) = tanh x * I := by"
  },
  {
    "full_name": "IsBezout.gcd_dvd_left",
    "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean",
    "teorema": "lemma IsBezout.gcd_dvd_left (R : Type u) (x : R) (y : R) : x ∈ {x, y} := by"
  },
  {
    "full_name": "Matrix.sub_mulVec",
    "file_path": "Mathlib/Data/Matrix/Basic.lean",
    "teorema": "lemma Matrix.sub_mulVec (A : Matrix m n α) (B : Matrix m n α) (m : Type u_2) (n : Type u_3) (x : n → α) (α : Type v) : (A - B) *ᵥ x = A *ᵥ x - B *ᵥ x := by"
  },
  {
    "full_name": "IsSelfAdjoint.neg_algebraMap_norm_le_self",
    "file_path": "Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Order.lean",
    "teorema": "theorem IsSelfAdjoint.neg_algebraMap_norm_le_self (A : Type u_1) (a : A) : -(algebraMap ℝ A) ‖a‖ ≤ a := by"
  },
  {
    "full_name": "MeasureTheory.Measure.compProd_apply_prod",
    "file_path": "Mathlib/Probability/Kernel/MeasureCompProd.lean",
    "teorema": "theorem MeasureTheory.Measure.compProd_apply_prod (s : Set α) (t : Set β) (α : Type u_1) (β : Type u_2) (κ : ↥(kernel α β)) (μ : Measure α) : (μ ⊗ₘ κ) (s ×ˢ t) = ∫⁻ (a : α) in s, (κ a) t ∂μ := by"
  },
  {
    "full_name": "Rat.neg_normalize",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.neg_normalize (d : Nat) (n : Int) (z : d ≠ 0) : -normalize n d z = normalize (-n) d z := by"
  },
  {
    "full_name": "QPF.recF_eq_of_Wequiv",
    "file_path": "Mathlib/Data/QPF/Univariate/Basic.lean",
    "teorema": "theorem QPF.recF_eq_of_Wequiv (F : Type u → Type u) (u : F α → α) (x : (P F).W) (y : (P F).W) (α : Type u) : Wequiv x y → recF u x = recF u y := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.id_homMap",
    "file_path": "Mathlib/CategoryTheory/Localization/HomEquiv.lean",
    "teorema": "theorem CategoryTheory.LocalizerMorphism.id_homMap (C₁ : Type u_2) (D₁ : Type u_5) (L₁ : C₁ ⥤ D₁) (W₁ : MorphismProperty C₁) (X : C₁) (Y : C₁) (f : L₁.obj X ⟶ L₁.obj Y) : (id W₁).homMap L₁ L₁ f = f := by"
  },
  {
    "full_name": "Complex.tsum_exp_neg_mul_int_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean",
    "teorema": "theorem Complex.tsum_exp_neg_mul_int_sq (a : ℂ) : ∑' (n : ℤ), cexp (-↑π * a * ↑n ^ 2) = 1 / a ^ (1 / 2) * ∑' (n : ℤ), cexp (-↑π / a * ↑n ^ 2) := by"
  },
  {
    "full_name": "Nat.gcd_add_mul_right_right",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "teorema": "theorem Nat.gcd_add_mul_right_right (k : ℕ) (m : ℕ) (n : ℕ) : m.gcd (n + k * m) = m.gcd n := by"
  },
  {
    "full_name": "affineSpan_singleton_union_vadd_eq_top_of_span_eq_top",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "lemma affineSpan_singleton_union_vadd_eq_top_of_span_eq_top (P : Type u_3) (V : Type u_2) (k : Type u_1) (p : P) (s : Set V) : affineSpan k ({p} ∪ (fun v => v +ᵥ p) '' s) = ⊤ := by"
  },
  {
    "full_name": "MeasureTheory.pdf.lintegral_eq_measure_univ",
    "file_path": "Mathlib/Probability/Density.lean",
    "teorema": "theorem MeasureTheory.pdf.lintegral_eq_measure_univ (E : Type u_2) (X : Ω → E) (Ω : Type u_1) (μ : Measure E) (ℙ : Measure Ω) : ∫⁻ (x : E), pdf X ℙ μ x ∂μ = ℙ Set.univ := by"
  },
  {
    "full_name": "CochainComplex.HomComplex.Cochain.id_comp",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean",
    "teorema": "lemma CochainComplex.HomComplex.Cochain.id_comp (C : Type u) (F : CochainComplex C ℤ) (G : CochainComplex C ℤ) (n : ℤ) (z₂ : Cochain F G n) : (ofHom (𝟙 F)).comp z₂ ⋯ = z₂ := by"
  },
  {
    "full_name": "Finset.val_eq_singleton_iff",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "theorem Finset.val_eq_singleton_iff (a : α) (s : Finset α) (α : Type u_1) : s.val = {a} ↔ s = {a} := by"
  },
  {
    "full_name": "BooleanAlgebra.le_iff_atom_le_imp",
    "file_path": "Mathlib/Order/Atoms.lean",
    "teorema": "lemma BooleanAlgebra.le_iff_atom_le_imp (x : α) (y : α) (α : Type u_4) : x ≤ y := by"
  },
  {
    "full_name": "Zsqrtd.dmuld",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "lemma Zsqrtd.dmuld (d : ℤ) : sqrtd * sqrtd = ↑d := by"
  },
  {
    "full_name": "round_neg_two_inv",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem round_neg_two_inv : round (-2⁻¹) = 0 := by"
  },
  {
    "full_name": "TensorProduct.toDirectLimit_tmul_of",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/DirectLimit.lean",
    "teorema": "lemma TensorProduct.toDirectLimit_tmul_of (G : ι → Type u_3) (M : Type u_4) (R : Type u_1) (f : (i j : ι) → i ≤ j → G i →ₗ[R] G j) (g : G i) (i : ι) (m : M) (ι : Type u_2) : (toDirectLimit f M) ((of R ι G f i) g ⊗ₜ[R] m) = (of R ι (fun x => G x ⊗[R] M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (g ⊗ₜ[R] m) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.ι_colimitConstInitial_hom",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean",
    "teorema": "theorem CategoryTheory.Limits.ι_colimitConstInitial_hom (C : Type u_2) (J : Type u_1) (j : J) : colimit.ι ((Functor.const J).obj (⊥_ C)) j ≫ colimitConstInitial.hom = initial.to (⊥_ C) := by"
  },
  {
    "full_name": "Submodule.map_op_mul",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "theorem Submodule.map_op_mul (A : Type v) (M : Submodule R A) (N : Submodule R A) (R : Type u) : map (↑(opLinearEquiv R)) (M * N) = map (↑(opLinearEquiv R)) N * map (↑(opLinearEquiv R)) M := by"
  },
  {
    "full_name": "CategoryTheory.Limits.biprod.isoProd_hom",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean",
    "teorema": "theorem CategoryTheory.Limits.biprod.isoProd_hom (C : Type u) (X : C) (Y : C) : (isoProd X Y).hom = prod.lift fst snd := by"
  },
  {
    "full_name": "CategoryTheory.Discrete.natIso_app",
    "file_path": "Mathlib/CategoryTheory/DiscreteCategory.lean",
    "teorema": "lemma CategoryTheory.Discrete.natIso_app (C : Type u₂) (F : Discrete I ⥤ C) (G : Discrete I ⥤ C) (I : Type u₁) (f : (i : Discrete I) → F.obj i ≅ G.obj i) (i : Discrete I) : (natIso f).app i = f i := by"
  },
  {
    "full_name": "Part.inv_mem_inv",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.inv_mem_inv (a : Part α) (ma : α) (α : Type u_1) : ma⁻¹ ∈ a⁻¹ := by"
  },
  {
    "full_name": "Int.fract_sub_nat",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Int.fract_sub_nat (a : α) (n : ℕ) (α : Type u_2) : fract (a - ↑n) = fract a := by"
  },
  {
    "full_name": "AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.lift_uniq",
    "file_path": "Mathlib/Geometry/RingedSpace/OpenImmersion.lean",
    "teorema": "theorem AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.lift_uniq (C : Type u) (H : Set.range ⇑g.base ⊆ Set.range ⇑f.base) (X : PresheafedSpace C) (Y : PresheafedSpace C) (Z : PresheafedSpace C) (f : X ⟶ Z) (g : Y ⟶ Z) (l : Y ⟶ X) : l = lift f g H := by"
  },
  {
    "full_name": "Filter.Tendsto.of_tendsto_comp",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.Tendsto.of_tendsto_comp (a : Filter α) (b : Filter β) (f : α → β) (α : Type u) (β : Type v) : Tendsto f a b := by"
  },
  {
    "full_name": "Polynomial.eval_comp",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "lemma Polynomial.eval_comp (R : Type u) (p : R[X]) (q : R[X]) (x : R) : eval x (p.comp q) = eval (eval x q) p := by"
  },
  {
    "full_name": "LinearMap.adjoint_adjoint",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Adjoint.lean",
    "teorema": "lemma LinearMap.adjoint_adjoint (A : E →ₗ[𝕜] F) (E : Type u_2) (F : Type u_3) (𝕜 : Type u_1) : adjoint (adjoint A) = A := by"
  },
  {
    "full_name": "contDiff_top_iff_deriv",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "theorem contDiff_top_iff_deriv (F : Type uF) (f₂ : 𝕜 → F) (𝕜 : Type u_1) : ContDiff 𝕜 ⊤ f₂ ↔ Differentiable 𝕜 f₂ ∧ ContDiff 𝕜 ⊤ (deriv f₂) := by"
  },
  {
    "full_name": "WeierstrassCurve.ΨSq_odd",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "teorema": "theorem WeierstrassCurve.ΨSq_odd (R : Type r) (W : WeierstrassCurve R) (m : ℕ) : W.ΨSq (2 * (↑m + 2) + 1) = ((W.preΨ' (m + 4) * W.preΨ' (m + 2) ^ 3 * if Even m then W.Ψ₂Sq ^ 2 else 1) - W.preΨ' (m + 1) * W.preΨ' (m + 3) ^ 3 * if Even m then 1 else W.Ψ₂Sq ^ 2) ^ 2 := by"
  },
  {
    "full_name": "ProbabilityTheory.IdentDistrib.evariance_eq",
    "file_path": "Mathlib/Probability/IdentDistrib.lean",
    "teorema": "theorem ProbabilityTheory.IdentDistrib.evariance_eq (f : α → ℝ) (g : β → ℝ) (α : Type u_1) (β : Type u_2) (μ : Measure α) (ν : Measure β) : evariance f μ = evariance g ν := by"
  },
  {
    "full_name": "Basis.sumCoords_reindex",
    "file_path": "Mathlib/LinearAlgebra/Basis.lean",
    "teorema": "theorem Basis.sumCoords_reindex (M : Type u_6) (R : Type u_3) (b : Basis ι R M) (e : ι ≃ ι') (ι : Type u_1) : (b.reindex e).sumCoords = b.sumCoords := by"
  },
  {
    "full_name": "Monoid.exponent_dvd",
    "file_path": "Mathlib/GroupTheory/Exponent.lean",
    "teorema": "theorem Monoid.exponent_dvd (G : Type u) (n : ℕ) : exponent G ∣ n ↔ ∀ (g : G), orderOf g ∣ n := by"
  },
  {
    "full_name": "JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup",
    "file_path": "Mathlib/Order/JordanHolder.lean",
    "teorema": "theorem JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup (X : Type u) (x : X) (y : X) : IsMaximal (x ⊓ y) y := by"
  },
  {
    "full_name": "FirstOrder.Language.LHom.setOf_realize_onFormula",
    "file_path": "Mathlib/ModelTheory/Semantics.lean",
    "teorema": "lemma FirstOrder.Language.LHom.setOf_realize_onFormula (L : Language) (α : Type u') (φ : L →ᴸ L') (ψ : L.Formula α) : setOf (φ.onFormula ψ).Realize = setOf ψ.Realize := by"
  },
  {
    "full_name": "Collinear.oangle_sign_of_sameRay_vsub",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean",
    "teorema": "lemma Collinear.oangle_sign_of_sameRay_vsub (P : Type u_2) (p₁ : P) (p₂ : P) (p₃ : P) (p₄ : P) (p₅ : P) : (∡ p₁ p₅ p₂).sign = (∡ p₃ p₅ p₄).sign := by"
  },
  {
    "full_name": "MeasureTheory.Measure.InnerRegularWRT.of_restrict",
    "file_path": "Mathlib/MeasureTheory/Measure/Regular.lean",
    "teorema": "lemma MeasureTheory.Measure.InnerRegularWRT.of_restrict (p : Set α → Prop) (α : Type u_1) (μ : Measure α) : μ.InnerRegularWRT p MeasurableSet := by"
  },
  {
    "full_name": "Finset.sum_nat_mod",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "lemma Finset.sum_nat_mod (f : α → ℕ) (n : ℕ) (s : Finset α) (α : Type u_3) : (Multiset.map (fun x => x % n) (Multiset.map (fun i => f i) s.val)).sum % n = (∑ i ∈ s, f i % n) % n := by"
  },
  {
    "full_name": "Associates.dvdNotUnit_of_lt",
    "file_path": "Mathlib/Algebra/Associated.lean",
    "teorema": "theorem Associates.dvdNotUnit_of_lt (a : Associates α) (b : Associates α) (α : Type u_1) : DvdNotUnit a b := by"
  },
  {
    "full_name": "exists_maximal_orthonormal",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
    "teorema": "lemma exists_maximal_orthonormal (E : Type u_2) (s : Set E) (𝕜 : Type u_1) : ∃ w ⊇ s, Orthonormal 𝕜 Subtype.val ∧ ∀ u ⊇ w, Orthonormal 𝕜 Subtype.val → u = w := by"
  },
  {
    "full_name": "mem_segment_translate",
    "file_path": "Mathlib/Analysis/Convex/Segment.lean",
    "teorema": "lemma mem_segment_translate (E : Type u_2) (a : E) (b : E) (c : E) (x : E) (𝕜 : Type u_1) : a + x ∈ [a + b-[𝕜]a + c] ↔ x ∈ [b-[𝕜]c] := by"
  },
  {
    "full_name": "IsBoundedLinearMap.snd",
    "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean",
    "teorema": "theorem IsBoundedLinearMap.snd (𝕜 : Type u_1) : IsBoundedLinearMap 𝕜 fun x => x.2 := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.measure_le_lt_top",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "theorem MeasureTheory.Integrable.measure_le_lt_top (c : ℝ) (f : α → ℝ) (α : Type u_1) (μ : Measure α) : μ {a | f a ≤ c} < ⊤ := by"
  },
  {
    "full_name": "HasDerivWithinAt.norm_sq",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Calculus.lean",
    "teorema": "theorem HasDerivWithinAt.norm_sq (F : Type u_3) (f : ℝ → F) (s : Set ℝ) (x : ℝ) : HasDerivWithinAt (fun x => ‖f x‖ ^ 2) (2 * ⟪f x, f'⟫_ℝ) s x := by"
  },
  {
    "full_name": "FiniteDimensional.finrank_pi",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Constructions.lean",
    "teorema": "lemma FiniteDimensional.finrank_pi (R : Type u) (ι : Type v) : finrank R (ι → R) = Fintype.card ι := by"
  },
  {
    "full_name": "isOpenMap_eval",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "lemma isOpenMap_eval (i : ι) (ι : Type u_1) : IsOpenMap (eval i) := by"
  },
  {
    "full_name": "tsum_sq_fourierCoeff",
    "file_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
    "teorema": "theorem tsum_sq_fourierCoeff (T : ℝ) (f : ↥(Lp ℂ 2 haarAddCircle)) : ∑' (i : ℤ), ‖fourierCoeff (↑↑f) i‖ ^ 2 = ∫ (t : AddCircle T), ‖↑↑f t‖ ^ 2 ∂haarAddCircle := by"
  },
  {
    "full_name": "GaussianInt.natCast_natAbs_norm",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
    "teorema": "lemma GaussianInt.natCast_natAbs_norm (x : ℤ[i]) : ↑(norm x).natAbs = ↑(norm x) := by"
  },
  {
    "full_name": "Basis.mem_submodule_iff'",
    "file_path": "Mathlib/LinearAlgebra/Basis.lean",
    "teorema": "lemma Basis.mem_submodule_iff' (M : Type u_6) (P : Submodule R M) (R : Type u_3) (b : Basis ι R ↥P) (c : ι → R) (x : M) (ι : Type u_1) : (x = (Finsupp.equivFunOnFinite.symm c).sum fun i x => x • ↑(b i)) ↔ x = ∑ i : ι, c i • ↑(b i) := by"
  },
  {
    "full_name": "variationOnFromTo.monotoneOn",
    "file_path": "Mathlib/Analysis/BoundedVariation.lean",
    "teorema": "lemma variationOnFromTo.monotoneOn (E : Type u_2) (a : α) (f : α → E) (s : Set α) (α : Type u_1) : MonotoneOn (variationOnFromTo f s a) s := by"
  },
  {
    "full_name": "List.length_sigma",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "theorem List.length_sigma (l₁ : List α) (l₂ : (a : α) → List (σ a)) (α : Type u_2) (σ : α → Type u_8) : (l₁.sigma l₂).length = (map (fun a => (l₂ a).length) l₁).sum := by"
  },
  {
    "full_name": "Polynomial.smeval_comp",
    "file_path": "Mathlib/Algebra/Polynomial/Smeval.lean",
    "teorema": "lemma Polynomial.smeval_comp (R : Type u_1) (S : Type u_2) (p : R[X]) (q : R[X]) (x : S) : (p.comp q).smeval x = p.smeval (q.smeval x) := by"
  },
  {
    "full_name": "Option.map_bind'",
    "file_path": "Mathlib/Data/Option/Basic.lean",
    "teorema": "lemma Option.map_bind' (f : β → γ) (g : α → Option β) (x : Option α) (α : Type u_1) (β : Type u_2) (γ : Type u_3) : Option.map f (x.bind g) = x.bind fun a => Option.map f (g a) := by"
  },
  {
    "full_name": "SimpleGraph.cliqueFinset_map_of_equiv",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "teorema": "theorem SimpleGraph.cliqueFinset_map_of_equiv (G : SimpleGraph α) (e : α ≃ β) (n : ℕ) (α : Type u_1) (β : Type u_2) : ↑((SimpleGraph.map e.toEmbedding G).cliqueFinset n) = := by"
  },
  {
    "full_name": "Submonoid.LocalizationMap.eq_iff_exists",
    "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean",
    "teorema": "theorem Submonoid.LocalizationMap.eq_iff_exists (M : Type u_1) (N : Type u_2) (S : Submonoid M) (f : S.LocalizationMap N) (x : M) (y : M) : f.toMap x = f.toMap y := by"
  },
  {
    "full_name": "Set.Intersecting.exists_card_eq",
    "file_path": "Mathlib/Combinatorics/SetFamily/Intersecting.lean",
    "teorema": "theorem Set.Intersecting.exists_card_eq (s : Finset α) (α : Type u_1) : ∃ t, s ⊆ t ∧ 2 * t.card = Fintype.card α ∧ (↑t).Intersecting := by"
  },
  {
    "full_name": "Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean",
    "teorema": "lemma Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint (P : Type u_3) (b : P) (k : Type u_1) (p₁ : P) (p₂ : ι → P) (s : Finset ι) (w : ι → k) (ι : Type u_4) : ∑ i ∈ s, w i • (p₁ -ᵥ p₂ i) = (∑ i ∈ s, w i) • (p₁ -ᵥ b) - (s.weightedVSubOfPoint p₂ b) w := by"
  },
  {
    "full_name": "MeasurableSpace.cardinal_generateMeasurable_le_continuum",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Card.lean",
    "teorema": "lemma MeasurableSpace.cardinal_generateMeasurable_le_continuum (s : Set (Set α)) (α : Type u) : max (#↑s) 2 ^ ℵ₀ ≤ 𝔠 := by"
  },
  {
    "full_name": "Fin.coe_of_injective_castLE_symm",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.coe_of_injective_castLE_symm (h : n ≤ k) (hi : i ∈ Set.range (castLE h)) (i : Fin k) (k : ℕ) (n : ℕ) : ↑((Equiv.ofInjective (castLE h) ⋯).symm ⟨i, hi⟩) = ↑i := by"
  },
  {
    "full_name": "cfc_inv_id",
    "file_path": "Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean",
    "teorema": "lemma cfc_inv_id (a : Aˣ) : cfc (fun x => x⁻¹) ↑a = ↑a⁻¹ := by"
  },
  {
    "full_name": "summable_of_ratio_norm_eventually_le",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "theorem summable_of_ratio_norm_eventually_le (f : ℕ → α) (α : Type u_4) : Summable f := by"
  },
  {
    "full_name": "CategoryTheory.whisker_eq",
    "file_path": "Mathlib/CategoryTheory/Category/Basic.lean",
    "teorema": "theorem CategoryTheory.whisker_eq (C : Type u) (X : C) (Y : C) (Z : C) (f : X ⟶ Y) (g : Y ⟶ Z) (h : Y ⟶ Z) : f ≫ g = f ≫ h := by"
  },
  {
    "full_name": "IntermediateField.AdjoinSimple.norm_gen_eq_one",
    "file_path": "Mathlib/RingTheory/Norm.lean",
    "teorema": "lemma IntermediateField.AdjoinSimple.norm_gen_eq_one (K : Type u_4) (L : Type u_5) (x : L) : (norm K) (AdjoinSimple.gen K x) = 1 := by"
  },
  {
    "full_name": "List.permutationsAux2_fst",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "teorema": "theorem List.permutationsAux2_fst (f : List α → β) (r : List β) (t : α) (ts : List α) (y : α) (ys : List α) (α : Type u_1) (β : Type u_2) : (permutationsAux2 t ts r (y :: ys) f).1 = y :: ys ++ ts := by"
  },
  {
    "full_name": "Set.image_iUnion₂",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "lemma Set.image_iUnion₂ (f : α → β) (s : (i : ι) → κ i → Set α) (α : Type u_1) (β : Type u_2) (ι : Sort u_4) (κ : ι → Sort u_7) : f '' ⋃ i, ⋃ j, s i j = ⋃ i, ⋃ j, f '' s i j := by"
  },
  {
    "full_name": "Int.preimage_Ioc",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Int.preimage_Ioc (a : α) (b : α) (α : Type u_2) : Int.cast ⁻¹' Ioc a b = Ioc ⌊a⌋ ⌊b⌋ := by"
  },
  {
    "full_name": "EuclideanGeometry.two_zsmul_oangle_of_vectorSpan_eq",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean",
    "teorema": "lemma EuclideanGeometry.two_zsmul_oangle_of_vectorSpan_eq (P : Type u_2) (p₁ : P) (p₂ : P) (p₃ : P) (p₄ : P) (p₅ : P) (p₆ : P) : 2 • ∡ p₁ p₂ p₃ = 2 • ∡ p₄ p₅ p₆ := by"
  },
  {
    "full_name": "Matrix.frobenius_nnnorm_diagonal",
    "file_path": "Mathlib/Analysis/Matrix.lean",
    "teorema": "lemma Matrix.frobenius_nnnorm_diagonal (n : Type u_4) (v : n → α) (α : Type u_5) : ‖diagonal v‖₊ = ‖(WithLp.equiv 2 (n → α)).symm v‖₊ := by"
  },
  {
    "full_name": "LieModule.Weight.ext_iff",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "theorem LieModule.Weight.ext_iff (L : Type u_3) (M : Type u_4) (R : Type u_2) (χ₁ : Weight R L M) (χ₂ : Weight R L M) : ⇑χ₁ = ⇑χ₂ ↔ χ₁ = χ₂ := by"
  },
  {
    "full_name": "NoZeroSMulDivisors.trans",
    "file_path": "Mathlib/Algebra/Algebra/Basic.lean",
    "teorema": "theorem NoZeroSMulDivisors.trans (M : Type u_7) (R : Type u_5) : NoZeroSMulDivisors R M := by"
  },
  {
    "full_name": "CategoryTheory.Subobject.ofLEMk_comp",
    "file_path": "Mathlib/CategoryTheory/Subobject/Basic.lean",
    "teorema": "lemma CategoryTheory.Subobject.ofLEMk_comp (A : C) (B : C) (C : Type u₁) (X : Subobject B) (f : A ⟶ B) (h : X ≤ mk f) : X.ofLEMk f h ≫ f = X.arrow := by"
  },
  {
    "full_name": "EMetric.isClosed_subsets_of_isClosed",
    "file_path": "Mathlib/Topology/MetricSpace/Closeds.lean",
    "teorema": "lemma EMetric.isClosed_subsets_of_isClosed (s : Set α) (α : Type u) : IsClosed {t | ↑t ⊆ s} := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.iIndepFun.indepFun_prod_mk",
    "file_path": "Mathlib/Probability/Independence/Kernel.lean",
    "teorema": "lemma ProbabilityTheory.kernel.iIndepFun.indepFun_prod_mk (f : (i : ι) → Ω → β i) (i : ι) (j : ι) (k : ι) (Ω : Type u_2) (α : Type u_1) (β : ι → Type u_8) (ι : Type u_3) (κ : ↥(kernel α Ω)) (μ : Measure α) : IndepFun (fun a => (f i a, f j a)) (f k) κ μ := by"
  },
  {
    "full_name": "QPF.liftp_iff",
    "file_path": "Mathlib/Data/QPF/Univariate/Basic.lean",
    "teorema": "theorem QPF.liftp_iff (F : Type u → Type u) (p : α → Prop) (x : F α) (α : Type u) : Liftp p x ↔ ∃ a f, x = abs ⟨a, f⟩ ∧ ∀ (i : (P F).B a), p (f i) := by"
  },
  {
    "full_name": "differentiableWithinAt_univ",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
    "teorema": "theorem differentiableWithinAt_univ (E : Type u_2) (F : Type u_3) (f : E → F) (x : E) (𝕜 : Type u_1) : DifferentiableWithinAt 𝕜 f univ x ↔ DifferentiableAt 𝕜 f x := by"
  },
  {
    "full_name": "FirstOrder.Language.Embedding.coe_injective",
    "file_path": "Mathlib/ModelTheory/Basic.lean",
    "teorema": "lemma FirstOrder.Language.Embedding.coe_injective (L : Language) (M : Type w) (N : Type w') (f : M ↪[L] N) (g : M ↪[L] N) : f = g := by"
  },
  {
    "full_name": "Polynomial.Monic.mul_left_ne_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "teorema": "lemma Polynomial.Monic.mul_left_ne_zero (R : Type u) (p : R[X]) (q : R[X]) : q * p ≠ 0 := by"
  },
  {
    "full_name": "Filter.principal_mono",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.principal_mono (s : Set α) (t : Set α) (α : Type u) : 𝓟 s ≤ 𝓟 t ↔ s ⊆ t := by"
  },
  {
    "full_name": "denseRange_discrete",
    "file_path": "Mathlib/Topology/Order.lean",
    "teorema": "theorem denseRange_discrete (f : ι → α) (α : Type u_1) (ι : Type u_3) : DenseRange f ↔ Surjective f := by"
  },
  {
    "full_name": "MulAction.map_stabilizer_le",
    "file_path": "Mathlib/Algebra/Pointwise/Stabilizer.lean",
    "teorema": "theorem MulAction.map_stabilizer_le (G : Type u_1) (H : Type u_2) (f : G →* H) (s : Set G) : Subgroup.map f (stabilizer G s) ≤ stabilizer H (⇑f '' s) := by"
  },
  {
    "full_name": "AffineSubspace.wSameSide_vadd_left_iff",
    "file_path": "Mathlib/Analysis/Convex/Side.lean",
    "teorema": "theorem AffineSubspace.wSameSide_vadd_left_iff (P : Type u_4) (R : Type u_1) (V : Type u_2) (s : AffineSubspace R P) (v : V) (x : P) (y : P) : s.WSameSide (v +ᵥ x) y ↔ s.WSameSide x y := by"
  },
  {
    "full_name": "CategoryTheory.eqToIso_map",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "lemma CategoryTheory.eqToIso_map (C : Type u₁) (D : Type u₂) (F : C ⥤ D) (X : C) (Y : C) (p : X = Y) : F.mapIso (eqToIso p) = eqToIso ⋯ := by"
  },
  {
    "full_name": "le_iff_compact_le_imp",
    "file_path": "Mathlib/Order/CompactlyGenerated/Basic.lean",
    "teorema": "lemma le_iff_compact_le_imp (a : α) (b : α) (α : Type u_2) : a ≤ b := by"
  },
  {
    "full_name": "LucasLehmer.X.card_units_lt",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "teorema": "theorem LucasLehmer.X.card_units_lt (q : ℕ+) : Fintype.card (X q)ˣ < ↑q ^ 2 := by"
  },
  {
    "full_name": "Batteries.RBNode.Path.zoom_zoomed₂",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "teorema": "theorem Batteries.RBNode.Path.zoom_zoomed₂ (cut : α✝ → Ordering) (path : Path α✝) : Zoomed cut path' := by"
  },
  {
    "full_name": "Trivialization.linearMapAt_apply",
    "file_path": "Mathlib/Topology/VectorBundle/Basic.lean",
    "teorema": "lemma Trivialization.linearMapAt_apply (B : Type u_2) (E : B → Type u_4) (F : Type u_3) (R : Type u_1) (b : B) (e : Trivialization F TotalSpace.proj) (y : E b) : (Trivialization.linearMapAt R e b) y = if b ∈ e.baseSet then (↑e { proj := b, snd := y }).2 else 0 := by"
  },
  {
    "full_name": "Matroid.Basis.exchange",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "teorema": "lemma Matroid.Basis.exchange (I : Set α) (J : Set α) (M : Matroid α) (X : Set α) (e : α) (α : Type u_1) : ∃ f ∈ J \\ I, M.Basis (insert f (I \\ {e})) X := by"
  },
  {
    "full_name": "Multiset.inf_union",
    "file_path": "Mathlib/Data/Multiset/Lattice.lean",
    "teorema": "theorem Multiset.inf_union (s₁ : Multiset α) (s₂ : Multiset α) (α : Type u_1) : (s₁ ∪ s₂).inf = s₁.inf ⊓ s₂.inf := by"
  },
  {
    "full_name": "Vector.mapAccumr_snoc",
    "file_path": "Mathlib/Data/Vector/Snoc.lean",
    "teorema": "theorem Vector.mapAccumr_snoc (f : α → α✝ → α✝ × β✝) (n : ℕ) (s : α✝) (x : α) (xs : Vector α n) (α : Type u_2) : mapAccumr f (xs.snoc x) s = := by"
  },
  {
    "full_name": "orthogonalProjection_eq_self_iff",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Projection.lean",
    "teorema": "lemma orthogonalProjection_eq_self_iff (E : Type u_2) (K : Submodule 𝕜 E) (v : E) (𝕜 : Type u_1) : ↑((orthogonalProjection K) v) = v ↔ v ∈ K := by"
  },
  {
    "full_name": "OrthonormalBasis.coe_toBasis",
    "file_path": "Mathlib/Analysis/InnerProductSpace/PiL2.lean",
    "teorema": "theorem OrthonormalBasis.coe_toBasis (E : Type u_4) (b : OrthonormalBasis ι 𝕜 E) (ι : Type u_1) (𝕜 : Type u_3) : ⇑b.toBasis = ⇑b := by"
  },
  {
    "full_name": "Finset.preimage_union",
    "file_path": "Mathlib/Data/Finset/Preimage.lean",
    "teorema": "lemma Finset.preimage_union (f : α → β) (hst : InjOn f (f ⁻¹' ↑(s ∪ t))) (s : Finset β) (t : Finset β) (α : Type u) (β : Type v) : ↑((s ∪ t).preimage f hst) = ↑(s.preimage f ⋯ ∪ t.preimage f ⋯) := by"
  },
  {
    "full_name": "ArithmeticFunction.LSeriesSummable_vonMangoldt",
    "file_path": "Mathlib/NumberTheory/LSeries/Dirichlet.lean",
    "teorema": "lemma ArithmeticFunction.LSeriesSummable_vonMangoldt (s : ℂ) : LSeriesSummable (fun n => ↑(Λ n)) s := by"
  },
  {
    "full_name": "nilpotent_iff_finite_descending_central_series",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "teorema": "theorem nilpotent_iff_finite_descending_central_series (G : Type u_1) (H : Subgroup G) : Group.IsNilpotent G ↔ ∃ n H, IsDescendingCentralSeries H ∧ H n = ⊥ := by"
  },
  {
    "full_name": "mulIndicator_biUnion_finset_eventuallyEq",
    "file_path": "Mathlib/Order/Filter/IndicatorFunction.lean",
    "teorema": "lemma mulIndicator_biUnion_finset_eventuallyEq (a : α) (f : α → β) (s : ι → Set α) (α : Type u_1) (β : Type u_2) (ι : Type u_5) : (fun n => (⋃ i ∈ n, s i).mulIndicator f a) =ᶠ[atTop] fun x => (iUnion s).mulIndicator f a := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_eq_pi_iff",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "teorema": "theorem InnerProductGeometry.angle_eq_pi_iff (V : Type u_1) (x : V) (y : V) : angle x y = π ↔ x ≠ 0 ∧ ∃ r < 0, y = r • x := by"
  },
  {
    "full_name": "CovBy.Ico_eq",
    "file_path": "Mathlib/Order/Cover.lean",
    "teorema": "theorem CovBy.Ico_eq (a : α) (b : α) (α : Type u_1) : Ico a b = {a} := by"
  },
  {
    "full_name": "PSet.not_nonempty_empty",
    "file_path": "Mathlib/SetTheory/ZFC/Basic.lean",
    "teorema": "lemma PSet.not_nonempty_empty : ¬∅.Nonempty := by"
  },
  {
    "full_name": "Surreal.Multiplication.P2_neg_right",
    "file_path": "Mathlib/SetTheory/Surreal/Multiplication.lean",
    "teorema": "lemma Surreal.Multiplication.P2_neg_right (x₁ : PGame) (x₂ : PGame) (y : PGame) : P2 x₁ x₂ y ↔ P2 x₁ x₂ (-y) := by"
  },
  {
    "full_name": "IsSubmonoid.multiset_prod_mem",
    "file_path": "Mathlib/Deprecated/Submonoid.lean",
    "teorema": "lemma IsSubmonoid.multiset_prod_mem (M : Type u_3) (m : Multiset M) (s : Set M) : (∀ a ∈ m, a ∈ s) → m.prod ∈ s := by"
  },
  {
    "full_name": "StructureGroupoid.restriction_in_maximalAtlas",
    "file_path": "Mathlib/Geometry/Manifold/ChartedSpace.lean",
    "teorema": "theorem StructureGroupoid.restriction_in_maximalAtlas (G : StructureGroupoid H) (H : Type u) (M : Type u_2) (e : PartialHomeomorph M H) (hs : Nonempty ↥s) (s : Opens M) : e.subtypeRestr hs ∈ maximalAtlas (↥s) G := by"
  },
  {
    "full_name": "one_lt_of_lt_mul_left",
    "file_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
    "teorema": "lemma one_lt_of_lt_mul_left (a : α) (α : Type u_1) : 1 * ?m.28643 < a * ?m.28643 := by"
  },
  {
    "full_name": "Set.image_fst_graphOn",
    "file_path": "Mathlib/Data/Set/Function.lean",
    "teorema": "lemma Set.image_fst_graphOn (f : α → β) (s : Set α) (α : Type u_1) (β : Type u_2) : Prod.fst '' graphOn f s = s := by"
  },
  {
    "full_name": "LipschitzOnWith.extend_pi",
    "file_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean",
    "teorema": "theorem LipschitzOnWith.extend_pi (K : ℝ≥0) (f : α → ι → ℝ) (s : Set α) (α : Type u) (ι : Type x) : ∃ g, LipschitzWith K g ∧ EqOn f g s := by"
  },
  {
    "full_name": "Finset.mem_sym_iff",
    "file_path": "Mathlib/Data/Finset/Sym.lean",
    "teorema": "theorem Finset.mem_sym_iff (a : α) (m : Sym α n) (n : ℕ) (s : Finset α) (α : Type u_1) : m ∈ s.sym n ↔ ∀ a ∈ m, a ∈ s := by"
  },
  {
    "full_name": "OrthonormalBasis.orthonormal_adjustToOrientation",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Orientation.lean",
    "teorema": "theorem OrthonormalBasis.orthonormal_adjustToOrientation (E : Type u_1) (e : OrthonormalBasis ι ℝ E) (x : Orientation ℝ E ι) (ι : Type u_2) : Orthonormal ℝ ⇑(e.toBasis.adjustToOrientation x) := by"
  },
  {
    "full_name": "HurwitzZeta.completedHurwitzZetaOdd_one_sub",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaOdd.lean",
    "teorema": "lemma HurwitzZeta.completedHurwitzZetaOdd_one_sub (a : UnitAddCircle) (s : ℂ) : completedHurwitzZetaOdd a (1 - s) = completedSinZeta a s := by"
  },
  {
    "full_name": "List.cons_diff_of_mem",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "lemma List.cons_diff_of_mem (a : α) (l₁ : List α) (l₂ : List α) (α : Type u_1) : (a :: l₁).diff l₂ = l₁.diff (l₂.erase a) := by"
  },
  {
    "full_name": "Substring.Valid.next",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "theorem Substring.Valid.next (c : Char) (m₁ : List Char) : x✝.next { byteIdx := utf8Len m₁ } = { byteIdx := utf8Len m₁ + c.utf8Size } := by"
  },
  {
    "full_name": "exists_set_linearIndependent_of_isDomain",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Localization.lean",
    "teorema": "theorem exists_set_linearIndependent_of_isDomain (M : Type v) (R : Type u) : ∃ s, #↑s = Module.rank R M ∧ LinearIndependent (ι := ↑s) R Subtype.val := by"
  },
  {
    "full_name": "CategoryTheory.topologyOfClosureOperator_self",
    "file_path": "Mathlib/CategoryTheory/Sites/Closed.lean",
    "teorema": "theorem CategoryTheory.topologyOfClosureOperator_self (C : Type u) (J₁ : GrothendieckTopology C) : topologyOfClosureOperator J₁.closureOperator ⋯ = J₁ := by"
  },
  {
    "full_name": "Nat.prime_two",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "theorem Nat.prime_two : Prime 2 := by"
  },
  {
    "full_name": "FiniteDimensional.finrank_eq_zero_iff_isTorsion",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Finite.lean",
    "teorema": "theorem FiniteDimensional.finrank_eq_zero_iff_isTorsion (M : Type v) (R : Type u_1) : finrank R M = 0 ↔ Module.IsTorsion R M := by"
  },
  {
    "full_name": "IsPGroup.powEquiv_symm_apply",
    "file_path": "Mathlib/GroupTheory/PGroup.lean",
    "teorema": "theorem IsPGroup.powEquiv_symm_apply (G : Type u_1) (g : G) (hG : IsPGroup p G) (hn : p.Coprime n) (n : ℕ) (p : ℕ) : (hG.powEquiv hn).symm g = g ^ (orderOf g).gcdB n := by"
  },
  {
    "full_name": "VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable",
    "file_path": "Mathlib/MeasureTheory/Covering/Differentiation.lean",
    "teorema": "lemma VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable (E : Type u_2) (f : α → E) (v : VitaliFamily μ) (α : Type u_1) (μ : Measure α) : ∀ᵐ (x : α) ∂μ, Tendsto (fun a => (∫⁻ (y : α) in a, ↑‖f y - f x‖₊ ∂μ) / μ a) (v.filterAt x) (𝓝 0) := by"
  },
  {
    "full_name": "Units.mul_right_eq_zero",
    "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
    "teorema": "theorem Units.mul_right_eq_zero (M₀ : Type u_2) (a : M₀) : a = 0 := by"
  },
  {
    "full_name": "Seminorm.finset_sup_le_sum",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "theorem Seminorm.finset_sup_le_sum (E : Type u_7) (p : ι → Seminorm 𝕜 E) (s : Finset ι) (ι : Type u_12) (𝕜 : Type u_3) : s.sup p ≤ ∑ i ∈ s, p i := by"
  },
  {
    "full_name": "LinearMap.trace_tensorProduct",
    "file_path": "Mathlib/LinearAlgebra/Trace.lean",
    "teorema": "theorem LinearMap.trace_tensorProduct (M : Type u_2) (N : Type u_3) (R : Type u_1) : (mapBilinear R M N M N).compr₂ (trace R (M ⊗[R] N)) = (lsmul R R).compl₁₂ (trace R M) (trace R N) := by"
  },
  {
    "full_name": "Finset.sum_pow'",
    "file_path": "Mathlib/Algebra/BigOperators/Ring.lean",
    "teorema": "lemma Finset.sum_pow' (a : α) (f : ι → α) (i : ι) (n : ℕ) (s : Finset ι) (α : Type u_2) (ι : Type u_1) : (∑ a ∈ s, f a) ^ n = ∑ p ∈ piFinset fun _i => s, ∏ i : Fin n, f (p i) := by"
  },
  {
    "full_name": "Finset.surj_on_of_inj_on_of_card_le",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "lemma Finset.surj_on_of_inj_on_of_card_le (f : (a : α) → a ∈ s → β) (s : Finset α) (t : Finset β) (α : Type u_1) (β : Type u_2) : ∀ b ∈ t, ∃ a, ∃ (ha : a ∈ s), b = f a ha := by"
  },
  {
    "full_name": "Finsupp.neLocus_self_sub_right",
    "file_path": "Mathlib/Data/Finsupp/NeLocus.lean",
    "teorema": "lemma Finsupp.neLocus_self_sub_right (N : Type u_3) (f : α →₀ N) (g : α →₀ N) (α : Type u_1) : f.neLocus (f - g) = g.support := by"
  },
  {
    "full_name": "UpperHalfPlane.center_zero",
    "file_path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean",
    "teorema": "theorem UpperHalfPlane.center_zero (z : ℍ) : (z.center 0).im = z.im := by"
  },
  {
    "full_name": "ContinuousLinearMap.prod_ext_iff",
    "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean",
    "teorema": "lemma ContinuousLinearMap.prod_ext_iff (M : Type u_6) (N₂ : Type u_9) (N₃ : Type u_10) (R : Type u_1) (f : M × N₂ →L[R] N₃) (g : M × N₂ →L[R] N₃) : f = g ↔ f.comp (inl R M N₂) = g.comp (inl R M N₂) ∧ f.comp (inr R M N₂) = g.comp (inr R M N₂) := by"
  },
  {
    "full_name": "Polynomial.eval₂_neg",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "theorem Polynomial.eval₂_neg (R : Type u) (S : Type u_1) (f : R →+* S) (p : R[X]) (x : S) : eval₂ f x (-p) = -eval₂ f x p := by"
  },
  {
    "full_name": "eq_of_vsub_eq_zero",
    "file_path": "Mathlib/Algebra/AddTorsor.lean",
    "teorema": "lemma eq_of_vsub_eq_zero (P : Type u_2) (p₁ : P) (p₂ : P) : p₁ = p₂ := by"
  },
  {
    "full_name": "Complex.Gammaℝ_ne_zero_of_re_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean",
    "teorema": "theorem Complex.Gammaℝ_ne_zero_of_re_pos (s : ℂ) : s.Gammaℝ ≠ 0 := by"
  },
  {
    "full_name": "HasProd.mul",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean",
    "teorema": "theorem HasProd.mul (a : α) (b : α) (f : β → α) (g : β → α) (α : Type u_1) (β : Type u_2) : HasProd (fun b => f b * g b) (a * b) := by"
  },
  {
    "full_name": "Lagrange.degree_interpolate_lt",
    "file_path": "Mathlib/LinearAlgebra/Lagrange.lean",
    "teorema": "theorem Lagrange.degree_interpolate_lt (F : Type u_1) (r : ι → F) (s : Finset ι) (v : ι → F) (ι : Type u_2) : ((interpolate s v) r).degree < ↑s.card := by"
  },
  {
    "full_name": "Projectivization.submodule_injective",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Basic.lean",
    "teorema": "theorem Projectivization.submodule_injective (K : Type u_1) (V : Type u_2) (u : ℙ K V) (v : ℙ K V) : u = v := by"
  },
  {
    "full_name": "Rel.mul_edgeDensity_le_edgeDensity",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Density.lean",
    "teorema": "lemma Rel.mul_edgeDensity_le_edgeDensity (r : α → β → Prop) (s₁ : Finset α) (s₂ : Finset α) (t₁ : Finset β) (t₂ : Finset β) (α : Type u_4) (β : Type u_5) : ↑s₂.card / ↑s₁.card * (↑t₂.card / ↑t₁.card) * edgeDensity r s₂ t₂ ≤ edgeDensity r s₁ t₁ := by"
  },
  {
    "full_name": "left_eq_midpoint_iff",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean",
    "teorema": "theorem left_eq_midpoint_iff (P : Type u_4) (R : Type u_1) (x : P) (y : P) : x = midpoint R x y ↔ x = y := by"
  },
  {
    "full_name": "Function.not_injective_iff",
    "file_path": "Mathlib/Logic/Function/Basic.lean",
    "teorema": "lemma Function.not_injective_iff (f : α → β) (α : Sort u_1) (β : Sort u_2) : ¬Injective f ↔ ∃ a b, f a = f b ∧ a ≠ b := by"
  },
  {
    "full_name": "Finset.sup'_union",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "lemma Finset.sup'_union (a : α) (f : β → α) (h₁ : s₁.Nonempty) (h₂ : s₂.Nonempty) (s₁ : Finset β) (s₂ : Finset β) (α : Type u_2) (β : Type u_3) : (s₁ ∪ s₂).sup' ⋯ f ≤ a ↔ s₁.sup' h₁ f ⊔ s₂.sup' h₂ f ≤ a := by"
  },
  {
    "full_name": "Polynomial.cyclotomic_irreducible_pow_of_irreducible_pow",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean",
    "teorema": "theorem Polynomial.cyclotomic_irreducible_pow_of_irreducible_pow (R : Type u_1) (m : ℕ) (p : ℕ) : Irreducible (cyclotomic (p ^ m) R) := by"
  },
  {
    "full_name": "SignType.nonneg_iff_ne_neg_one",
    "file_path": "Mathlib/Data/Sign.lean",
    "teorema": "lemma SignType.nonneg_iff_ne_neg_one (a : SignType) : 0 ≤ a ↔ a ≠ -1 := by"
  },
  {
    "full_name": "CoxeterSystem.length_eq_one_iff",
    "file_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
    "teorema": "theorem CoxeterSystem.length_eq_one_iff (B : Type u_1) (M : CoxeterMatrix B) (W : Type u_2) (cs : CoxeterSystem M W) (w : W) : cs.length w = 1 ↔ ∃ i, w = cs.simple i := by"
  },
  {
    "full_name": "HahnSeries.single_coeff",
    "file_path": "Mathlib/RingTheory/HahnSeries/Basic.lean",
    "teorema": "lemma HahnSeries.single_coeff (R : Type u_2) (a : Γ) (b : Γ) (r : R) (Γ : Type u_1) : ((single a) r).coeff b = if b = a then r else 0 := by"
  },
  {
    "full_name": "Filter.EventuallyEq.mfderivWithin_eq",
    "file_path": "Mathlib/Geometry/Manifold/MFDeriv/Basic.lean",
    "teorema": "lemma Filter.EventuallyEq.mfderivWithin_eq (E : Type u_2) (H : Type u_3) (I : ModelWithCorners 𝕜 E H) (M : Type u_4) (f : M → M') (f₁ : M → M') (s : Set M) (x : M) (𝕜 : Type u_1) : mfderivWithin I I' f₁ s x = mfderivWithin I I' f s x := by"
  },
  {
    "full_name": "MeasureTheory.Measure.restrict_toMeasurable_of_sFinite",
    "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean",
    "teorema": "theorem MeasureTheory.Measure.restrict_toMeasurable_of_sFinite (s : Set α) (t : Set α) (α : Type u_1) (μ : Measure α) : (μ.restrict (toMeasurable μ s)) t = (μ.restrict s) t := by"
  },
  {
    "full_name": "TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "theorem TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff (s : Set α) (t : Set α) (α : Type u) : s = t := by"
  },
  {
    "full_name": "List.sum_take_map_length_splitWrtComposition",
    "file_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
    "teorema": "theorem List.sum_take_map_length_splitWrtComposition (c : Composition l.length) (i : ℕ) (l : List α) (α : Type u_1) : (take i (map length (l.splitWrtComposition c))).sum = c.sizeUpTo i := by"
  },
  {
    "full_name": "IsSl2Triple.f_ne_zero",
    "file_path": "Mathlib/Algebra/Lie/Sl2.lean",
    "teorema": "lemma IsSl2Triple.f_ne_zero (L : Type u_2) (f : L) : f ≠ 0 := by"
  },
  {
    "full_name": "Finsupp.mem_neLocus",
    "file_path": "Mathlib/Data/Finsupp/NeLocus.lean",
    "teorema": "lemma Finsupp.mem_neLocus (N : Type u_3) (a : α) (f : α →₀ N) (g : α →₀ N) (α : Type u_1) : a ∈ f.neLocus g ↔ f a ≠ g a := by"
  },
  {
    "full_name": "Order.isPredLimit_toDual_iff",
    "file_path": "Mathlib/Order/SuccPred/Limit.lean",
    "teorema": "theorem Order.isPredLimit_toDual_iff (a : α) (α : Type u_1) : IsPredLimit (toDual a) ↔ IsSuccLimit a := by"
  },
  {
    "full_name": "Multiset.powerset_cons",
    "file_path": "Mathlib/Data/Multiset/Powerset.lean",
    "teorema": "lemma Multiset.powerset_cons (a : α) (l : List α) (α : Type u_1) : (a ::ₘ ⟦l⟧).powerset = powerset ⟦l⟧ + map (cons a) (powerset ⟦l⟧) := by"
  },
  {
    "full_name": "Polynomial.degree_erase_lt",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "theorem Polynomial.degree_erase_lt (R : Type u) (p : R[X]) : (erase p.natDegree p).degree < p.degree := by"
  },
  {
    "full_name": "ContinuousMultilinearMap.ext_iff",
    "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean",
    "teorema": "lemma ContinuousMultilinearMap.ext_iff (M₁ : ι → Type w₁) (M₂ : Type w₂) (R : Type u) (f : ContinuousMultilinearMap R M₁ M₂) (ι : Type v) : f = f' ↔ ∀ (x : (i : ι) → M₁ i), f x = f' x := by"
  },
  {
    "full_name": "SimpleGraph.Subgraph.subgraphOfAdj_connected",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
    "teorema": "theorem SimpleGraph.Subgraph.subgraphOfAdj_connected (G : SimpleGraph V) (V : Type u) (hvw : G.Adj v w) (v : V) (w : V) : (G.subgraphOfAdj hvw).Connected := by"
  },
  {
    "full_name": "CliffordAlgebra.ι_sq_scalar",
    "file_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Basic.lean",
    "teorema": "theorem CliffordAlgebra.ι_sq_scalar (M : Type u_2) (Q : QuadraticForm R M) (R : Type u_1) (m : M) : (ι Q) m * (ι Q) m = (algebraMap R (CliffordAlgebra Q)) (Q m) := by"
  },
  {
    "full_name": "Real.mk_neg",
    "file_path": "Mathlib/Data/Real/Basic.lean",
    "teorema": "lemma Real.mk_neg (f : CauSeq ℚ abs) : mk (-f) = -mk f := by"
  },
  {
    "full_name": "Polynomial.eval₂_mul_noncomm",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "lemma Polynomial.eval₂_mul_noncomm (R : Type u) (S : Type v) (f : R →+* S) (p : R[X]) (q : R[X]) (x : S) : eval₂ f x (p * q) = eval₂ f x p * eval₂ f x q := by"
  },
  {
    "full_name": "Stream'.get_succ_iterate",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "teorema": "theorem Stream'.get_succ_iterate (a : α) (f : α → α) (n : ℕ) (α : Type u) : (iterate f a).get n.succ = (iterate f (f a)).get n := by"
  },
  {
    "full_name": "Real.volume_ball",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean",
    "teorema": "theorem Real.volume_ball (a : ℝ) (r : ℝ) : volume (Metric.ball a r) = ofReal (2 * r) := by"
  },
  {
    "full_name": "ProbabilityTheory.IsCondKernelCDF.setLIntegral",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean",
    "teorema": "theorem ProbabilityTheory.IsCondKernelCDF.setLIntegral (a : α) (f : α × β → StieltjesFunction) (s : Set β) (x : ℝ) (α : Type u_1) (β : Type u_2) (κ : ↥(kernel α (β × ℝ))) (ν : ↥(kernel α β)) : ∫⁻ (b : β) in s, ENNReal.ofReal (↑(f (a, b)) x) ∂ν a = (κ a) (s ×ˢ Iic x) := by"
  },
  {
    "full_name": "Affine.Simplex.reindex_reindex_symm",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean",
    "teorema": "lemma Affine.Simplex.reindex_reindex_symm (P : Type u_3) (e : Fin (m + 1) ≃ Fin (n + 1)) (k : Type u_1) (m : ℕ) (n : ℕ) (s : Simplex k P m) : (s.reindex e).reindex e.symm = s := by"
  },
  {
    "full_name": "AlgebraicGeometry.diagonal_targetAffineLocally_eq_targetAffineLocally",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/Constructors.lean",
    "teorema": "lemma AlgebraicGeometry.diagonal_targetAffineLocally_eq_targetAffineLocally (P : AffineTargetMorphismProperty) : (targetAffineLocally P).diagonal = targetAffineLocally P.diagonal := by"
  },
  {
    "full_name": "Filter.HasBasis.frequently_iff",
    "file_path": "Mathlib/Order/Filter/Bases.lean",
    "teorema": "lemma Filter.HasBasis.frequently_iff (i : ι) (l : Filter α) (p : ι → Prop) (q : α → Prop) (s : ι → Set α) (α : Type u_1) (ι : Sort u_4) : (∃ᶠ (x : α) in l, q x) ↔ ∀ (i : ι), p i → ∃ x ∈ s i, q x := by"
  },
  {
    "full_name": "MvPolynomial.vanishingIdeal_pointToPoint",
    "file_path": "Mathlib/RingTheory/Nullstellensatz.lean",
    "teorema": "theorem MvPolynomial.vanishingIdeal_pointToPoint (k : Type u_1) (x : σ → k) (σ : Type u_2) : (vanishingIdeal {x}).IsPrime := by"
  },
  {
    "full_name": "List.permutationsAux_cons",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "teorema": "lemma List.permutationsAux_cons (is : List α) (t : α) (ts : List α) (α : Type u_1) : (t :: ts).permutationsAux is = := by"
  },
  {
    "full_name": "Nat.factorization_eq_zero_of_not_dvd",
    "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
    "teorema": "lemma Nat.factorization_eq_zero_of_not_dvd (n : ℕ) (p : ℕ) : n.factorization p = 0 := by"
  },
  {
    "full_name": "Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic",
    "file_path": "Mathlib/FieldTheory/PurelyInseparable.lean",
    "teorema": "lemma Field.lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic (E : Type v) (F : Type u) (K : Type w) : Cardinal.lift.{w, v} (sepDegree F E) * Cardinal.lift.{v, w} (sepDegree E K) = Cardinal.lift.{v, w} (sepDegree F K) := by"
  },
  {
    "full_name": "HasLineDerivAt.le_of_lipschitzOn",
    "file_path": "Mathlib/Analysis/Calculus/LineDeriv/Basic.lean",
    "teorema": "theorem HasLineDerivAt.le_of_lipschitzOn (C : ℝ≥0) (E : Type u_3) (F : Type u_2) (f : E → F) (v : E) : ‖f'‖ ≤ ↑C * ‖v‖ := by"
  },
  {
    "full_name": "LinearIndependent.cardinal_mk_le_finrank",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Finite.lean",
    "teorema": "lemma LinearIndependent.cardinal_mk_le_finrank (M : Type v) (R : Type u) (ι : Type w) : #ι ≤ ↑(finrank R M) := by"
  },
  {
    "full_name": "prime_dvd_prime_iff_eq",
    "file_path": "Mathlib/Algebra/Associated.lean",
    "teorema": "theorem prime_dvd_prime_iff_eq (M : Type u_5) (p : M) (q : M) : p ∣ q ↔ p = q := by"
  },
  {
    "full_name": "NNRat.add_def",
    "file_path": "Mathlib/Data/NNRat/Defs.lean",
    "teorema": "theorem NNRat.add_def (q : ℚ≥0) (r : ℚ≥0) : q + r = divNat (q.num * r.den + r.num * q.den) (q.den * r.den) := by"
  },
  {
    "full_name": "dualTensorHomEquivOfBasis_apply",
    "file_path": "Mathlib/LinearAlgebra/Contraction.lean",
    "teorema": "lemma dualTensorHomEquivOfBasis_apply (M : Type v₁) (N : Type v₂) (R : Type u) (b : Basis ι R M) (x : Dual R M ⊗[R] N) (ι : Type w) : (dualTensorHomEquivOfBasis b) x = (dualTensorHom R M N) x := by"
  },
  {
    "full_name": "FloorRing.exists_prime_mul_pow_div_factorial_lt_one",
    "file_path": "Mathlib/Algebra/Order/Floor/Prime.lean",
    "teorema": "theorem FloorRing.exists_prime_mul_pow_div_factorial_lt_one (K : Type u_1) (a : K) (c : K) (n : ℕ) : ∃ p > n, Nat.Prime p ∧ a * c ^ p / ↑(p - 1)! < 1 := by"
  },
  {
    "full_name": "Option.map₂_coe_right",
    "file_path": "Mathlib/Data/Option/NAry.lean",
    "teorema": "lemma Option.map₂_coe_right (a : Option α) (b : β) (f : α → β → γ) (α : Type u_1) (β : Type u_2) (γ : Type u_3) : map₂ f a (some b) = Option.map (fun a => f a b) a := by"
  },
  {
    "full_name": "Fin.foldl_zero",
    "file_path": ".lake/packages/batteries/Batteries/Data/Fin/Lemmas.lean",
    "teorema": "theorem Fin.foldl_zero (f : α → Fin 0 → α) (x : α) (α : Sort u_1) : foldl 0 f x = x := by"
  },
  {
    "full_name": "Complex.sin_add_sin",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.sin_add_sin (x : ℂ) (y : ℂ) : sin x + sin y = 2 * sin ((x + y) / 2) * cos ((x - y) / 2) := by"
  },
  {
    "full_name": "Complex.monotone_ofReal",
    "file_path": "Mathlib/Data/Complex/Order.lean",
    "teorema": "lemma Complex.monotone_ofReal : Monotone ofReal' := by"
  },
  {
    "full_name": "LinearMap.orthogonal_span_singleton_eq_to_lin_ker",
    "file_path": "Mathlib/LinearAlgebra/SesquilinearForm.lean",
    "teorema": "theorem LinearMap.orthogonal_span_singleton_eq_to_lin_ker (B : V →ₗ[K] V →ₛₗ[J] V₂) (J : K →+* K) (K : Type u_13) (V : Type u_16) (V₂ : Type u_18) (x : V) : (Submodule.span K {x}).orthogonalBilin B = ker (B x) := by"
  },
  {
    "full_name": "MvPowerSeries.inv_eq_zero",
    "file_path": "Mathlib/RingTheory/MvPowerSeries/Inverse.lean",
    "teorema": "lemma MvPowerSeries.inv_eq_zero (k : Type u_3) (σ : Type u_1) (φ : MvPowerSeries σ k) : (constantCoeff σ k) φ = 0 := by"
  },
  {
    "full_name": "Polynomial.degree_C_mul_X_pow_le",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "theorem Polynomial.degree_C_mul_X_pow_le (R : Type u) (a : R) (n : ℕ) : (C a * X ^ n).degree ≤ ↑n := by"
  },
  {
    "full_name": "Submodule.le_one_toAddSubmonoid",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "theorem Submodule.le_one_toAddSubmonoid : 1 ≤ toAddSubmonoid 1 := by"
  },
  {
    "full_name": "Finpartition.part_surjOn",
    "file_path": "Mathlib/Order/Partition/Finpartition.lean",
    "teorema": "theorem Finpartition.part_surjOn (P : Finpartition s) (p : Finset α) (s : Finset α) (α : Type u_1) : p ∈ P.part '' ↑s := by"
  },
  {
    "full_name": "UniformFun.uniformSpace_eq_inf_precomp_of_cover",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "theorem UniformFun.uniformSpace_eq_inf_precomp_of_cover (x : α) (α : Type u_1) (β : Type u_2) (δ₁ : Type u_6) (δ₂ : Type u_7) (φ₁ : δ₁ → α) (φ₂ : δ₂ → α) : uniformSpace α β = UniformSpace.comap (⇑ofFun ∘ (fun x => x ∘ φ₁) ∘ ⇑toFun) (uniformSpace δ₁ β) ⊓ UniformSpace.comap (⇑ofFun ∘ (fun x => x ∘ φ₂) ∘ ⇑toFun) (uniformSpace δ₂ β) := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_sub_eq_arccos_of_inner_eq_zero",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean",
    "teorema": "lemma InnerProductGeometry.angle_sub_eq_arccos_of_inner_eq_zero (V : Type u_1) (x : V) (y : V) : angle x (x - y) = Real.arccos (‖x‖ / ‖x - y‖) := by"
  },
  {
    "full_name": "CategoryTheory.Abelian.exact_iff_exact_coimage_π",
    "file_path": "Mathlib/CategoryTheory/Abelian/Exact.lean",
    "teorema": "theorem CategoryTheory.Abelian.exact_iff_exact_coimage_π (C : Type u₁) (X : C) (Y : C) (Z : C) (f : X ⟶ Y) (g : Y ⟶ Z) : Exact f g ↔ Exact f (coimage.π g) := by"
  },
  {
    "full_name": "Matroid.comap_base_iff",
    "file_path": "Mathlib/Data/Matroid/Map.lean",
    "teorema": "lemma Matroid.comap_base_iff (B : Set α) (E : Set α) (N : Matroid β) (f : α → β) (α : Type u_1) (β : Type u_2) : (N.comap f).Base B ↔ N.Basis (f '' B) (f '' (f ⁻¹' N.E)) ∧ InjOn f B ∧ B ⊆ f ⁻¹' N.E := by"
  },
  {
    "full_name": "MulAction.set_mem_fixedBy_of_subset_fixedBy",
    "file_path": "Mathlib/GroupTheory/GroupAction/FixedPoints.lean",
    "teorema": "theorem MulAction.set_mem_fixedBy_of_subset_fixedBy (G : Type u_2) (g : G) (s : Set α) (α : Type u_1) : s ∈ fixedBy (Set α) g := by"
  },
  {
    "full_name": "Matrix.BlockTriangular.det_fintype",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Block.lean",
    "teorema": "theorem Matrix.BlockTriangular.det_fintype (M : Matrix m m R) (R : Type v) (b : m → α) (m : Type u_3) (α : Type u_1) : M.det = ∏ k : α, (M.toSquareBlock b k).det := by"
  },
  {
    "full_name": "DirectSum.equivCongrLeft_apply",
    "file_path": "Mathlib/Algebra/DirectSum/Basic.lean",
    "teorema": "lemma DirectSum.equivCongrLeft_apply (f : ⨁ (i : ι), β i) (h : ι ≃ κ) (k : κ) (β : ι → Type w) (ι : Type v) (κ : Type u_1) : ((equivCongrLeft h) f) k = f (h.symm k) := by"
  },
  {
    "full_name": "GeneralizedContinuedFraction.compExactValue_correctness_of_stream_eq_some",
    "file_path": "Mathlib/Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean",
    "teorema": "lemma GeneralizedContinuedFraction.compExactValue_correctness_of_stream_eq_some (K : Type u_1) (n : ℕ) (v : K) : ∀ {ifp_n : IntFractPair K}, IntFractPair.stream v n = some ifp_n → v = compExactValue ((of v).continuantsAux n) ((of v).continuantsAux (n + 1)) ifp_n.fr := by"
  },
  {
    "full_name": "ConvexOn.average_mem_epigraph",
    "file_path": "Mathlib/Analysis/Convex/Integral.lean",
    "teorema": "lemma ConvexOn.average_mem_epigraph (E : Type u_2) (f : α → E) (g : E → ℝ) (s : Set E) (α : Type u_1) (μ : Measure α) : (⨍ (x : α), f x ∂μ, ⨍ (x : α), g (f x) ∂μ) ∈ {p | p.1 ∈ s ∧ g p.1 ≤ p.2} := by"
  },
  {
    "full_name": "StrictConcaveOn.eq_of_map_sum_eq",
    "file_path": "Mathlib/Analysis/Convex/Jensen.lean",
    "teorema": "theorem StrictConcaveOn.eq_of_map_sum_eq (E : Type u_2) (p : ι → E) (t : Finset ι) (ι : Type u_5) : ∀ ⦃j : ι⦄, j ∈ t → ∀ ⦃k : ι⦄, k ∈ t → p j = p k := by"
  },
  {
    "full_name": "Finsupp.card_Ico",
    "file_path": "Mathlib/Data/Finsupp/Interval.lean",
    "teorema": "theorem Finsupp.card_Ico (f : ι →₀ α) (g : ι →₀ α) (α : Type u_2) (ι : Type u_1) : (Ico f g).card = ∏ i ∈ f.support ∪ g.support, (Icc (f i) (g i)).card - 1 := by"
  },
  {
    "full_name": "neg_one_sq",
    "file_path": "Mathlib/Algebra/Ring/Commute.lean",
    "teorema": "theorem neg_one_sq : (-1) ^ 2 = 1 := by"
  },
  {
    "full_name": "Real.Angle.eq_iff_sign_eq_and_abs_toReal_eq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "lemma Real.Angle.eq_iff_sign_eq_and_abs_toReal_eq (θ : Angle) (ψ : Angle) : θ = ψ ↔ θ.sign = ψ.sign ∧ |θ.toReal| = |ψ.toReal| := by"
  },
  {
    "full_name": "Submodule.restrictScalars_mul",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "teorema": "lemma Submodule.restrictScalars_mul (A : Type u_1) (B : Type u_2) (C : Type u_3) (I : Submodule B C) (J : Submodule B C) : restrictScalars A (I * J) = restrictScalars A I * restrictScalars A J := by"
  },
  {
    "full_name": "Subalgebra.iSupLift_of_mem",
    "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Directed.lean",
    "teorema": "lemma Subalgebra.iSupLift_of_mem (A : Type u_2) (B : Type u_3) (K : ι → Subalgebra R A) (R : Type u_1) (T : Subalgebra R A) (dir : Directed (fun x x_1 => x ≤ x_1) K) (f : (i : ι) → ↥(K i) →ₐ[R] B) (hT : T = iSup K) (hf : ∀ (i j : ι) (h : K i ≤ K j), f i = (f j).comp (inclusion h)) (hx : ↑x ∈ K i) (i : ι) (x : ↥T) (ι : Type u_4) : (iSupLift K dir f hf T hT) x = (f i) ⟨↑x, hx⟩ := by"
  },
  {
    "full_name": "Cardinal.lift_le_continuum",
    "file_path": "Mathlib/SetTheory/Cardinal/Continuum.lean",
    "teorema": "lemma Cardinal.lift_le_continuum (c : Cardinal.{u}) : lift.{v, u} c ≤ 𝔠 ↔ c ≤ 𝔠 := by"
  },
  {
    "full_name": "Int.fract_add_int",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Int.fract_add_int (a : α) (m : ℤ) (α : Type u_2) : fract (a + ↑m) = fract a := by"
  },
  {
    "full_name": "exists_mem_frontier_infDist_compl_eq_dist",
    "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean",
    "teorema": "theorem exists_mem_frontier_infDist_compl_eq_dist (E : Type u_1) (s : Set E) (x : E) : ∃ y ∈ frontier s, infDist x sᶜ = dist x y := by"
  },
  {
    "full_name": "Multiset.product_cons",
    "file_path": "Mathlib/Data/Multiset/Bind.lean",
    "teorema": "lemma Multiset.product_cons (a : α) (b : β) (s : Multiset α) (t : Multiset β) (α : Type u_1) (β : Type v) : s ×ˢ (b ::ₘ t) = map (fun a => (a, b)) s + s ×ˢ t := by"
  },
  {
    "full_name": "integrable_rpow_mul_exp_neg_mul_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",
    "teorema": "lemma integrable_rpow_mul_exp_neg_mul_sq (b : ℝ) (s : ℝ) : Integrable (fun x => x ^ s * rexp (-b * x ^ 2)) volume := by"
  },
  {
    "full_name": "TopCat.Presheaf.covering_presieve_eq_self",
    "file_path": "Mathlib/Topology/Sheaves/SheafCondition/Sites.lean",
    "teorema": "lemma TopCat.Presheaf.covering_presieve_eq_self (R : Presieve Y) (X : TopCat) (Y : Opens ↑X) : presieveOfCoveringAux (coveringOfPresieve Y R) Y = R := by"
  },
  {
    "full_name": "Finset.prod_eq_prod_Ico_succ_bot",
    "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean",
    "teorema": "theorem Finset.prod_eq_prod_Ico_succ_bot (M : Type u_2) (a : ℕ) (b : ℕ) (f : ℕ → M) : ∏ k ∈ Ico a b, f k = f a * ∏ k ∈ Ico (a + 1) b, f k := by"
  },
  {
    "full_name": "Orientation.oangle_add_left_eq_arccos_of_oangle_eq_pi_div_two",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/RightAngle.lean",
    "teorema": "theorem Orientation.oangle_add_left_eq_arccos_of_oangle_eq_pi_div_two (V : Type u_1) (o : Orientation ℝ V (Fin 2)) (x : V) (y : V) : o.oangle (x + y) y = ↑(Real.arccos (‖y‖ / ‖x + y‖)) := by"
  },
  {
    "full_name": "Real.mul_self_sqrt",
    "file_path": "Mathlib/Data/Real/Sqrt.lean",
    "teorema": "theorem Real.mul_self_sqrt (x : ℝ) : √x * √x = x := by"
  },
  {
    "full_name": "Asymptotics.IsBigO.integrable",
    "file_path": "Mathlib/MeasureTheory/Integral/Asymptotics.lean",
    "teorema": "theorem Asymptotics.IsBigO.integrable (E : Type u_2) (f : α → E) (α : Type u_1) (μ : Measure α) : Integrable f μ := by"
  },
  {
    "full_name": "Filter.frequently_iff_forall_eventually_exists_and",
    "file_path": "Mathlib/Order/Filter/Basic.lean",
    "teorema": "lemma Filter.frequently_iff_forall_eventually_exists_and : False := by"
  },
  {
    "full_name": "Filter.extraction_forall_of_eventually'",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "theorem Filter.extraction_forall_of_eventually' (P : ℕ → ℕ → Prop) : ∀ (n : ℕ), ∀ᶠ (k : ℕ) in atTop, P n k := by"
  },
  {
    "full_name": "Matroid.restrict_eq_restrict_iff",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "teorema": "theorem Matroid.restrict_eq_restrict_iff (I : Set α) (M : Matroid α) (X : Set α) (α : Type u_1) : M ↾ X = M' ↾ X ↔ ∀ I ⊆ X, M.Indep I ↔ M'.Indep I := by"
  },
  {
    "full_name": "Part.some_inter_some",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.some_inter_some (a : α) (b : α) (α : Type u_1) : some a ∩ some b = some (a ∩ b) := by"
  },
  {
    "full_name": "Finset.mem_inv_smul_finset_iff",
    "file_path": "Mathlib/Data/Finset/Pointwise.lean",
    "teorema": "lemma Finset.mem_inv_smul_finset_iff (a : α) (b : β) (s : Finset β) (α : Type u_2) (β : Type u_3) : b ∈ a⁻¹ • s ↔ a • b ∈ s := by"
  },
  {
    "full_name": "integral_comp_neg_Iic",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Integral.lean",
    "teorema": "theorem integral_comp_neg_Iic (E : Type u_1) (c : ℝ) (f : ℝ → E) : ∫ (x : ℝ) in Iic c, f (-x) = ∫ (x : ℝ) in Ioi (-c), f x := by"
  },
  {
    "full_name": "Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range",
    "file_path": "Mathlib/Logic/Equiv/Fintype.lean",
    "teorema": "theorem Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range (b : β) (e : Perm α) (f : α ↪ β) (α : Type u_1) (β : Type u_2) : (e.viaFintypeEmbedding f) b = b := by"
  },
  {
    "full_name": "IsCyclic.unique_zpow_zmod",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
    "teorema": "lemma IsCyclic.unique_zpow_zmod (a : α) (x : α) (α : Type u) : ∃! n, x = a ^ n.val := by"
  },
  {
    "full_name": "BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding",
    "file_path": "Mathlib/Topology/TietzeExtension.lean",
    "teorema": "theorem BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding (X : Type u_1) (Y : Type u_2) (e : X → Y) (f : X →ᵇ ℝ) : ∃ g, (∀ (y : Y), ∃ x₁ x₂, g y ∈ Icc (f x₁) (f x₂)) ∧ ⇑g ∘ e = ⇑f := by"
  },
  {
    "full_name": "intervalIntegral.integral_comp_neg",
    "file_path": "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean",
    "teorema": "lemma intervalIntegral.integral_comp_neg (E : Type u_3) (a : ℝ) (b : ℝ) (f : ℝ → E) : ∫ (x : ℝ) in a..b, f (-x) = ∫ (x : ℝ) in -b..-a, f x := by"
  },
  {
    "full_name": "NNReal.summable_coe",
    "file_path": "Mathlib/Topology/Instances/NNReal.lean",
    "teorema": "theorem NNReal.summable_coe (f : α → ℝ≥0) (α : Type u_1) : (Summable fun a => ↑(f a)) ↔ Summable f := by"
  },
  {
    "full_name": "RightDerivMeasurableAux.differentiable_set_subset_D",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Measurable.lean",
    "teorema": "lemma RightDerivMeasurableAux.differentiable_set_subset_D (F : Type u_1) (K : Set F) (f : ℝ → F) : {x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ K} ⊆ D f K := by"
  },
  {
    "full_name": "constantCoeff_wittStructureRat_zero",
    "file_path": "Mathlib/RingTheory/WittVector/StructurePolynomial.lean",
    "teorema": "theorem constantCoeff_wittStructureRat_zero (idx : Type u_2) (p : ℕ) (Φ : MvPolynomial idx ℚ) : constantCoeff (wittStructureRat p Φ 0) = constantCoeff Φ := by"
  },
  {
    "full_name": "cfc_add",
    "file_path": "Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean",
    "teorema": "theorem cfc_add (A : Type u_2) (R : Type u_1) (a : A) (f : R → R) (g : R → R) : cfc (fun x => f x + g x) a = cfc f a + cfc g a := by"
  },
  {
    "full_name": "PadicSeq.equiv_zero_of_val_eq_of_equiv_zero",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNumbers.lean",
    "teorema": "lemma PadicSeq.equiv_zero_of_val_eq_of_equiv_zero (g : PadicSeq p) (j : ℕ) (p : ℕ) (ε : ℚ) : padicNorm p (↑(g - 0) j) < ε := by"
  },
  {
    "full_name": "EReal.coe_ennreal_pos",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "lemma EReal.coe_ennreal_pos (x : ℝ≥0∞) : 0 < ↑x ↔ 0 < x := by"
  },
  {
    "full_name": "MeasureTheory.VectorMeasure.subset_le_of_restrict_le_restrict",
    "file_path": "Mathlib/MeasureTheory/Measure/VectorMeasure.lean",
    "teorema": "theorem MeasureTheory.VectorMeasure.subset_le_of_restrict_le_restrict (M : Type u_3) (j : Set α) (v : VectorMeasure α M) (w : VectorMeasure α M) (α : Type u_1) : ↑v j ≤ ↑w j := by"
  },
  {
    "full_name": "CategoryTheory.MonoidalCategory.inv_hom_id_tensor",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean",
    "teorema": "theorem CategoryTheory.MonoidalCategory.inv_hom_id_tensor (C : Type u) (V : C) (W : C) (X : C) (Y : C) (Z : C) (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) : (f.inv ⊗ g) ≫ (f.hom ⊗ h) = (𝟙 W ⊗ g) ≫ (𝟙 W ⊗ h) := by"
  },
  {
    "full_name": "Set.Ico_eq_Ico_iff",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Ico_eq_Ico_iff (a₁ : α) (a₂ : α) (b₁ : α) (b₂ : α) (α : Type u_1) : a₁ = a₂ ∧ b₁ = b₂ := by"
  },
  {
    "full_name": "IsCompact.measure_eq_iInf_isOpen",
    "file_path": "Mathlib/MeasureTheory/Measure/Regular.lean",
    "teorema": "theorem IsCompact.measure_eq_iInf_isOpen (K : Set α) (α : Type u_1) (μ : Measure α) : μ K = ⨅ U, ⨅ (_ : K ⊆ U), ⨅ (_ : IsOpen U), μ U := by"
  },
  {
    "full_name": "one_sub_goldConj",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "teorema": "lemma one_sub_goldConj : 1 - φ = ψ := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.homMap_apply",
    "file_path": "Mathlib/CategoryTheory/Localization/HomEquiv.lean",
    "teorema": "lemma CategoryTheory.LocalizerMorphism.homMap_apply (C₁ : Type u_2) (C₂ : Type u_3) (D₁ : Type u_5) (D₂ : Type u_6) (G : D₁ ⥤ D₂) (L₁ : C₁ ⥤ D₁) (L₂ : C₂ ⥤ D₂) (W₁ : MorphismProperty C₁) (W₂ : MorphismProperty C₂) (X : C₁) (Y : C₁) (e : Φ.functor ⋙ L₂ ≅ L₁ ⋙ G) (f : L₁.obj X ⟶ L₁.obj Y) (Φ : LocalizerMorphism W₁ W₂) : Φ.homMap L₁ L₂ f = e.hom.app X ≫ G.map f ≫ e.inv.app Y := by"
  },
  {
    "full_name": "Int.existsUnique_mem_box",
    "file_path": "Mathlib/Order/Interval/Finset/Box.lean",
    "teorema": "lemma Int.existsUnique_mem_box (n : ℕ) (x : ℤ × ℤ) : ∃! n, x ∈ box n := by"
  },
  {
    "full_name": "ENNReal.iInf_sum",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "teorema": "lemma ENNReal.iInf_sum (a : ℝ≥0∞) (f : ι → α → ℝ≥0∞) (s : Finset α) (α : Type u_2) (ι : Sort u_1) : ⨅ i, ∑ a ∈ s, f i a = ∑ a ∈ s, ⨅ i, f i a := by"
  },
  {
    "full_name": "Mathlib.Tactic.Ring.atom_pf",
    "file_path": "Mathlib/Tactic/Ring/Basic.lean",
    "teorema": "lemma Mathlib.Tactic.Ring.atom_pf (R : Type u_1) (a : R) : a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 := by"
  },
  {
    "full_name": "Prod.segment_subset",
    "file_path": "Mathlib/Analysis/Convex/Segment.lean",
    "teorema": "lemma Prod.segment_subset (E : Type u_2) (F : Type u_3) (x : E × F) (y : E × F) (𝕜 : Type u_1) : [x-[𝕜]y] ⊆ [x.1-[𝕜]y.1] ×ˢ [x.2-[𝕜]y.2] := by"
  },
  {
    "full_name": "IsSigmaCompact.image_of_continuousOn",
    "file_path": "Mathlib/Topology/Compactness/SigmaCompact.lean",
    "teorema": "theorem IsSigmaCompact.image_of_continuousOn (X : Type u_1) (Y : Type u_2) (f : X → Y) (s : Set X) : IsSigmaCompact (f '' s) := by"
  },
  {
    "full_name": "IsGalois.card_aut_eq_finrank",
    "file_path": "Mathlib/FieldTheory/Galois.lean",
    "teorema": "theorem IsGalois.card_aut_eq_finrank (E : Type u_2) (F : Type u_1) : Fintype.card (E ≃ₐ[F] E) = finrank F E := by"
  },
  {
    "full_name": "NNReal.hasSum_coe",
    "file_path": "Mathlib/Topology/Instances/NNReal.lean",
    "teorema": "theorem NNReal.hasSum_coe (f : α → ℝ≥0) (r : ℝ≥0) (α : Type u_1) : HasSum (fun a => ↑(f a)) ↑r ↔ HasSum f r := by"
  },
  {
    "full_name": "Finsupp.erase_add",
    "file_path": "Mathlib/Data/Finsupp/Defs.lean",
    "teorema": "theorem Finsupp.erase_add (M : Type u_5) (a : α) (f : α →₀ M) (α : Type u_1) : erase a (f + f') = erase a f + erase a f' := by"
  },
  {
    "full_name": "Rat.neg_mkRat",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.neg_mkRat (d : Nat) (n : Int) : -mkRat n d = mkRat (-n) d := by"
  },
  {
    "full_name": "PFunctor.M.ichildren_mk",
    "file_path": "Mathlib/Data/PFunctor/Univariate/M.lean",
    "teorema": "theorem PFunctor.M.ichildren_mk (F : PFunctor.{u}) (i : F.Idx) (x : ↑F F.M) : ichildren i (M.mk x) = x.iget i := by"
  },
  {
    "full_name": "Ordinal.log_mono_right",
    "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
    "teorema": "theorem Ordinal.log_mono_right (b : Ordinal.{u_1}) (x : Ordinal.{u_1}) (y : Ordinal.{u_1}) : log b x ≤ log b y := by"
  },
  {
    "full_name": "RCLike.add_conj",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "theorem RCLike.add_conj (K : Type u_1) (z : K) : z + (starRingEnd K) z = ↑(re z) + ↑(im z) * I + (↑(re z) - ↑(im z) * I) := by"
  },
  {
    "full_name": "compact_open_separated_mul_left",
    "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean",
    "teorema": "lemma compact_open_separated_mul_left (G : Type w) (K : Set G) (U : Set G) : ∃ V ∈ 𝓝 1, V * K ⊆ U := by"
  },
  {
    "full_name": "contDiffAt_map_inverse",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma contDiffAt_map_inverse (E : Type uE) (F : Type uF) (e : E ≃L[𝕜] F) (n : ℕ∞) (𝕜 : Type u_1) : ContDiffAt 𝕜 n inverse ↑e := by"
  },
  {
    "full_name": "Finset.max'_mem",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "theorem Finset.max'_mem (H : s.Nonempty) (s : Finset α) (α : Type u_2) : s.max = ↑(s.max' H) := by"
  },
  {
    "full_name": "UFModel.Agrees.push",
    "file_path": "Mathlib/Data/UnionFind.lean",
    "teorema": "lemma UFModel.Agrees.push (arr : Array α) (f : α → β) (m : Fin n → β) (n : ℕ) (x : α) (α : Type u_1) (β : Sort u_2) : Agrees (arr.push x) f m' := by"
  },
  {
    "full_name": "inv_mul_cancel_left₀",
    "file_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
    "teorema": "lemma inv_mul_cancel_left₀ (G₀ : Type u_3) (a : G₀) (b : G₀) : a⁻¹ * a * b = b := by"
  },
  {
    "full_name": "Algebra.norm_algebraMap_of_basis",
    "file_path": "Mathlib/RingTheory/Norm.lean",
    "teorema": "lemma Algebra.norm_algebraMap_of_basis (R : Type u_1) (S : Type u_2) (x : R) (ι : Type w) : (norm R) ((algebraMap R S) x) = x ^ Fintype.card ι := by"
  },
  {
    "full_name": "ModularForm.mul_slash_SL2",
    "file_path": "Mathlib/NumberTheory/ModularForms/SlashActions.lean",
    "teorema": "theorem ModularForm.mul_slash_SL2 (A : SL(2, ℤ)) (f : ℍ → ℂ) (g : ℍ → ℂ) (k1 : ℤ) (k2 : ℤ) : (f * g) ∣[k1 + k2] ↑A = (↑↑↑A).det • f ∣[k1] A * g ∣[k2] A := by"
  },
  {
    "full_name": "UniqueMDiffWithinAt.smooth_bundle_preimage",
    "file_path": "Mathlib/Geometry/Manifold/MFDeriv/UniqueDifferential.lean",
    "teorema": "theorem UniqueMDiffWithinAt.smooth_bundle_preimage (E : Type u_2) (F : Type u_8) (H : Type u_3) (I : ModelWithCorners 𝕜 E H) (M : Type u_4) (Z : M → Type u_9) (p : TotalSpace F Z) (s : Set M) (𝕜 : Type u_1) : UniqueMDiffWithinAt (I.prod 𝓘(𝕜, F)) (TotalSpace.proj ⁻¹' s) p := by"
  },
  {
    "full_name": "List.takeD_eq_takeDTR",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "teorema": "theorem List.takeD_eq_takeDTR : @takeD = @takeDTR := by"
  },
  {
    "full_name": "unitInterval.mem_iff_one_sub_mem",
    "file_path": "Mathlib/Topology/UnitInterval.lean",
    "teorema": "theorem unitInterval.mem_iff_one_sub_mem (t : ℝ) : t ∈ I ↔ 1 - t ∈ I := by"
  },
  {
    "full_name": "Set.encard_tsub_one_le_encard_diff_singleton",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "theorem Set.encard_tsub_one_le_encard_diff_singleton (s : Set α) (x : α) (α : Type u_1) : s.encard - 1 ≤ (s \\ {x}).encard := by"
  },
  {
    "full_name": "Ideal.IsPrime.mul_mem_pow",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Ideal.lean",
    "teorema": "lemma Ideal.IsPrime.mul_mem_pow (I : Ideal R) (R : Type u_1) (a : R) (b : R) (n : ℕ) : a ∈ I ∨ b ∈ I ^ n := by"
  },
  {
    "full_name": "MeasureTheory.memℒp_zero_iff_aestronglyMeasurable",
    "file_path": "Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean",
    "teorema": "lemma MeasureTheory.memℒp_zero_iff_aestronglyMeasurable (E : Type u_2) (f : α → E) (α : Type u_1) (μ : Measure α) : Memℒp f 0 μ ↔ AEStronglyMeasurable f μ := by"
  },
  {
    "full_name": "Ring.DirectLimit.congr_symm_apply_of",
    "file_path": "Mathlib/Algebra/DirectLimit.lean",
    "teorema": "lemma Ring.DirectLimit.congr_symm_apply_of (G : ι → Type w) (e : (i : ι) → G i ≃+* G' i) (f : (i j : ι) → i ≤ j → G i →+* G j) (g : G' i) (he : ∀ (i j : ι) (h : i ≤ j), (e j).toRingHom.comp (f i j h) = (f' i j h).comp ↑(e i)) (i : ι) (ι : Type v) : (congr e he).symm ((of G' (fun x x_1 h => ⇑(f' x x_1 h)) i) g) = (of G (fun x x_1 h => ⇑(f x x_1 h)) i) ((e i).symm g) := by"
  },
  {
    "full_name": "eq_one_div_of_mul_eq_one_left",
    "file_path": "Mathlib/Algebra/Group/Basic.lean",
    "teorema": "lemma eq_one_div_of_mul_eq_one_left (a : α) (b : α) (α : Type u_1) : b = 1 / a := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.compProdFun_tsum_left",
    "file_path": "Mathlib/Probability/Kernel/Composition.lean",
    "teorema": "lemma ProbabilityTheory.kernel.compProdFun_tsum_left (a : α) (s : Set (β × γ)) (α : Type u_1) (β : Type u_2) (γ : Type u_4) (η : ↥(kernel (α × β) γ)) (κ : ↥(kernel α β)) : compProdFun κ η a s = ∑' (n : ℕ), compProdFun (seq κ n) η a s := by"
  },
  {
    "full_name": "MulAction.Supports.smul",
    "file_path": "Mathlib/GroupTheory/GroupAction/Support.lean",
    "teorema": "lemma MulAction.Supports.smul (G : Type u_1) (H : Type u_2) (b : β) (g : H) (s : Set α) (α : Type u_3) (β : Type u_4) : Supports G (g • s) (g • b) := by"
  },
  {
    "full_name": "Set.projIci_eq_self",
    "file_path": "Mathlib/Order/Interval/Set/ProjIcc.lean",
    "teorema": "lemma Set.projIci_eq_self (a : α) (x : α) (α : Type u_1) : projIci a x = ⟨a, ⋯⟩ ↔ x ≤ a := by"
  },
  {
    "full_name": "nnnorm_mul_le",
    "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean",
    "teorema": "lemma nnnorm_mul_le (a : α) (b : α) (α : Type u_1) : ‖a * b‖₊ ≤ ‖a‖₊ * ‖b‖₊ := by"
  },
  {
    "full_name": "IsGLB.biUnion_Ioi_eq",
    "file_path": "Mathlib/Order/Interval/Set/Disjoint.lean",
    "teorema": "theorem IsGLB.biUnion_Ioi_eq (a : α) (s : Set α) (α : Type v) : ⋃ x ∈ s, Ioi x = Ioi a := by"
  },
  {
    "full_name": "RCLike.conj_smul",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "lemma RCLike.conj_smul (K : Type u_1) (r : ℝ) (z : K) : (starRingEnd K) (r • z) = r • (starRingEnd K) z := by"
  },
  {
    "full_name": "Polynomial.isNilpotent_C_mul_pow_X_of_isNilpotent",
    "file_path": "Mathlib/RingTheory/Polynomial/Nilpotent.lean",
    "teorema": "lemma Polynomial.isNilpotent_C_mul_pow_X_of_isNilpotent (R : Type u_1) (n : ℕ) (r : R) : IsNilpotent (C r * X ^ n) := by"
  },
  {
    "full_name": "AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection_germ",
    "file_path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean",
    "teorema": "lemma AlgebraicGeometry.ProjectiveSpectrum.Proj.awayToSection_germ (A : Type u_2) (R : Type u_1) (f : A) (x : ↥(pbo f)) (𝒜 : ℕ → Submodule R A) : awayToSection 𝒜 f ≫ (structureSheaf 𝒜).presheaf.germ x = HomogeneousLocalization.mapId 𝒜 ⋯ ≫ (Proj.stalkIso' 𝒜 ↑x).toCommRingCatIso.inv := by"
  },
  {
    "full_name": "Measurable.nnreal_tsum",
    "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean",
    "teorema": "lemma Measurable.nnreal_tsum (f : ι → α → ℝ≥0) (α : Type u_1) (ι : Type u_5) : Measurable fun x => ∑' (i : ι), f i x := by"
  },
  {
    "full_name": "PosNum.to_nat_inj",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "lemma PosNum.to_nat_inj (m : PosNum) (n : PosNum) : pos m = pos n := by"
  },
  {
    "full_name": "Complex.add_conj",
    "file_path": "Mathlib/Data/Complex/Basic.lean",
    "teorema": "lemma Complex.add_conj (z : ℂ) : (z + (starRingEnd ℂ) z).re = (↑(2 * z.re)).re ∧ (z + (starRingEnd ℂ) z).im = (↑(2 * z.re)).im := by"
  },
  {
    "full_name": "AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk",
    "file_path": "Mathlib/RingTheory/AdjoinRoot.lean",
    "teorema": "lemma AdjoinRoot.quotAdjoinRootEquivQuotPolynomialQuot_symm_mk_mk (I : Ideal R) (R : Type u) (f : R[X]) (p : R[X]) : (quotAdjoinRootEquivQuotPolynomialQuot I f).symm ((Ideal.Quotient.mk (span {Polynomial.map (Ideal.Quotient.mk I) f})) (Polynomial.map (Ideal.Quotient.mk I) p)) = (Ideal.Quotient.mk (Ideal.map (of f) I)) ((mk f) p) := by"
  },
  {
    "full_name": "Mathlib.Meta.NormNum.isRat_inv_pos",
    "file_path": "Mathlib/Tactic/NormNum/Inv.lean",
    "teorema": "theorem Mathlib.Meta.NormNum.isRat_inv_pos (a : α) (d : ℕ) (n : ℕ) (α : Type u_1) : IsRat a (Int.ofNat n.succ) d → IsRat a⁻¹ (Int.ofNat d) n.succ := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.density_nonneg",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
    "teorema": "theorem ProbabilityTheory.kernel.density_nonneg (a : α) (s : Set β) (x : γ) (α : Type u_1) (β : Type u_2) (γ : Type u_3) (κ : ↥(kernel α (γ × β))) (ν : ↥(kernel α γ)) : 0 ≤ density κ ν a x s := by"
  },
  {
    "full_name": "Multiset.le_inter",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.le_inter (s : Multiset α) (t : Multiset α) (u : Multiset α) (α : Type u_1) : s ≤ t ∩ u := by"
  },
  {
    "full_name": "Nat.WithBot.add_one_le_of_lt",
    "file_path": "Mathlib/Data/Nat/WithBot.lean",
    "teorema": "lemma Nat.WithBot.add_one_le_of_lt (m : WithBot ℕ) (n : WithBot ℕ) : n + 1 ≤ m := by"
  },
  {
    "full_name": "Matrix.det_updateColumn_add_self",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
    "teorema": "lemma Matrix.det_updateColumn_add_self (A : Matrix n n R) (R : Type v) (i : n) (j : n) (n : Type u_2) : (A.updateColumn i fun k => A k i + A k j).det = A.det := by"
  },
  {
    "full_name": "Subgroup.MemRightTransversals.toEquiv_apply",
    "file_path": "Mathlib/GroupTheory/Complement.lean",
    "teorema": "theorem Subgroup.MemRightTransversals.toEquiv_apply (G : Type u_1) (H : Subgroup G) (f : Quotient (QuotientGroup.rightRel H) → G) (q : Quotient (QuotientGroup.rightRel H)) : ↑((toEquiv ⋯) q) = f q := by"
  },
  {
    "full_name": "Stream'.WSeq.exists_of_liftRel_right",
    "file_path": "Mathlib/Data/Seq/WSeq.lean",
    "teorema": "lemma Stream'.WSeq.exists_of_liftRel_right (R : α → β → Prop) (b : β) (s : WSeq α) (α : Type u) (β : Type v) : ∃ a, a ∈ s ∧ R a b := by"
  },
  {
    "full_name": "MeasureTheory.locallyIntegrableOn_of_locallyIntegrable_restrict",
    "file_path": "Mathlib/MeasureTheory/Function/LocallyIntegrable.lean",
    "teorema": "lemma MeasureTheory.locallyIntegrableOn_of_locallyIntegrable_restrict (E : Type u_3) (X : Type u_1) (f : X → E) (s : Set X) (μ : Measure X) : LocallyIntegrableOn f s μ := by"
  },
  {
    "full_name": "ENNReal.smul_sSup",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "theorem ENNReal.smul_sSup (R : Type u_4) (c : R) (s : Set ℝ≥0∞) : c • sSup s = ⨆ i ∈ s, c • i := by"
  },
  {
    "full_name": "UniqueMul.of_image_filter",
    "file_path": "Mathlib/Algebra/Group/UniqueProds.lean",
    "teorema": "theorem UniqueMul.of_image_filter (G : Type u_1) (a : G) (aG : G) (b : G) (bG : G) : a = aG ∧ b = bG := by"
  },
  {
    "full_name": "Nat.prod_pow_pos_of_zero_not_mem_support",
    "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean",
    "teorema": "lemma Nat.prod_pow_pos_of_zero_not_mem_support : False := by"
  },
  {
    "full_name": "Matrix.PosSemidef.fromBlocks₁₁",
    "file_path": "Mathlib/LinearAlgebra/Matrix/SchurComplement.lean",
    "teorema": "lemma Matrix.PosSemidef.fromBlocks₁₁ (A : Matrix m m 𝕜) (B : Matrix m n 𝕜) (D : Matrix n n 𝕜) (m : Type u_2) (n : Type u_3) (𝕜 : Type u_5) : (fromBlocks A B Bᴴ D).PosSemidef ↔ (D - Bᴴ * A⁻¹ * B).PosSemidef := by"
  },
  {
    "full_name": "Function.mulSupport_update_of_ne_one",
    "file_path": "Mathlib/Algebra/Group/Support.lean",
    "teorema": "lemma Function.mulSupport_update_of_ne_one (M : Type u_5) (f : α → M) (x : α) (y : M) (α : Type u_1) : mulSupport (update f x y) = insert x (mulSupport f) := by"
  },
  {
    "full_name": "Multiset.gcd_union",
    "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
    "teorema": "theorem Multiset.gcd_union (s₁ : Multiset α) (s₂ : Multiset α) (α : Type u_1) : (s₁ ∪ s₂).gcd = GCDMonoid.gcd s₁.gcd s₂.gcd := by"
  },
  {
    "full_name": "Multiset.Icc_eq_zero_iff",
    "file_path": "Mathlib/Order/Interval/Multiset.lean",
    "teorema": "lemma Multiset.Icc_eq_zero_iff (a : α) (b : α) (α : Type u_1) : Icc a b = 0 ↔ ¬a ≤ b := by"
  },
  {
    "full_name": "Set.pairwise_univ",
    "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean",
    "teorema": "theorem Set.pairwise_univ (r : α → α → Prop) (α : Type u_1) : univ.Pairwise r ↔ Pairwise r := by"
  },
  {
    "full_name": "Finset.affineCombination_filter_of_ne",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean",
    "teorema": "lemma Finset.affineCombination_filter_of_ne (P : Type u_3) (k : Type u_1) (p : ι → P) (pred : ι → Prop) (s : Finset ι) (w : ι → k) (ι : Type u_4) : (affineCombination k (filter pred s) p) w = (affineCombination k s p) w := by"
  },
  {
    "full_name": "Filter.pi_eq_bot",
    "file_path": "Mathlib/Order/Filter/Pi.lean",
    "teorema": "theorem Filter.pi_eq_bot (f : (i : ι) → Filter (α i)) (α : ι → Type u_2) (ι : Type u_1) : pi f = ⊥ ↔ ∃ i, f i = ⊥ := by"
  },
  {
    "full_name": "iterateFrobeniusEquiv_symm_add_apply",
    "file_path": "Mathlib/FieldTheory/Perfect.lean",
    "teorema": "theorem iterateFrobeniusEquiv_symm_add_apply (R : Type u_1) (m : ℕ) (n : ℕ) (p : ℕ) (x : R) : (iterateFrobeniusEquiv R p (m + n)) ((iterateFrobeniusEquiv R p (m + n)).symm x) = (iterateFrobeniusEquiv R p (m + n)) ((iterateFrobeniusEquiv R p m).symm ((iterateFrobeniusEquiv R p n).symm x)) := by"
  },
  {
    "full_name": "Set.Ioi_mul_Ici_subset'",
    "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean",
    "teorema": "theorem Set.Ioi_mul_Ici_subset' (a : α) (b : α) (α : Type u_1) : Ioi a * Ici b ⊆ Ioi (a * b) := by"
  },
  {
    "full_name": "EReal.image_coe_Iio",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "theorem EReal.image_coe_Iio (x : ℝ) : Real.toEReal '' Iio x = Ioo ⊥ ↑x := by"
  },
  {
    "full_name": "Real.tendsto_exp_div_pow_atTop",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
    "teorema": "theorem Real.tendsto_exp_div_pow_atTop (n : ℕ) (x : ℝ) : Tendsto (fun x => rexp x / x ^ n) atTop atTop := by"
  },
  {
    "full_name": "FractionalIdeal.count_zero",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Factorization.lean",
    "teorema": "lemma FractionalIdeal.count_zero (K : Type u_2) (R : Type u_1) (v : HeightOneSpectrum R) : count K v 0 = 0 := by"
  },
  {
    "full_name": "CategoryTheory.eqToHom_comp_iff",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "theorem CategoryTheory.eqToHom_comp_iff (C : Type u₁) (X : C) (Y : C) (g : X' ⟶ Y) (p : X = X') : g = eqToHom ⋯ ≫ eqToHom p ≫ g := by"
  },
  {
    "full_name": "Real.exists_rat_pow_btwn_rat_aux",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "lemma Real.exists_rat_pow_btwn_rat_aux (n : ℕ) (x : ℝ) (y : ℝ) : ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y := by"
  },
  {
    "full_name": "UniqueFactorizationMonoid.normalize_normalized_factor",
    "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean",
    "teorema": "theorem UniqueFactorizationMonoid.normalize_normalized_factor (a : α) (α : Type u_1) : ∀ x ∈ normalizedFactors a, normalize x = x := by"
  },
  {
    "full_name": "Real.mul_le_sin",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean",
    "teorema": "theorem Real.mul_le_sin (x : ℝ) : 2 / π * x ≤ sin x := by"
  },
  {
    "full_name": "Bornology.isVonNBounded_insert",
    "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean",
    "teorema": "theorem Bornology.isVonNBounded_insert (E : Type u_3) (s : Set E) (x : E) (𝕜 : Type u_1) : IsVonNBounded 𝕜 (insert x s) ↔ IsVonNBounded 𝕜 s := by"
  },
  {
    "full_name": "monovary_inv₀",
    "file_path": "Mathlib/Algebra/Order/Monovary.lean",
    "teorema": "lemma monovary_inv₀ (f : ι → α) (g : ι → β) (α : Type u_2) (β : Type u_3) (ι : Type u_1) : Monovary f⁻¹ g⁻¹ ↔ Monovary f g := by"
  },
  {
    "full_name": "smul_balancedCore_subset",
    "file_path": "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean",
    "teorema": "theorem smul_balancedCore_subset (E : Type u_2) (a : 𝕜) (s : Set E) (𝕜 : Type u_1) : a • balancedCore 𝕜 s ⊆ balancedCore 𝕜 s := by"
  },
  {
    "full_name": "List.enumFrom_eq_nil",
    "file_path": "Mathlib/Data/List/Enum.lean",
    "teorema": "theorem List.enumFrom_eq_nil (l : List α) (n : ℕ) (α : Type u_1) : enumFrom n l = [] ↔ l = [] := by"
  },
  {
    "full_name": "Nat.or_exists_succ",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "lemma Nat.or_exists_succ (n : ℕ) (p : ℕ → Prop) : (∃ n, p n) → p 0 ∨ ∃ n, p (n + 1) := by"
  },
  {
    "full_name": "IsUnit.smul_sub_iff_sub_inv_smul",
    "file_path": "Mathlib/GroupTheory/GroupAction/Group.lean",
    "teorema": "lemma IsUnit.smul_sub_iff_sub_inv_smul (a : β) (r : α) (α : Type u) (β : Type v) : IsUnit (r • 1 - a) ↔ IsUnit (1 - r⁻¹ • a) := by"
  },
  {
    "full_name": "HasFiniteFPowerSeriesOnBall.changeOrigin",
    "file_path": "Mathlib/Analysis/Analytic/CPolynomial.lean",
    "teorema": "theorem HasFiniteFPowerSeriesOnBall.changeOrigin (E : Type u_2) (r : ℝ≥0∞) (y : E) : 0 < r - ↑‖y‖₊ := by"
  },
  {
    "full_name": "Set.image_mono",
    "file_path": "Mathlib/Data/Set/Image.lean",
    "teorema": "theorem Set.image_mono (f : α → β) (s : Set α) (t : Set α) (α : Type u_1) (β : Type u_2) : f '' s ⊆ f '' t := by"
  },
  {
    "full_name": "Filter.EventuallyEq.restrict",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "theorem Filter.EventuallyEq.restrict (f : α → δ) (g : α → δ) (s : Set α) (α : Type u_2) (δ : Type u_4) (μ : Measure α) : f =ᶠ[ae (μ.restrict s)] g := by"
  },
  {
    "full_name": "Fin.castAdd_inj",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.castAdd_inj (a : Fin m) (b : Fin m) (m : ℕ) (n : ℕ) : castAdd n a = castAdd n b ↔ a = b := by"
  },
  {
    "full_name": "Matrix.conjTranspose_zpow",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "teorema": "lemma Matrix.conjTranspose_zpow (A : M) (n : ℕ) : (A ^ ↑n)ᴴ = Aᴴ ^ ↑n := by"
  },
  {
    "full_name": "List.countP_join'",
    "file_path": "Mathlib/Data/List/Join.lean",
    "teorema": "lemma List.countP_join' (a : List α) (l : List (List α)) (p : α → Bool) (α : Type u_1) : countP p (a :: l).join = Nat.sum (map (countP p) (a :: l)) := by"
  },
  {
    "full_name": "NormedSpace.vonNBornology_eq",
    "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean",
    "teorema": "theorem NormedSpace.vonNBornology_eq (E : Type u_3) (𝕜 : Type u_1) : Bornology.vonNBornology 𝕜 E = PseudoMetricSpace.toBornology := by"
  },
  {
    "full_name": "Rat.mkRat_nonneg",
    "file_path": "Mathlib/Algebra/Order/Ring/Rat.lean",
    "teorema": "lemma Rat.mkRat_nonneg (a : ℤ) (b : ℕ) : 0 ≤ mkRat a b := by"
  },
  {
    "full_name": "dist_vadd_left",
    "file_path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean",
    "teorema": "theorem dist_vadd_left (P : Type u_3) (V : Type u_2) (v : V) (x : P) : dist (v +ᵥ x) x = ‖v‖ := by"
  },
  {
    "full_name": "ContDiffAt.dist",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Calculus.lean",
    "teorema": "lemma ContDiffAt.dist (E : Type u_2) (G : Type u_4) (f : G → E) (g : G → E) (n : ℕ∞) (x : G) : ContDiffAt ℝ n (fun y => Dist.dist (f y) (g y)) x := by"
  },
  {
    "full_name": "Set.image_const_sub_uIcc",
    "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean",
    "teorema": "lemma Set.image_const_sub_uIcc (a : α) (b : α) (c : α) (α : Type u_1) : (fun x => a - x) '' [[b, c]] = [[a - b, a - c]] := by"
  },
  {
    "full_name": "Nat.div_ne_zero_iff_of_dvd",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "theorem Nat.div_ne_zero_iff_of_dvd (a : ℕ) (b : ℕ) : a / b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 := by"
  },
  {
    "full_name": "isQuasiSeparated_univ_iff",
    "file_path": "Mathlib/Topology/QuasiSeparated.lean",
    "teorema": "lemma isQuasiSeparated_univ_iff (α : Type u_3) : IsQuasiSeparated Set.univ ↔ QuasiSeparatedSpace α := by"
  },
  {
    "full_name": "MeasureTheory.measure_le_average_pos",
    "file_path": "Mathlib/MeasureTheory/Integral/Average.lean",
    "teorema": "theorem MeasureTheory.measure_le_average_pos (f : α → ℝ) (α : Type u_1) (μ : Measure α) : 0 < μ {x | f x ≤ ⨍ (a : α), f a ∂μ} := by"
  },
  {
    "full_name": "Int.bitwise_bit",
    "file_path": "Mathlib/Data/Int/Bitwise.lean",
    "teorema": "theorem Int.bitwise_bit (a : Bool) (b : Bool) (f : Bool → Bool → Bool) (m : ℤ) (n : ℤ) : bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by"
  },
  {
    "full_name": "Real.log_sqrt",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "teorema": "theorem Real.log_sqrt (x : ℝ) : log √x = log x / 2 := by"
  },
  {
    "full_name": "openEmbedding_sigma_map",
    "file_path": "Mathlib/Topology/Constructions.lean",
    "teorema": "theorem openEmbedding_sigma_map (f₁ : ι → κ) (f₂ : (i : ι) → σ i → τ (f₁ i)) (ι : Type u_5) (κ : Type u_6) (σ : ι → Type u_7) (τ : κ → Type u_8) : OpenEmbedding (Sigma.map f₁ f₂) ↔ ∀ (i : ι), OpenEmbedding (f₂ i) := by"
  },
  {
    "full_name": "WithTop.map₂_coe_right",
    "file_path": "Mathlib/Order/WithBot.lean",
    "teorema": "lemma WithTop.map₂_coe_right (a : WithTop α) (b : β) (f : α → β → γ) (α : Type u_1) (β : Type u_2) (γ : Type u_3) : map₂ f a ↑b = map (fun x => f x b) a := by"
  },
  {
    "full_name": "Matrix.isUnit_fromBlocks_zero₁₂",
    "file_path": "Mathlib/LinearAlgebra/Matrix/SchurComplement.lean",
    "teorema": "lemma Matrix.isUnit_fromBlocks_zero₁₂ (A : Matrix m m α) (C : Matrix n m α) (D : Matrix n n α) (m : Type u_2) (n : Type u_3) (α : Type u_4) : IsUnit (fromBlocks A 0 C D) ↔ IsUnit A ∧ IsUnit D := by"
  },
  {
    "full_name": "MeasureTheory.DominatedFinMeasAdditive.of_smul_measure",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "lemma MeasureTheory.DominatedFinMeasAdditive.of_smul_measure (C : ℝ) (T : Set α → β) (c : ℝ≥0∞) (α : Type u_1) (β : Type u_7) (μ : Measure α) : DominatedFinMeasAdditive μ T (c.toReal * C) := by"
  },
  {
    "full_name": "MeasureTheory.AEStronglyMeasurable.ae_integrable_condKernel_iff",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Integral.lean",
    "teorema": "theorem MeasureTheory.AEStronglyMeasurable.ae_integrable_condKernel_iff (F : Type u_4) (f : α × Ω → F) (Ω : Type u_2) (α : Type u_1) (ρ : Measure (α × Ω)) : (∀ᵐ (a : α) ∂ρ.fst, Integrable (fun ω => f (a, ω)) (ρ.condKernel a)) ∧ := by"
  },
  {
    "full_name": "smul_inv_smul",
    "file_path": "Mathlib/GroupTheory/GroupAction/Group.lean",
    "teorema": "lemma smul_inv_smul (c : α) (x : β) (α : Type u) (β : Type v) : c • c⁻¹ • x = x := by"
  },
  {
    "full_name": "RingHom.pNilradical_le_ker_of_perfectRing",
    "file_path": "Mathlib/FieldTheory/IsPerfectClosure.lean",
    "teorema": "lemma RingHom.pNilradical_le_ker_of_perfectRing (K : Type u_1) (L : Type u_2) (i : K →+* L) (x : K) : x ∈ ker i := by"
  },
  {
    "full_name": "infPrime_iff_infIrred",
    "file_path": "Mathlib/Order/Irreducible.lean",
    "teorema": "theorem infPrime_iff_infIrred (a : α) (b : α) (c : α) (α : Type u_2) : b ⊓ c ≤ a → b ≤ a ∨ c ≤ a := by"
  },
  {
    "full_name": "Nat.count_one",
    "file_path": "Mathlib/Data/Nat/Count.lean",
    "teorema": "lemma Nat.count_one (p : ℕ → Prop) : count p 1 = if p 0 then 1 else 0 := by"
  },
  {
    "full_name": "TensorProduct.liftAux.smul",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean",
    "teorema": "lemma TensorProduct.liftAux.smul (M : Type u_4) (N : Type u_5) (P : Type u_6) (R : Type u_1) (f : M →ₗ[R] N →ₗ[R] P) (p : M) (q : N) (r : R) : (liftAux f) (r • p ⊗ₜ[R] q) = r • (liftAux f) (p ⊗ₜ[R] q) := by"
  },
  {
    "full_name": "NumberField.mem_span_integralBasis",
    "file_path": "Mathlib/NumberTheory/NumberField/Basic.lean",
    "teorema": "theorem NumberField.mem_span_integralBasis (K : Type u_1) (x : K) : x ∈ Submodule.span ℤ (Set.range ⇑(integralBasis K)) ↔ x ∈ (algebraMap (𝓞 K) K).range := by"
  },
  {
    "full_name": "MvPolynomial.weightedHomogeneousComponent_eq_zero",
    "file_path": "Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean",
    "teorema": "theorem MvPolynomial.weightedHomogeneousComponent_eq_zero (M : Type u_2) (R : Type u_1) (n : M) (w : σ → M) (σ : Type u_3) (φ : MvPolynomial σ R) : (weightedHomogeneousComponent w n) φ = 0 := by"
  },
  {
    "full_name": "IsPurelyInseparable.tower_bot",
    "file_path": "Mathlib/FieldTheory/PurelyInseparable.lean",
    "teorema": "theorem IsPurelyInseparable.tower_bot (E : Type v) (F : Type u) : IsPurelyInseparable F E := by"
  },
  {
    "full_name": "Finset.card_union_eq_card_add_card",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "lemma Finset.card_union_eq_card_add_card (s : Finset α) (t : Finset α) (α : Type u_1) : (s ∪ t).card = s.card + t.card ↔ _root_.Disjoint s t := by"
  },
  {
    "full_name": "sdiff_lt",
    "file_path": "Mathlib/Order/BooleanAlgebra.lean",
    "teorema": "theorem sdiff_lt (x : α) (y : α) (α : Type u) : x \\ y < x := by"
  },
  {
    "full_name": "nonneg_iff_isSelfAdjoint_and_quasispectrumRestricts",
    "file_path": "Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean",
    "teorema": "theorem nonneg_iff_isSelfAdjoint_and_quasispectrumRestricts (A : Type u_1) (a : A) : 0 ≤ a ↔ IsSelfAdjoint a ∧ QuasispectrumRestricts a ⇑ContinuousMap.realToNNReal := by"
  },
  {
    "full_name": "MeasureTheory.Lp.norm_const",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "theorem MeasureTheory.Lp.norm_const (E : Type u_2) (c : E) (p : ℝ≥0∞) (α : Type u_1) (μ : Measure α) : ‖(Lp.const p μ) c‖ = ‖c‖ * (μ Set.univ).toReal ^ (1 / p.toReal) := by"
  },
  {
    "full_name": "MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto",
    "file_path": "Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean",
    "teorema": "lemma MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto (E : Type u_1) (a : ℝ) (f : ℝ → E) (m : E) : ∫ (x : ℝ) in Ioi a, f' x = m - f a := by"
  },
  {
    "full_name": "BoxIntegral.Box.measurableSet_coe",
    "file_path": "Mathlib/Analysis/BoxIntegral/Partition/Measure.lean",
    "teorema": "theorem BoxIntegral.Box.measurableSet_coe (I : Box ι) (ι : Type u_1) : MeasurableSet ↑I := by"
  },
  {
    "full_name": "Sum.lex_acc_inr",
    "file_path": ".lake/packages/batteries/Batteries/Data/Sum/Lemmas.lean",
    "teorema": "lemma Sum.lex_acc_inr (b : β✝) (r : α✝ → α✝ → Prop) (s : β✝ → β✝ → Prop) : Acc (Lex r s) (inr b) := by"
  },
  {
    "full_name": "Nat.bit0_val",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "teorema": "lemma Nat.bit0_val (n : ℕ) : n + n = 0 + n + n := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.densityProcess_fst_univ_ae",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
    "teorema": "theorem ProbabilityTheory.kernel.densityProcess_fst_univ_ae (a : α) (n : ℕ) (α : Type u_1) (β : Type u_2) (γ : Type u_3) (κ : ↥(kernel α (γ × β))) : ∀ᵐ (x : γ) ∂(fst κ) a, densityProcess κ (fst κ) n a x univ = 1 := by"
  },
  {
    "full_name": "TensorProduct.LieModule.liftLie_apply",
    "file_path": "Mathlib/Algebra/Lie/TensorProduct.lean",
    "teorema": "theorem TensorProduct.LieModule.liftLie_apply (L : Type v) (M : Type w) (N : Type w₁) (P : Type w₂) (R : Type u) (f : M →ₗ⁅R,L⁆ N →ₗ[R] P) (m : M) (n : N) : ((liftLie R L M N P) f) (m ⊗ₜ[R] n) = (f m) n := by"
  },
  {
    "full_name": "Rat.divInt_nonneg",
    "file_path": "Mathlib/Algebra/Order/Ring/Rat.lean",
    "teorema": "lemma Rat.divInt_nonneg (a : ℤ) (b : ℤ) : 0 ≤ a /. b := by"
  },
  {
    "full_name": "TotallyBounded.isSeparable",
    "file_path": "Mathlib/Topology/Metrizable/Uniformity.lean",
    "teorema": "lemma TotallyBounded.isSeparable (X : Type u_1) (s : Set X) : TopologicalSpace.IsSeparable s := by"
  },
  {
    "full_name": "FractionalIdeal.dual_inv",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Different.lean",
    "teorema": "lemma FractionalIdeal.dual_inv (A : Type u_1) (I : FractionalIdeal B⁰ L) (K : Type u_2) (L : Type u) : dual A K I⁻¹ = dual A K 1 * I := by"
  },
  {
    "full_name": "normEDS_three",
    "file_path": "Mathlib/NumberTheory/EllipticDivisibilitySequence.lean",
    "teorema": "theorem normEDS_three (R : Type u) (b : R) (c : R) (d : R) : normEDS b c d 3 = c := by"
  },
  {
    "full_name": "CategoryTheory.monoidalOfHasFiniteProducts.associator_hom_fst",
    "file_path": "Mathlib/CategoryTheory/Monoidal/OfHasFiniteProducts.lean",
    "teorema": "lemma CategoryTheory.monoidalOfHasFiniteProducts.associator_hom_fst (C : Type u) (X : C) (Y : C) (Z : C) : (α_ X Y Z).hom ≫ prod.fst = prod.fst ≫ prod.fst := by"
  },
  {
    "full_name": "Cardinal.cantor",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "theorem Cardinal.cantor (a : Cardinal.{u}) : a < 2 ^ a := by"
  },
  {
    "full_name": "Ideal.exists_comap_eq_of_mem_minimalPrimes",
    "file_path": "Mathlib/RingTheory/Ideal/MinimalPrime.lean",
    "teorema": "theorem Ideal.exists_comap_eq_of_mem_minimalPrimes (I : Ideal S) (R : Type u_1) (S : Type u_2) (f : R →+* S) (p : Ideal R) : ∃ p', p'.IsPrime ∧ I ≤ p' ∧ comap f p' = p := by"
  },
  {
    "full_name": "Polynomial.leadingCoeff_prod",
    "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
    "teorema": "lemma Polynomial.leadingCoeff_prod (R : Type u) (f : ι → R[X]) (s : Finset ι) (ι : Type w) : (∏ i ∈ s, f i).leadingCoeff = ∏ i ∈ s, (f i).leadingCoeff := by"
  },
  {
    "full_name": "CochainComplex.mappingCone.ext_cochain_to_iff",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/MappingCone.lean",
    "teorema": "theorem CochainComplex.mappingCone.ext_cochain_to_iff (C : Type u_1) (F : CochainComplex C ℤ) (G : CochainComplex C ℤ) (K : CochainComplex C ℤ) (hij : i + 1 = j) (i : ℤ) (j : ℤ) (γ₁ : Cochain K (mappingCone φ) i) (γ₂ : Cochain K (mappingCone φ) i) (φ : F ⟶ G) : γ₁ = γ₂ ↔ γ₁.comp (↑(fst φ)) hij = γ₂.comp (↑(fst φ)) hij ∧ γ₁.comp (snd φ) ⋯ = γ₂.comp (snd φ) ⋯ := by"
  },
  {
    "full_name": "Batteries.HashMap.Imp.Buckets.WF.update",
    "file_path": ".lake/packages/batteries/Batteries/Data/HashMap/WF.lean",
    "teorema": "theorem Batteries.HashMap.Imp.Buckets.WF.update (buckets : Buckets α β) (d : AssocList α β) (h : i.toNat < buckets.val.size) (i : USize) (α : Type u_1) (β : Type u_2) : (buckets.update i d h).WF := by"
  },
  {
    "full_name": "Prod.smul_mk_zero",
    "file_path": "Mathlib/GroupTheory/GroupAction/Prod.lean",
    "teorema": "lemma Prod.smul_mk_zero (M : Type u_1) (a : M) (b : α) (α : Type u_5) : a • (b, 0) = (a • b, 0) := by"
  },
  {
    "full_name": "Set.Ioc_union_Ioc_left",
    "file_path": "Mathlib/Order/Interval/Set/Basic.lean",
    "teorema": "theorem Set.Ioc_union_Ioc_left (a : α) (b : α) (c : α) (α : Type u_1) : Ioc a c ∪ Ioc b c = Ioc (min a b) c := by"
  },
  {
    "full_name": "Finset.sup_product_right",
    "file_path": "Mathlib/Data/Finset/Lattice.lean",
    "teorema": "lemma Finset.sup_product_right (f : β × γ → α) (s : Finset β) (t : Finset γ) (α : Type u_2) (β : Type u_3) (γ : Type u_4) : (s ×ˢ t).sup f = t.sup fun i' => s.sup fun i => f (i, i') := by"
  },
  {
    "full_name": "isSolvable_of_comm",
    "file_path": "Mathlib/GroupTheory/Solvable.lean",
    "teorema": "lemma isSolvable_of_comm (G : Type u_3) : IsSolvable G := by"
  },
  {
    "full_name": "hasDerivAt_mul_const",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean",
    "teorema": "theorem hasDerivAt_mul_const (c : 𝕜) (u : 𝕜 → 𝕜') (x : 𝕜) (𝕜 : Type u) : HasDerivAt (fun x => x * c) c x := by"
  },
  {
    "full_name": "Complex.arg_eq_nhds_of_re_neg_of_im_neg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean",
    "teorema": "lemma Complex.arg_eq_nhds_of_re_neg_of_im_neg (x : ℂ) : arg =ᶠ[𝓝 x] fun x => Real.arcsin ((-x).im / abs x) - π := by"
  },
  {
    "full_name": "CategoryTheory.InjectiveResolution.homotopyEquiv_hom_ι",
    "file_path": "Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean",
    "teorema": "lemma CategoryTheory.InjectiveResolution.homotopyEquiv_hom_ι (C : Type u) (I : InjectiveResolution X) (J : InjectiveResolution X) (X : C) : I.ι ≫ (I.homotopyEquiv J).hom = J.ι := by"
  },
  {
    "full_name": "Polynomial.mul_coeff_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Coeff.lean",
    "teorema": "theorem Polynomial.mul_coeff_zero (R : Type u) (p : R[X]) (q : R[X]) : (p * q).coeff 0 = p.coeff 0 * q.coeff 0 := by"
  },
  {
    "full_name": "Monotone.cauchySeq_alternating_series_of_tendsto_zero",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "lemma Monotone.cauchySeq_alternating_series_of_tendsto_zero (f : ℕ → ℝ) : CauchySeq fun n => ∑ i ∈ Finset.range n, (-1) ^ i * f i := by"
  },
  {
    "full_name": "MeasureTheory.restrict_trim",
    "file_path": "Mathlib/MeasureTheory/Measure/Trim.lean",
    "teorema": "theorem MeasureTheory.restrict_trim (hm : m ≤ m0) (m : MeasurableSpace α) (m0 : MeasurableSpace α) (s : Set α) (α : Type u_1) (μ : Measure α) : (μ.trim hm).restrict s = (μ.restrict s).trim hm := by"
  },
  {
    "full_name": "SecondCountableTopology.of_separableSpace_orderTopology",
    "file_path": "Mathlib/Topology/Order/Basic.lean",
    "teorema": "lemma SecondCountableTopology.of_separableSpace_orderTopology (α : Type u) : SecondCountableTopology α := by"
  },
  {
    "full_name": "Rat.add_def",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "lemma Rat.add_def (a : Rat) (b : Rat) : a + b = normalize (a.num * ↑b.den + b.num * ↑a.den) (a.den * b.den) ⋯ := by"
  },
  {
    "full_name": "of_quotient_center_nilpotent",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "teorema": "lemma of_quotient_center_nilpotent (G : Type u_1) : Group.IsNilpotent G := by"
  },
  {
    "full_name": "Metric.cthickening_closure",
    "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean",
    "teorema": "lemma Metric.cthickening_closure (s : Set α) (α : Type u) (δ : ℝ) : cthickening δ (closure s) = cthickening δ s := by"
  },
  {
    "full_name": "Real.Angle.cos_pi_div_two_sub",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "theorem Real.Angle.cos_pi_div_two_sub (θ : Angle) : (↑(π / 2) - θ).cos = θ.sin := by"
  },
  {
    "full_name": "Ideal.isMaximal_iff",
    "file_path": "Mathlib/RingTheory/Ideal/Basic.lean",
    "teorema": "lemma Ideal.isMaximal_iff (I : Ideal α) (J : Ideal α) (α : Type u) : I < J → J = ⊤ ↔ ∀ (x : α), I ≤ J → x ∉ I → x ∈ J → 1 ∈ J := by"
  },
  {
    "full_name": "RelIso.preimage_eq_image_symm",
    "file_path": "Mathlib/Order/RelIso/Set.lean",
    "teorema": "theorem RelIso.preimage_eq_image_symm (e : r ≃r s) (r : α → α → Prop) (s : β → β → Prop) (t : Set β) (α : Type u_5) (β : Type u_6) : ⇑e ⁻¹' t = ⇑e.symm '' t := by"
  },
  {
    "full_name": "MeasureTheory.Measure.singularPart_of_not_haveLebesgueDecomposition",
    "file_path": "Mathlib/MeasureTheory/Decomposition/Lebesgue.lean",
    "teorema": "lemma MeasureTheory.Measure.singularPart_of_not_haveLebesgueDecomposition (α : Type u_1) (μ : Measure α) (ν : Measure α) : μ.singularPart ν = 0 := by"
  },
  {
    "full_name": "ProbabilityTheory.cond_univ",
    "file_path": "Mathlib/Probability/ConditionalProbability.lean",
    "teorema": "theorem ProbabilityTheory.cond_univ (Ω : Type u_1) (μ : Measure Ω) : μ[|univ] = μ := by"
  },
  {
    "full_name": "AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_fst_snd",
    "file_path": "Mathlib/AlgebraicGeometry/Gluing.lean",
    "teorema": "theorem AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_fst_snd (X : Scheme) (x : 𝒰.J) (y : 𝒰.J) (z : 𝒰.J) (𝒰 : X.OpenCover) : 𝒰.gluedCoverT' x y z ≫ pullback.fst ≫ pullback.snd = pullback.snd ≫ pullback.snd := by"
  },
  {
    "full_name": "MeasurableSet.cond",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
    "teorema": "lemma MeasurableSet.cond (i : Bool) (s₁ : Set α) (s₂ : Set α) (α : Type u_1) : MeasurableSet (bif i then s₁ else s₂) := by"
  }
]