[
  {
    "full_name": "WithLp.prod_nnnorm_eq_add",
    "file_path": "Mathlib/Analysis/NormedSpace/ProdLp.lean",
    "teorema": "lemma WithLp.prod_nnnorm_eq_add (f : WithLp p (Œ± √ó Œ≤)) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_2) (Œ≤ : Type u_3) : ‚Äñf‚Äñ‚Çä = (‚Äñf.1‚Äñ‚Çä ^ p.toReal + ‚Äñf.2‚Äñ‚Çä ^ p.toReal) ^ (1 / p.toReal) := by"
  },
  {
    "full_name": "CategoryTheory.ShortComplex.isIso‚ÇÇ_of_shortExact_of_isIso‚ÇÅ‚ÇÉ",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/ShortExact.lean",
    "teorema": "lemma CategoryTheory.ShortComplex.isIso‚ÇÇ_of_shortExact_of_isIso‚ÇÅ‚ÇÉ (C : Type u_1) (S‚ÇÅ : ShortComplex C) (S‚ÇÇ : ShortComplex C) (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) : IsIso œÜ.œÑ‚ÇÇ := by"
  },
  {
    "full_name": "nhdsWithin_pi_univ_eq",
    "file_path": "Mathlib/Topology/ContinuousOn.lean",
    "teorema": "lemma nhdsWithin_pi_univ_eq (s : (i : Œπ) ‚Üí Set (œÄ i)) (x : (i : Œπ) ‚Üí œÄ i) (Œπ : Type u_5) (œÄ : Œπ ‚Üí Type u_6) : ùìù[univ.pi s] x = ‚®Ö i, comap (fun x => x i) (ùìù[s i] x i) := by"
  },
  {
    "full_name": "mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt",
    "file_path": "Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean",
    "teorema": "lemma mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (B : PowerBasis K L) (K : Type v) (L : Type z) (R : Type u) (z : L) : z ‚àà adjoin R {B.gen} := by"
  },
  {
    "full_name": "MvPolynomial.degrees_map_of_injective",
    "file_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
    "teorema": "theorem MvPolynomial.degrees_map_of_injective (R : Type u) (S : Type v) (f : R ‚Üí+* S) (p : MvPolynomial œÉ R) (œÉ : Type u_1) : ((map f) p).degrees = p.degrees := by"
  },
  {
    "full_name": "CategoryTheory.ShortComplex.SnakeInput.w‚ÇÅ‚ÇÉ_œÑ‚ÇÅ",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/SnakeLemma.lean",
    "teorema": "lemma CategoryTheory.ShortComplex.SnakeInput.w‚ÇÅ‚ÇÉ_œÑ‚ÇÅ (C : Type u_1) (S : SnakeInput C) : S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÅ ‚â´ S.v‚ÇÇ‚ÇÉ.œÑ‚ÇÅ = 0 := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_nnnorm_condexpL2_le",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL2.lean",
    "teorema": "theorem MeasureTheory.lintegral_nnnorm_condexpL2_le (f : ‚Ü•(Lp ‚Ñù 2 Œº)) (hm : m ‚â§ m0) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±) in s, ‚Üë‚Äñ‚Üë‚Üë‚Üë((condexpL2 ‚Ñù ‚Ñù hm) f) x‚Äñ‚Çä ‚àÇŒº ‚â§ ‚à´‚Åª (x : Œ±) in s, ‚Üë‚Äñ‚Üë‚Üëf x‚Äñ‚Çä ‚àÇŒº := by"
  },
  {
    "full_name": "CliffordAlgebra.star_smul",
    "file_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Star.lean",
    "teorema": "lemma CliffordAlgebra.star_smul (M : Type u_2) (Q : QuadraticForm R M) (R : Type u_1) (r : R) (x : CliffordAlgebra Q) : star (r ‚Ä¢ x) = r ‚Ä¢ star x := by"
  },
  {
    "full_name": "LieSubmodule.coe_toSubmodule_mk",
    "file_path": "Mathlib/Algebra/Lie/Submodule.lean",
    "teorema": "lemma LieSubmodule.coe_toSubmodule_mk (L : Type v) (M : Type w) (R : Type u) (h : ‚àÄ {x : L} {m : M}, m ‚àà p.carrier ‚Üí ‚ÅÖx, m‚ÅÜ ‚àà p.carrier) (p : Submodule R M) : ‚Üë{ toSubmodule := p, lie_mem := h } = p := by"
  },
  {
    "full_name": "Complex.abs_im_div_abs_le_one",
    "file_path": "Mathlib/Data/Complex/Abs.lean",
    "teorema": "lemma Complex.abs_im_div_abs_le_one (z : ‚ÑÇ) : |z.im / abs z| ‚â§ 1 := by"
  },
  {
    "full_name": "NumberField.InfinitePlace.not_isReal_iff_isComplex",
    "file_path": "Mathlib/NumberTheory/NumberField/Embeddings.lean",
    "teorema": "theorem NumberField.InfinitePlace.not_isReal_iff_isComplex (K : Type u_2) (w : InfinitePlace K) : ¬¨w.IsReal ‚Üî w.IsComplex := by"
  },
  {
    "full_name": "smul_finsum",
    "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean",
    "teorema": "lemma smul_finsum (M : Type u_8) (R : Type u_7) (c : R) (f : Œπ ‚Üí M) (Œπ : Sort u_6) : c ‚Ä¢ ‚àë·∂† (i : Œπ), f i = ‚àë·∂† (i : Œπ), c ‚Ä¢ f i := by"
  },
  {
    "full_name": "MeasureTheory.tilted_apply_eq_ofReal_integral",
    "file_path": "Mathlib/MeasureTheory/Measure/Tilted.lean",
    "teorema": "theorem MeasureTheory.tilted_apply_eq_ofReal_integral (f : Œ± ‚Üí ‚Ñù) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (Œº.tilted f) s = ENNReal.ofReal (‚à´ (a : Œ±) in s, rexp (f a) / ‚à´ (x : Œ±), rexp (f x) ‚àÇŒº ‚àÇŒº) := by"
  },
  {
    "full_name": "nilpotencyClass_prod",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "teorema": "lemma nilpotencyClass_prod (G‚ÇÅ : Type u_2) (G‚ÇÇ : Type u_3) : Group.nilpotencyClass (G‚ÇÅ √ó G‚ÇÇ) = max (Group.nilpotencyClass G‚ÇÅ) (Group.nilpotencyClass G‚ÇÇ) := by"
  },
  {
    "full_name": "Ideal.fg_ker_comp",
    "file_path": "Mathlib/RingTheory/Finiteness.lean",
    "teorema": "theorem Ideal.fg_ker_comp (A : Type u_5) (R : Type u_3) (S : Type u_4) (f : R ‚Üí+* S) (g : S ‚Üí+* A) : (RingHom.ker (g.comp f)).FG := by"
  },
  {
    "full_name": "GromovHausdorff.one_le_maxVar",
    "file_path": "Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean",
    "teorema": "lemma GromovHausdorff.one_le_maxVar : 1 = 2 * 0 + 1 + 2 * 0 := by"
  },
  {
    "full_name": "sup_right_comm",
    "file_path": "Mathlib/Order/Lattice.lean",
    "teorema": "lemma sup_right_comm (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u) : a ‚äî b ‚äî c = a ‚äî c ‚äî b := by"
  },
  {
    "full_name": "Polynomial.lt_natDegree_of_mem_eraseLead_support",
    "file_path": "Mathlib/Algebra/Polynomial/EraseLead.lean",
    "teorema": "lemma Polynomial.lt_natDegree_of_mem_eraseLead_support (R : Type u_1) (a : ‚Ñï) (f : R[X]) : a < f.natDegree := by"
  },
  {
    "full_name": "CategoryTheory.ShortComplex.Exact.moduleCat_of_range_eq_ker",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/ModuleCat.lean",
    "teorema": "lemma CategoryTheory.ShortComplex.Exact.moduleCat_of_range_eq_ker (R : Type u) (X‚ÇÅ : ModuleCat R) (X‚ÇÇ : ModuleCat R) (X‚ÇÉ : ModuleCat R) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : X‚ÇÇ ‚ü∂ X‚ÇÉ) : LinearMap.range f ‚â§ LinearMap.ker g := by"
  },
  {
    "full_name": "eval‚ÇÇ_minpolyDiv_of_eval‚ÇÇ_eq_zero",
    "file_path": "Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean",
    "teorema": "lemma eval‚ÇÇ_minpolyDiv_of_eval‚ÇÇ_eq_zero (R : Type u_3) (S : Type u_2) (T : Type u_1) (x : S) (y : T) (œÉ : S ‚Üí+* T) : eval‚ÇÇ œÉ y (minpolyDiv R x) = if œÉ x = y then œÉ ((aeval x) (derivative (minpoly R x))) else 0 := by"
  },
  {
    "full_name": "MeasureTheory.SignedMeasure.toJordanDecomposition_eq",
    "file_path": "Mathlib/MeasureTheory/Decomposition/Jordan.lean",
    "teorema": "lemma MeasureTheory.SignedMeasure.toJordanDecomposition_eq (j : JordanDecomposition Œ±) (s : SignedMeasure Œ±) (Œ± : Type u_1) : s.toJordanDecomposition = j := by"
  },
  {
    "full_name": "mul_invOf_mul_self_cancel",
    "file_path": "Mathlib/Algebra/Group/Invertible/Defs.lean",
    "teorema": "theorem mul_invOf_mul_self_cancel (a : Œ±) (b : Œ±) (Œ± : Type u) : a * ‚Öüb * b = a := by"
  },
  {
    "full_name": "spectrum.singleton_add_eq",
    "file_path": "Mathlib/Algebra/Algebra/Spectrum.lean",
    "teorema": "lemma spectrum.singleton_add_eq (A : Type v) (R : Type u) (a : A) (r : R) (x : R) : x ‚àà {r} + œÉ a ‚Üî x ‚àà œÉ (‚Üë‚Çê r + a) := by"
  },
  {
    "full_name": "Monoid.CoprodI.NeWord.inv_head",
    "file_path": "Mathlib/GroupTheory/CoprodI.lean",
    "teorema": "lemma Monoid.CoprodI.NeWord.inv_head (G : Œπ ‚Üí Type u_4) (i : Œπ) (j : Œπ) (w : NeWord G i j) (Œπ : Type u_1) : w.inv.head = w.last‚Åª¬π := by"
  },
  {
    "full_name": "MonotoneOn.integral_le_sum_Ico",
    "file_path": "Mathlib/Analysis/SumIntegralComparisons.lean",
    "teorema": "lemma MonotoneOn.integral_le_sum_Ico (a : ‚Ñï) (b : ‚Ñï) (f : ‚Ñù ‚Üí ‚Ñù) : ‚à´ (x : ‚Ñù) in ‚Üëa..‚Üëb, f x ‚â§ ‚àë i ‚àà Finset.Ico a b, f ‚Üë(i + 1) := by"
  },
  {
    "full_name": "Urysohns.CU.continuous_lim",
    "file_path": "Mathlib/Topology/UrysohnsLemma.lean",
    "teorema": "lemma Urysohns.CU.continuous_lim (P : Set X ‚Üí Prop) (X : Type u_1) (c : CU P) : Continuous c.lim := by"
  },
  {
    "full_name": "Bornology.IsVonNBounded.image_multilinear",
    "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Bounded.lean",
    "teorema": "lemma Bornology.IsVonNBounded.image_multilinear (E : Œπ ‚Üí Type u_4) (F : Type u_3) (f : ContinuousMultilinearMap ùïú E F) (s : Set ((i : Œπ) ‚Üí E i)) (Œπ : Type u_1) (ùïú : Type u_2) : IsVonNBounded ùïú (‚áëf '' s) := by"
  },
  {
    "full_name": "exists_prime_addOrderOf_dvd_card",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean",
    "teorema": "lemma exists_prime_addOrderOf_dvd_card (G : Type u_3) (p : ‚Ñï) : p ‚à£ Fintype.card (Multiplicative G) := by"
  },
  {
    "full_name": "MeasureTheory.ext_of_forall_lintegral_eq_of_IsFiniteMeasure",
    "file_path": "Mathlib/MeasureTheory/Measure/HasOuterApproxClosed.lean",
    "teorema": "theorem MeasureTheory.ext_of_forall_lintegral_eq_of_IsFiniteMeasure (Œ© : Type u_1) (Œº : Measure Œ©) (ŒΩ : Measure Œ©) : Œº = ŒΩ := by"
  },
  {
    "full_name": "Ideal.eq_jacobson_iff_not_mem",
    "file_path": "Mathlib/RingTheory/JacobsonIdeal.lean",
    "teorema": "lemma Ideal.eq_jacobson_iff_not_mem (I : Ideal R) (R : Type u) : I.jacobson = I ‚Üî ‚àÄ x ‚àâ I, ‚àÉ M, (I ‚â§ M ‚àß M.IsMaximal) ‚àß x ‚àâ M := by"
  },
  {
    "full_name": "Ideal.isCompactElement_top",
    "file_path": "Mathlib/RingTheory/Ideal/Basic.lean",
    "teorema": "theorem Ideal.isCompactElement_top : CompleteLattice.IsCompactElement ‚ä§ := by"
  },
  {
    "full_name": "gc_exterior_interior",
    "file_path": "Mathlib/Topology/AlexandrovDiscrete.lean",
    "teorema": "lemma gc_exterior_interior (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_3) : exterior s ‚â§ t ‚Üî s ‚â§ interior t := by"
  },
  {
    "full_name": "Real.hasDerivAt_fourierChar",
    "file_path": "Mathlib/Analysis/Fourier/FourierTransformDeriv.lean",
    "teorema": "theorem Real.hasDerivAt_fourierChar (x : ‚Ñù) : HasDerivAt (fun x => ‚Üë(ùêû x)) (2 * ‚ÜëœÄ * I * ‚Üë(ùêû x)) x := by"
  },
  {
    "full_name": "Disjoint.left_le_of_le_sup_left",
    "file_path": "Mathlib/Order/Disjoint.lean",
    "teorema": "lemma Disjoint.left_le_of_le_sup_left (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : a ‚â§ b ‚äî c := by"
  },
  {
    "full_name": "contDiff_clm_apply_iff",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/FiniteDimension.lean",
    "teorema": "theorem contDiff_clm_apply_iff (E : Type uE) (F : Type uF) (G : Type uG) (f : E ‚Üí F ‚ÜíL[ùïú] G) (n : ‚Ñï‚àû) (ùïú : Type u_1) : ContDiff ùïú n f ‚Üî ‚àÄ (y : F), ContDiff ùïú n fun x => (f x) y := by"
  },
  {
    "full_name": "Finmap.mem_list_toFinmap",
    "file_path": "Mathlib/Data/Finmap.lean",
    "teorema": "lemma Finmap.mem_list_toFinmap (a : Œ±) (xs : List (Sigma Œ≤)) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) : a ‚àà xs.toFinmap ‚Üî ‚àÉ b, ‚ü®a, b‚ü© ‚àà xs := by"
  },
  {
    "full_name": "PartialEquiv.transEquiv_transEquiv",
    "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean",
    "teorema": "lemma PartialEquiv.transEquiv_transEquiv (e : PartialEquiv Œ± Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (e.transEquiv f').transEquiv f'' = e.transEquiv (f'.trans f'') := by"
  },
  {
    "full_name": "groupCohomology.H1LequivOfIsTrivial_comp_H1_œÄ",
    "file_path": "Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean",
    "teorema": "theorem groupCohomology.H1LequivOfIsTrivial_comp_H1_œÄ (A : Rep k G) (G : Type u) (k : Type u) : ‚Üë(H1LequivOfIsTrivial A) ‚àò‚Çó H1_œÄ A = ‚Üë(oneCocyclesLequivOfIsTrivial A) := by"
  },
  {
    "full_name": "NonUnitalAlgebra.mem_iInf",
    "file_path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean",
    "teorema": "theorem NonUnitalAlgebra.mem_iInf (A : Type v) (R : Type u) (S : Œπ ‚Üí NonUnitalSubalgebra R A) (x : A) (Œπ : Sort u_2) : x ‚àà ‚®Ö i, S i ‚Üî ‚àÄ (i : Œπ), x ‚àà S i := by"
  },
  {
    "full_name": "Fin.map_valEmbedding_Iic",
    "file_path": "Mathlib/Order/Interval/Finset/Fin.lean",
    "teorema": "theorem Fin.map_valEmbedding_Iic (b : Fin n) (n : ‚Ñï) : map valEmbedding (Iic b) = Iic ‚Üëb := by"
  },
  {
    "full_name": "Submodule.le_traceDual_mul_iff",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Different.lean",
    "teorema": "lemma Submodule.le_traceDual_mul_iff (B : Type u_3) (I : Submodule B L) (J : Submodule B L) (J' : Submodule B L) (L : Type u) : I ‚â§ (J * J')·µõ ‚Üî I * J ‚â§ J'·µõ := by"
  },
  {
    "full_name": "multiplicity.multiplicity_eq_zero",
    "file_path": "Mathlib/RingTheory/Multiplicity.lean",
    "teorema": "lemma multiplicity.multiplicity_eq_zero (a : Œ±) (b : Œ±) (Œ± : Type u_1) : multiplicity a b = 0 ‚Üî ¬¨a ‚à£ b := by"
  },
  {
    "full_name": "Function.Periodic.image_uIcc",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "lemma Function.Periodic.image_uIcc (a : Œ±) (c : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : f '' uIcc a (a + c) = range f := by"
  },
  {
    "full_name": "Matroid.Restriction.finite",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "teorema": "theorem Matroid.Restriction.finite (N : Matroid Œ±) (Œ± : Type u_1) : N.Finite := by"
  },
  {
    "full_name": "CategoryTheory.FreeBicategory.normalize_naturality",
    "file_path": "Mathlib/CategoryTheory/Bicategory/Coherence.lean",
    "teorema": "lemma CategoryTheory.FreeBicategory.normalize_naturality (B : Type u) (a : B) (b : B) (c : B) (f : Hom b c) (g : Hom b c) (p : Path a b) (Œ∑ : f ‚ü∂ g) : (‚Üë(preinclusion B)).map { as := p } ‚óÅ Œ∑ ‚â´ (normalizeIso p g).hom = (normalizeIso p f).hom ‚â´ (preinclusion B).map‚ÇÇ (eqToHom ‚ãØ) := by"
  },
  {
    "full_name": "PMF.toMeasure_apply_eq_zero_iff",
    "file_path": "Mathlib/Probability/ProbabilityMassFunction/Basic.lean",
    "teorema": "theorem PMF.toMeasure_apply_eq_zero_iff (p : PMF Œ±) (s : Set Œ±) (Œ± : Type u_1) : p.toMeasure s = 0 ‚Üî Disjoint p.support s := by"
  },
  {
    "full_name": "PiNat.cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff",
    "file_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
    "teorema": "theorem PiNat.cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff (E : ‚Ñï ‚Üí Type u_1) (s : Set ((n : ‚Ñï) ‚Üí E n)) (x : (n : ‚Ñï) ‚Üí E n) (y : (n : ‚Ñï) ‚Üí E n) : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by"
  },
  {
    "full_name": "RCLike.inv_re",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "theorem RCLike.inv_re (K : Type u_1) (z : K) : re z‚Åª¬π = re z / normSq z := by"
  },
  {
    "full_name": "Ordnode.size_balance'",
    "file_path": "Mathlib/Data/Ordmap/Ordset.lean",
    "teorema": "theorem Ordnode.size_balance' (l : Ordnode Œ±) (r : Ordnode Œ±) (x : Œ±) (Œ± : Type u_1) : (l.balance' x r).size = l.size + r.size + 1 := by"
  },
  {
    "full_name": "CategoryTheory.Limits.colimit_obj_ext",
    "file_path": "Mathlib/CategoryTheory/Limits/FunctorCategory.lean",
    "teorema": "theorem CategoryTheory.Limits.colimit_obj_ext (C : Type u) (H : J ‚•§ K ‚•§ C) (J : Type u‚ÇÅ) (K : Type u‚ÇÇ) (W : C) (f : (colimit H).obj k ‚ü∂ W) (g : (colimit H).obj k ‚ü∂ W) (k : K) : f = g := by"
  },
  {
    "full_name": "MeasureTheory.Measure.toENNRealVectorMeasure_ennrealToMeasure",
    "file_path": "Mathlib/MeasureTheory/Measure/VectorMeasure.lean",
    "teorema": "lemma MeasureTheory.Measure.toENNRealVectorMeasure_ennrealToMeasure (s : Set Œ±) (Œ± : Type u_1) (Œº : VectorMeasure Œ± ‚Ñù‚â•0‚àû) : ‚ÜëŒº.ennrealToMeasure.toENNRealVectorMeasure s = ‚ÜëŒº s := by"
  },
  {
    "full_name": "zero_le_four",
    "file_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean",
    "teorema": "theorem zero_le_four : 0 ‚â§ 4 := by"
  },
  {
    "full_name": "tsum_mul_tsum_eq_tsum_sum_range",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean",
    "teorema": "lemma tsum_mul_tsum_eq_tsum_sum_range (f : ‚Ñï ‚Üí Œ±) (g : ‚Ñï ‚Üí Œ±) (Œ± : Type u_4) : (‚àë' (n : ‚Ñï), f n) * ‚àë' (n : ‚Ñï), g n = ‚àë' (n : ‚Ñï), ‚àë k ‚àà range (n + 1), f k * g (n - k) := by"
  },
  {
    "full_name": "Irrational.sub_rat",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "lemma Irrational.sub_rat (q : ‚Ñö) (x : ‚Ñù) : Irrational (x - ‚Üëq) := by"
  },
  {
    "full_name": "NormedField.tendsto_zero_smul_of_tendsto_zero_of_bounded",
    "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean",
    "teorema": "theorem NormedField.tendsto_zero_smul_of_tendsto_zero_of_bounded (f : Œπ ‚Üí ùî∏) (l : Filter Œπ) (Œµ : Œπ ‚Üí ùïú) (Œπ : Type u_4) (ùî∏ : Type u_6) (ùïú : Type u_5) : Tendsto (Œµ ‚Ä¢ f) l (ùìù 0) := by"
  },
  {
    "full_name": "hasSum_geometric_two'",
    "file_path": "Mathlib/Analysis/SpecificLimits/Basic.lean",
    "teorema": "lemma hasSum_geometric_two' (a : ‚Ñù) : HasSum (fun n => a / 2 / 2 ^ n) a := by"
  },
  {
    "full_name": "Seminorm.closedBall_add_closedBall_subset",
    "file_path": "Mathlib/Analysis/Seminorm.lean",
    "teorema": "lemma Seminorm.closedBall_add_closedBall_subset (E : Type u_7) (p : Seminorm ùïú E) (r‚ÇÅ : ‚Ñù) (r‚ÇÇ : ‚Ñù) (x‚ÇÅ : E) (x‚ÇÇ : E) (ùïú : Type u_3) : p.closedBall x‚ÇÅ r‚ÇÅ + p.closedBall x‚ÇÇ r‚ÇÇ ‚äÜ p.closedBall (x‚ÇÅ + x‚ÇÇ) (r‚ÇÅ + r‚ÇÇ) := by"
  },
  {
    "full_name": "Ordering.then_eq_lt",
    "file_path": ".lake/packages/batteries/Batteries/Classes/Order.lean",
    "teorema": "theorem Ordering.then_eq_lt (o‚ÇÅ : Ordering) (o‚ÇÇ : Ordering) : o‚ÇÅ.then o‚ÇÇ = lt ‚Üî o‚ÇÅ = lt ‚à® o‚ÇÅ = eq ‚àß o‚ÇÇ = lt := by"
  },
  {
    "full_name": "MeasureTheory.condexpL1CLM_lpMeas",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean",
    "teorema": "lemma MeasureTheory.condexpL1CLM_lpMeas (F : Type u_3) (f : ‚Ü•(lpMeas F' ‚Ñù m 1 Œº)) (hm : m ‚â§ m0) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (condexpL1CLM F' hm Œº) ‚Üëf = ‚Üëf := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.withDensity·µ•_trim_absolutelyContinuous",
    "file_path": "Mathlib/MeasureTheory/Measure/WithDensityVectorMeasure.lean",
    "teorema": "theorem MeasureTheory.Integrable.withDensity·µ•_trim_absolutelyContinuous (E : Type u_3) (f : Œ± ‚Üí E) (hm : m ‚â§ m0) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (Œº.withDensity·µ• f).trim hm ‚â™·µ• (Œº.trim hm).toENNRealVectorMeasure := by"
  },
  {
    "full_name": "IsCoprime.mul_left",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "teorema": "theorem IsCoprime.mul_left (R : Type u) (a : R) (b : R) (c : R) (d : R) (x : R) (y : R) (z : R) : a * c * (x * y) + (a * x * d + b * c * y + b * d * z) * z = (a * x + b * z) * (c * y + d * z) := by"
  },
  {
    "full_name": "Filter.Tendsto.atBot_mul_neg",
    "file_path": "Mathlib/Topology/Algebra/Order/Field.lean",
    "teorema": "theorem Filter.Tendsto.atBot_mul_neg (f : Œ± ‚Üí ùïú) (g : Œ± ‚Üí ùïú) (l : Filter Œ±) (Œ± : Type u_2) (ùïú : Type u_1) : Tendsto (fun x => f x * g x) l atTop := by"
  },
  {
    "full_name": "Tactic.ReduceModChar.CharP.intCast_eq_mod",
    "file_path": "Mathlib/Tactic/ReduceModChar.lean",
    "teorema": "theorem Tactic.ReduceModChar.CharP.intCast_eq_mod (k : ‚Ñ§) (p : ‚Ñï) : ‚Üëk = ‚Üë(k % ‚Üëp) := by"
  },
  {
    "full_name": "Fermat42.coprime_of_minimal",
    "file_path": "Mathlib/NumberTheory/FLT/Four.lean",
    "teorema": "lemma Fermat42.coprime_of_minimal (a : ‚Ñ§) (b : ‚Ñ§) : IsCoprime a b := by"
  },
  {
    "full_name": "CategoryTheory.OverPresheafAux.counitForward_naturality‚ÇÇ",
    "file_path": "Mathlib/CategoryTheory/Comma/Presheaf.lean",
    "teorema": "lemma CategoryTheory.OverPresheafAux.counitForward_naturality‚ÇÇ (A : C·µí·µñ ‚•§ Type v) (f : t ‚ü∂ s) (s : (CostructuredArrow yoneda A)·µí·µñ) (t : (CostructuredArrow yoneda A)·µí·µñ) : yoneda.map f.unop.left ‚â´ t.unop.hom = s.unop.hom := by"
  },
  {
    "full_name": "Nat.minFac_has_prop",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "lemma Nat.minFac_has_prop (n : ‚Ñï) : Nat.minFacProp n n.minFac := by"
  },
  {
    "full_name": "MeasureTheory.snorm'_mono_nnnorm_ae",
    "file_path": "Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean",
    "teorema": "theorem MeasureTheory.snorm'_mono_nnnorm_ae (F : Type u_3) (G : Type u_4) (f : Œ± ‚Üí F) (g : Œ± ‚Üí G) (q : ‚Ñù) (Œ± : Type u_1) (Œº : Measure Œ±) : snorm' f q Œº ‚â§ snorm' g q Œº := by"
  },
  {
    "full_name": "HasDerivAt.iterate",
    "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean",
    "teorema": "theorem HasDerivAt.iterate (f : ùïú ‚Üí ùïú) (x : ùïú) (ùïú : Type u) : Tendsto f (ùìù x) (ùìù x) := by"
  },
  {
    "full_name": "continuous_iSup_dom",
    "file_path": "Mathlib/Topology/Order.lean",
    "teorema": "lemma continuous_iSup_dom (f : Œ± ‚Üí Œ≤) (Œ± : Type u) (Œ≤ : Type v) (Œπ : Sort u_2) : Continuous f ‚Üî ‚àÄ (i : Œπ), Continuous f := by"
  },
  {
    "full_name": "closure_diff_frontier",
    "file_path": "Mathlib/Topology/Basic.lean",
    "teorema": "lemma closure_diff_frontier (X : Type u) (s : Set X) : closure s \\ frontier s = interior s := by"
  },
  {
    "full_name": "simply_connected_iff_paths_homotopic",
    "file_path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean",
    "teorema": "theorem simply_connected_iff_paths_homotopic (Y : Type u_1) : SimplyConnectedSpace Y ‚Üí PathConnectedSpace Y ‚àß ‚àÄ (x y : Y), Subsingleton (Path.Homotopic.Quotient x y) := by"
  },
  {
    "full_name": "List.lookupAll_length_le_one",
    "file_path": "Mathlib/Data/List/Sigma.lean",
    "teorema": "lemma List.lookupAll_length_le_one (a : Œ±) (l : List (Sigma Œ≤)) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) : (lookupAll a l).length ‚â§ 1 := by"
  },
  {
    "full_name": "ModularGroup.abs_c_le_one",
    "file_path": "Mathlib/NumberTheory/Modular.lean",
    "teorema": "lemma ModularGroup.abs_c_le_one (g : SL(2, ‚Ñ§)) : |‚Üëg 1 0| ‚â§ 1 := by"
  },
  {
    "full_name": "Ordinal.eq_zero_or_opow_omega_le_of_mul_eq_right",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "teorema": "theorem Ordinal.eq_zero_or_opow_omega_le_of_mul_eq_right (a : Ordinal.{u}) (b : Ordinal.{u}) : b = 0 ‚à® a ^ œâ ‚â§ b := by"
  },
  {
    "full_name": "Multiset.mem_nsmul",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.mem_nsmul (a : Œ±) (n : ‚Ñï) (s : Multiset Œ±) (Œ± : Type u_1) : a ‚àà n ‚Ä¢ s ‚Üî a ‚àà s := by"
  },
  {
    "full_name": "IntervalIntegrable.iff_comp_neg",
    "file_path": "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean",
    "teorema": "lemma IntervalIntegrable.iff_comp_neg (E : Type u_3) (a : ‚Ñù) (b : ‚Ñù) (f : ‚Ñù ‚Üí E) : IntervalIntegrable f volume a b ‚Üî IntervalIntegrable (fun x => f (-x)) volume (-a) (-b) := by"
  },
  {
    "full_name": "Nat.Partrec.Code.const_inj",
    "file_path": "Mathlib/Computability/PartrecCode.lean",
    "teorema": "theorem Nat.Partrec.Code.const_inj : 0 = 0 := by"
  },
  {
    "full_name": "SchwartzMap.tsum_eq_tsum_fourierIntegral",
    "file_path": "Mathlib/Analysis/Fourier/PoissonSummation.lean",
    "teorema": "theorem SchwartzMap.tsum_eq_tsum_fourierIntegral (f : ùì¢(‚Ñù, ‚ÑÇ)) (g : ùì¢(‚Ñù, ‚ÑÇ)) (x : ‚Ñù) : ‚àë' (n : ‚Ñ§), f (x + ‚Üën) = ‚àë' (n : ‚Ñ§), g ‚Üën * (fourier n) ‚Üëx := by"
  },
  {
    "full_name": "MeasureTheory.ae_const_le_iff_forall_lt_measure_zero",
    "file_path": "Mathlib/MeasureTheory/Function/AEEqOfIntegral.lean",
    "teorema": "lemma MeasureTheory.ae_const_le_iff_forall_lt_measure_zero (c : Œ≤) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_3) (Œº : Measure Œ±) : (‚àÄ·µê (x : Œ±) ‚àÇŒº, c ‚â§ f x) ‚Üî ‚àÄ b < c, Œº {x | f x ‚â§ b} = 0 := by"
  },
  {
    "full_name": "MeasureTheory.Lp.snorm_lim_le_liminf_snorm",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "theorem MeasureTheory.Lp.snorm_lim_le_liminf_snorm (E : Type u_5) (f : ‚Ñï ‚Üí Œ± ‚Üí E) (f_lim : Œ± ‚Üí E) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : snorm f_lim p Œº ‚â§ liminf (fun n => snorm (f n) p Œº) atTop := by"
  },
  {
    "full_name": "FixedPoints.minpoly.irreducible_aux",
    "file_path": "Mathlib/FieldTheory/Fixed.lean",
    "teorema": "theorem FixedPoints.minpoly.irreducible_aux (F : Type v) (G : Type u) (f : Polynomial ‚Ü•(subfield G F)) (g : Polynomial ‚Ü•(subfield G F)) : f = 1 ‚à® g = 1 := by"
  },
  {
    "full_name": "List.Nodup.insert",
    "file_path": "Mathlib/Data/List/Nodup.lean",
    "teorema": "theorem List.Nodup.insert (a : Œ±) (l : List Œ±) (Œ± : Type u) : (List.insert a l).Nodup := by"
  },
  {
    "full_name": "singleton_span_mem_normalizedFactors_of_mem_normalizedFactors",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Ideal.lean",
    "teorema": "theorem singleton_span_mem_normalizedFactors_of_mem_normalizedFactors (R : Type u_1) (a : R) (b : R) : span {a} ‚àà normalizedFactors (span {b}) := by"
  },
  {
    "full_name": "List.splitOnP_cons",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "theorem List.splitOnP_cons (p : Œ± ‚Üí Bool) (x : Œ±) (xs : List Œ±) (Œ± : Type u) : splitOnP p (x :: xs) = if p x = true then [] :: splitOnP p xs else modifyHead (cons x) (splitOnP p xs) := by"
  },
  {
    "full_name": "continuous_multiset_prod",
    "file_path": "Mathlib/Topology/Algebra/Monoid.lean",
    "teorema": "theorem continuous_multiset_prod (M : Type u_3) (X : Type u_5) (f : Œπ ‚Üí X ‚Üí M) (s : Multiset Œπ) (Œπ : Type u_1) : (‚àÄ i ‚àà s, Continuous (f i)) ‚Üí Continuous fun a => (Multiset.map (fun i => f i a) s).prod := by"
  },
  {
    "full_name": "Real.volume_univ",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean",
    "teorema": "lemma Real.volume_univ (r : ‚Ñù‚â•0) : ‚Üër = volume (Icc 0 ‚Üër) := by"
  },
  {
    "full_name": "Matrix.IsHermitian.adjugate",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Hermitian.lean",
    "teorema": "lemma Matrix.IsHermitian.adjugate (A : Matrix m m Œ±) (m : Type u_3) (Œ± : Type u_1) : A.adjugate.IsHermitian := by"
  },
  {
    "full_name": "Nat.filter_multiset_Ico_card_eq_of_periodic",
    "file_path": "Mathlib/Data/Nat/Periodic.lean",
    "teorema": "lemma Nat.filter_multiset_Ico_card_eq_of_periodic (a : ‚Ñï) (n : ‚Ñï) (p : ‚Ñï ‚Üí Prop) : card (filter p (Ico n (n + a))) = count p a := by"
  },
  {
    "full_name": "Polynomial.coeff_mul_mirror",
    "file_path": "Mathlib/Algebra/Polynomial/Mirror.lean",
    "teorema": "theorem Polynomial.coeff_mul_mirror (R : Type u_1) (p : R[X]) : (p * p.mirror).coeff (p.natDegree + p.natTrailingDegree) = p.sum fun n x => x ^ 2 := by"
  },
  {
    "full_name": "even_two",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "lemma even_two : 2 = 1 + 1 := by"
  },
  {
    "full_name": "Submodule.convex",
    "file_path": "Mathlib/Analysis/Convex/Basic.lean",
    "teorema": "lemma Submodule.convex (E : Type u_2) (K : Submodule ùïú E) (ùïú : Type u_1) : Convex ùïú ‚ÜëK := by"
  },
  {
    "full_name": "Int.natCast_nonpos_iff",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "teorema": "lemma Int.natCast_nonpos_iff (n : ‚Ñï) : ‚Üën ‚â§ 0 ‚Üî n = 0 := by"
  },
  {
    "full_name": "HurwitzZeta.hurwitzEvenFEPair_neg",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean",
    "teorema": "lemma HurwitzZeta.hurwitzEvenFEPair_neg (a : UnitAddCircle) : hurwitzEvenFEPair (-a) = hurwitzEvenFEPair a := by"
  },
  {
    "full_name": "MeasurableEmbedding.singularPart_map",
    "file_path": "Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean",
    "teorema": "theorem MeasurableEmbedding.singularPart_map (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) (ŒΩ : Measure Œ±) : (map f Œº).singularPart (map f ŒΩ) = map f (Œº.singularPart ŒΩ) := by"
  },
  {
    "full_name": "MeasurableSpace.measurable_invariants_dom",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Invariants.lean",
    "teorema": "theorem MeasurableSpace.measurable_invariants_dom (f : Œ± ‚Üí Œ±) (g : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : Measurable g ‚Üî Measurable g ‚àß ‚àÄ (s : Set Œ≤), MeasurableSet s ‚Üí g ‚àò f ‚Åª¬π' s = g ‚Åª¬π' s := by"
  },
  {
    "full_name": "not_integrableOn_Ioi_rpow",
    "file_path": "Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean",
    "teorema": "theorem not_integrableOn_Ioi_rpow (s : ‚Ñù) : ¬¨IntegrableOn (fun x => x ^ s) (Ioi 0) volume := by"
  },
  {
    "full_name": "CategoryTheory.MonoidalFunctor.map_rightUnitor",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Functor.lean",
    "teorema": "lemma CategoryTheory.MonoidalFunctor.map_rightUnitor (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (F : MonoidalFunctor C D) (X : C) : F.map (œÅ_ X).hom = inv (F.Œº X (ùüô_ C)) ‚â´ F.obj X ‚óÅ inv F.Œµ ‚â´ (œÅ_ (F.obj X)).hom := by"
  },
  {
    "full_name": "Real.negMulLog_one",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
    "teorema": "theorem Real.negMulLog_one : negMulLog 1 = 0 := by"
  },
  {
    "full_name": "Finite.card_eq_zero_of_surjective",
    "file_path": "Mathlib/Data/Finite/Card.lean",
    "teorema": "lemma Finite.card_eq_zero_of_surjective (Œ± : Type u_1) : Nat.card Œ± = 0 := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.map_negAddY",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.map_negAddY (F : Type v) (P : Fin 3 ‚Üí R) (Q : Fin 3 ‚Üí R) (R : Type u) (S : Type u_1) (W : Jacobian F) (f : R ‚Üí+* S) : negAddY (map W' f) (‚áëf ‚àò P) (‚áëf ‚àò Q) = f (W'.negAddY P Q) := by"
  },
  {
    "full_name": "integral_univ_inv_one_add_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean",
    "teorema": "theorem integral_univ_inv_one_add_sq : œÄ = œÄ / 2 - -(œÄ / 2) := by"
  },
  {
    "full_name": "ProbabilityTheory.condexpKernel_apply_eq_condDistrib",
    "file_path": "Mathlib/Probability/Kernel/Condexp.lean",
    "teorema": "theorem ProbabilityTheory.condexpKernel_apply_eq_condDistrib (m : MeasurableSpace Œ©) (Œ© : Type u_1) (Œº : Measure Œ©) (œâ : Œ©) : (condexpKernel Œº m) œâ = (condDistrib id id Œº) (id œâ) := by"
  },
  {
    "full_name": "irrational_iff_ne_rational",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "theorem irrational_iff_ne_rational (x : ‚Ñù) : Irrational x ‚Üî ‚àÄ (a b : ‚Ñ§), x ‚â† ‚Üëa / ‚Üëb := by"
  },
  {
    "full_name": "LieModule.iSup_weightSpace_eq_top'",
    "file_path": "Mathlib/Algebra/Lie/Weights/Basic.lean",
    "teorema": "theorem LieModule.iSup_weightSpace_eq_top' (M : Type u_4) : ‚®Ü œá, weightSpace M ‚áëœá = ‚ä§ := by"
  },
  {
    "full_name": "TensorAlgebra.lift_comp_Œπ",
    "file_path": "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean",
    "teorema": "lemma TensorAlgebra.lift_comp_Œπ (A : Type u_3) (M : Type u_2) (R : Type u_1) (g : TensorAlgebra R M ‚Üí‚Çê[R] A) : (lift R) (g.toLinearMap ‚àò‚Çó Œπ R) = g := by"
  },
  {
    "full_name": "Function.Periodic.comp_addHom",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "lemma Function.Periodic.comp_addHom (c : Œ±) (f : Œ± ‚Üí Œ≤) (g : AddHom Œ≥ Œ±) (g_inv : Œ± ‚Üí Œ≥) (x : Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (f ‚àò ‚áëg) (x + g_inv c) = (f ‚àò ‚áëg) x := by"
  },
  {
    "full_name": "Real.Angle.expMapCircle_add",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean",
    "teorema": "lemma Real.Angle.expMapCircle_add (Œ∏‚ÇÅ : Angle) (Œ∏‚ÇÇ : Angle) : (Œ∏‚ÇÅ + Œ∏‚ÇÇ).expMapCircle = Œ∏‚ÇÅ.expMapCircle * Œ∏‚ÇÇ.expMapCircle := by"
  },
  {
    "full_name": "SimpleGraph.commonNeighbors_top_eq",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
    "teorema": "lemma SimpleGraph.commonNeighbors_top_eq (V : Type u) (u : V) (v : V) (w : V) : ‚ä§.commonNeighbors v w = Set.univ \\ {v, w} := by"
  },
  {
    "full_name": "Nat.div_pos",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "lemma Nat.div_pos (a : ‚Ñï) (b : ‚Ñï) : a = a % b := by"
  },
  {
    "full_name": "GromovHausdorff.ghDist_eq_hausdorffDist",
    "file_path": "Mathlib/Topology/MetricSpace/GromovHausdorff.lean",
    "teorema": "theorem GromovHausdorff.ghDist_eq_hausdorffDist (X : Type u) (Y : Type v) : ‚àÉ Œ¶ Œ®, Isometry Œ¶ ‚àß Isometry Œ® ‚àß ghDist X Y = hausdorffDist (range Œ¶) (range Œ®) := by"
  },
  {
    "full_name": "continuousWithinAt_Ioc_iff_Ioi",
    "file_path": "Mathlib/Topology/Order/OrderClosed.lean",
    "teorema": "theorem continuousWithinAt_Ioc_iff_Ioi (a : Œ±) (b : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u) (Œ≤ : Type v) : ContinuousWithinAt f (Ioc a b) a ‚Üî ContinuousWithinAt f (Ioi a) a := by"
  },
  {
    "full_name": "lowerSemicontinuous_iSup",
    "file_path": "Mathlib/Topology/Semicontinuous.lean",
    "teorema": "lemma lowerSemicontinuous_iSup (f : Œπ ‚Üí Œ± ‚Üí Œ¥) (x : Œ±) (Œ± : Type u_1) (Œ¥ : Type u_4) (Œπ : Sort u_3) : ‚àÄ (x : Œ±), BddAbove (range fun i => f i x) := by"
  },
  {
    "full_name": "PreErgodic.measure_self_or_compl_eq_zero",
    "file_path": "Mathlib/Dynamics/Ergodic/Ergodic.lean",
    "teorema": "lemma PreErgodic.measure_self_or_compl_eq_zero (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº s = 0 ‚à® Œº s·∂ú = 0 := by"
  },
  {
    "full_name": "SignType.univ_eq",
    "file_path": "Mathlib/Data/Sign.lean",
    "teorema": "lemma SignType.univ_eq : Finset.univ = {0, -1, 1} := by"
  },
  {
    "full_name": "TensorProduct.tmul_sum",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean",
    "teorema": "lemma TensorProduct.tmul_sum (M : Type u_4) (N : Type u_5) (R : Type u_1) (m : M) (n : Œ± ‚Üí N) (s : Finset Œ±) (Œ± : Type u_10) : m ‚äó‚Çú[R] ‚àë a ‚àà s, n a = ‚àë a ‚àà s, m ‚äó‚Çú[R] n a := by"
  },
  {
    "full_name": "rank_commutator_le_card",
    "file_path": "Mathlib/GroupTheory/Abelianization.lean",
    "teorema": "theorem rank_commutator_le_card (G : Type u) : Group.rank ‚Ü•(commutator G) ‚â§ Nat.card ‚Üë(commutatorSet G) := by"
  },
  {
    "full_name": "le_inv_iff_mul_le_one_right",
    "file_path": "Mathlib/Algebra/Order/Group/Defs.lean",
    "teorema": "theorem le_inv_iff_mul_le_one_right (a : Œ±) (b : Œ±) (Œ± : Type u) : a * b ‚â§ b‚Åª¬π * b ‚Üî a * b ‚â§ 1 := by"
  },
  {
    "full_name": "Nat.log_div_base",
    "file_path": "Mathlib/Data/Nat/Log.lean",
    "teorema": "lemma Nat.log_div_base (b : ‚Ñï) (n : ‚Ñï) : log b (n / b) = log b n - 1 := by"
  },
  {
    "full_name": "PowerBasis.dim_le_natDegree_of_root",
    "file_path": "Mathlib/RingTheory/PowerBasis.lean",
    "teorema": "lemma PowerBasis.dim_le_natDegree_of_root (A : Type u_4) (S : Type u_2) (p : A[X]) (pb : PowerBasis A S) : pb.dim ‚â§ p.natDegree := by"
  },
  {
    "full_name": "MeasureTheory.Measure.count_apply_eq_top",
    "file_path": "Mathlib/MeasureTheory/Measure/Count.lean",
    "teorema": "lemma MeasureTheory.Measure.count_apply_eq_top (s : Set Œ±) (Œ± : Type u_1) : count s = ‚ä§ ‚Üî s.Infinite := by"
  },
  {
    "full_name": "Rat.normalize_mul_normalize",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "theorem Rat.normalize_mul_normalize (d‚ÇÅ : Nat) (d‚ÇÇ : Nat) (n‚ÇÅ : Int) (n‚ÇÇ : Int) (z‚ÇÅ : d‚ÇÅ ‚â† 0) (z‚ÇÇ : d‚ÇÇ ‚â† 0) : normalize n‚ÇÅ d‚ÇÅ z‚ÇÅ * normalize n‚ÇÇ d‚ÇÇ z‚ÇÇ = normalize (n‚ÇÅ * n‚ÇÇ) (d‚ÇÅ * d‚ÇÇ) ‚ãØ := by"
  },
  {
    "full_name": "NumberField.canonicalEmbedding.integerLattice.inter_ball_finite",
    "file_path": "Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean",
    "teorema": "lemma NumberField.canonicalEmbedding.integerLattice.inter_ball_finite (K : Type u_1) (r : ‚Ñù) : (‚Üë(integerLattice K) ‚à© Metric.closedBall 0 r).Finite := by"
  },
  {
    "full_name": "HurwitzZeta.hasSum_nat_cosKernel‚ÇÄ",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean",
    "teorema": "theorem HurwitzZeta.hasSum_nat_cosKernel‚ÇÄ (a : ‚Ñù) (t : ‚Ñù) : HasSum (fun n => 2 * Real.cos (2 * œÄ * a * (‚Üën + 1)) * rexp (-œÄ * (‚Üën + 1) ^ 2 * t)) (cosKernel (‚Üëa) t - 1) := by"
  },
  {
    "full_name": "CategoryTheory.IsHomLift.fac'",
    "file_path": "Mathlib/CategoryTheory/FiberedCategory/HomLift.lean",
    "teorema": "theorem CategoryTheory.IsHomLift.fac' (R : ùíÆ) (S : ùíÆ) (a : ùí≥) (b : ùí≥) (f : R ‚ü∂ S) (p : ùí≥ ‚•§ ùíÆ) (œÜ : a ‚ü∂ b) (ùíÆ : Type u‚ÇÅ) (ùí≥ : Type u‚ÇÇ) : p.map œÜ = eqToHom ‚ãØ ‚â´ f ‚â´ eqToHom ‚ãØ := by"
  },
  {
    "full_name": "Module.AEval.injective_comapSubmodule",
    "file_path": "Mathlib/Algebra/Polynomial/Module/AEval.lean",
    "teorema": "theorem Module.AEval.injective_comapSubmodule (A : Type u_3) (M : Type u_1) (R : Type u_2) (a : A) : Injective ‚áë(comapSubmodule R M a) := by"
  },
  {
    "full_name": "Fin.foldr_loop",
    "file_path": ".lake/packages/batteries/Batteries/Data/Fin/Lemmas.lean",
    "teorema": "theorem Fin.foldr_loop (f : Fin (n + 1) ‚Üí Œ± ‚Üí Œ±) (h : m + 1 ‚â§ n + 1) (m : Nat) (n : Nat) (x : Œ±) (Œ± : Sort u_1) : foldr.loop (n + 1) f ‚ü®m + 1, h‚ü© x = f 0 (foldr.loop n (fun i => f i.succ) ‚ü®m, ‚ãØ‚ü© x) := by"
  },
  {
    "full_name": "IsAdjoinRoot.aeval_root",
    "file_path": "Mathlib/RingTheory/IsAdjoinRoot.lean",
    "teorema": "lemma IsAdjoinRoot.aeval_root (R : Type u) (S : Type v) (f : R[X]) (h : IsAdjoinRoot S f) : (aeval h.root) f = 0 := by"
  },
  {
    "full_name": "MeasureTheory.le_lintegral_add",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "lemma MeasureTheory.le_lintegral_add (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (g : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (a : Œ±), f a ‚àÇŒº + ‚à´‚Åª (a : Œ±), g a ‚àÇŒº ‚â§ ‚à´‚Åª (a : Œ±), f a + g a ‚àÇŒº := by"
  },
  {
    "full_name": "Ideal.Quotient.lift_surjective_of_surjective",
    "file_path": "Mathlib/RingTheory/Ideal/Quotient.lean",
    "teorema": "lemma Ideal.Quotient.lift_surjective_of_surjective (H : ‚àÄ a ‚àà I, f a = 0) (I : Ideal R) (R : Type u) (S : Type v) (a : R) (f : R ‚Üí+* S) : Function.Surjective ‚áë(lift I f H) := by"
  },
  {
    "full_name": "invOf_pos",
    "file_path": "Mathlib/Algebra/Order/Invertible.lean",
    "teorema": "lemma invOf_pos (a : Œ±) (Œ± : Type u_1) : 0 < a * ‚Öüa := by"
  },
  {
    "full_name": "TensorProduct.gradedComm_of_zero_tmul",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Graded/External.lean",
    "teorema": "theorem TensorProduct.gradedComm_of_zero_tmul (R : Type u_1) (a : ùíú 0) (b : ‚®Å (i : Œπ), ‚Ñ¨ i) (Œπ : Type u_2) (‚Ñ¨ : Œπ ‚Üí Type u_6) (ùíú : Œπ ‚Üí Type u_5) : (gradedComm R ùíú ‚Ñ¨) ((lof R Œπ ùíú 0) a ‚äó‚Çú[R] b) = b ‚äó‚Çú[R] (lof R Œπ ùíú 0) a := by"
  },
  {
    "full_name": "LSeries.abscissaOfAbsConv_le_of_forall_lt_LSeriesSummable'",
    "file_path": "Mathlib/NumberTheory/LSeries/Convergence.lean",
    "teorema": "lemma LSeries.abscissaOfAbsConv_le_of_forall_lt_LSeriesSummable' (f : ‚Ñï ‚Üí ‚ÑÇ) (x : EReal) : abscissaOfAbsConv f ‚â§ x := by"
  },
  {
    "full_name": "dvd_of_mul_left_dvd",
    "file_path": "Mathlib/Algebra/Divisibility/Basic.lean",
    "teorema": "theorem dvd_of_mul_left_dvd (a : Œ±) (b : Œ±) (c : Œ±) (d : Œ±) (Œ± : Type u_1) : b * (a * d) = c := by"
  },
  {
    "full_name": "Equiv.Perm.SameCycle.of_zpow",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean",
    "teorema": "theorem Equiv.Perm.SameCycle.of_zpow (f : Perm Œ±) (m : ‚Ñ§) (n : ‚Ñ§) (x : Œ±) (y : Œ±) (Œ± : Type u_2) : (f ^ (n * m)) x = y := by"
  },
  {
    "full_name": "Filter.Tendsto.piecewise_nhdsWithin",
    "file_path": "Mathlib/Topology/ContinuousOn.lean",
    "teorema": "lemma Filter.Tendsto.piecewise_nhdsWithin (a : Œ±) (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (l : Filter Œ≤) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : Tendsto (t.piecewise f g) (ùìù[s] a) l := by"
  },
  {
    "full_name": "Part.map_map",
    "file_path": "Mathlib/Data/Part.lean",
    "teorema": "lemma Part.map_map (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (o : Part Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : map g (map f o) = map (g ‚àò f) o := by"
  },
  {
    "full_name": "Orientation.abs_areaForm_le",
    "file_path": "Mathlib/Analysis/InnerProductSpace/TwoDim.lean",
    "teorema": "theorem Orientation.abs_areaForm_le (E : Type u_1) (o : Orientation ‚Ñù E (Fin 2)) (x : E) (y : E) : |(o.areaForm x) y| ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ := by"
  },
  {
    "full_name": "MeasureTheory.mem_ae_map_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
    "teorema": "theorem MeasureTheory.mem_ae_map_iff (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) : s ‚àà ae (Measure.map f Œº) ‚Üî f ‚Åª¬π' s ‚àà ae Œº := by"
  },
  {
    "full_name": "homology'.map_eq_desc'_lift_left",
    "file_path": "Mathlib/CategoryTheory/Abelian/Homology.lean",
    "teorema": "theorem homology'.map_eq_desc'_lift_left (A : Type u) (X : A) (Y : A) (Z : A) (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) (Œ≤ : Arrow.mk g ‚ü∂ Arrow.mk g') : (kernel.Œπ g ‚â´ Œ≤.left ‚â´ cokernel.œÄ f') ‚â´ cokernel.desc f' g' w' = 0 := by"
  },
  {
    "full_name": "Submodule.disjoint_iff_comap_eq_bot",
    "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean",
    "teorema": "theorem Submodule.disjoint_iff_comap_eq_bot (M : Type u_5) (R : Type u_1) (p : Submodule R M) (q : Submodule R M) : Disjoint p q ‚Üî comap p.subtype q = ‚ä• := by"
  },
  {
    "full_name": "List.isRotated_concat",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "teorema": "theorem List.isRotated_concat (hd : Œ±) (tl : List Œ±) (Œ± : Type u) : (hd :: tl).rotate 1 = tl ++ [hd] := by"
  },
  {
    "full_name": "IntermediateField.restrictScalars_adjoin_of_algEquiv",
    "file_path": "Mathlib/FieldTheory/Adjoin.lean",
    "teorema": "lemma IntermediateField.restrictScalars_adjoin_of_algEquiv (E : Type u_2) (F : Type u_1) (L : Type u_3) (S : Set E) : restrictScalars F (adjoin L S) = restrictScalars F (adjoin L' S) := by"
  },
  {
    "full_name": "Polynomial.dickson_one_one_eq_chebyshev_T",
    "file_path": "Mathlib/RingTheory/Polynomial/Dickson.lean",
    "teorema": "lemma Polynomial.dickson_one_one_eq_chebyshev_T (R : Type u_1) : dickson 1 1 0 = 2 * (Chebyshev.T R ‚Üë0).comp (C ‚Öü2 * X) := by"
  },
  {
    "full_name": "Int.add_two_le_iff_lt_of_even_sub",
    "file_path": "Mathlib/Algebra/Order/Ring/Int.lean",
    "teorema": "lemma Int.add_two_le_iff_lt_of_even_sub (m : ‚Ñ§) (n : ‚Ñ§) : m + 2 ‚â§ n ‚Üî m < n := by"
  },
  {
    "full_name": "Complex.norm_deriv_le_div_of_mapsTo_ball",
    "file_path": "Mathlib/Analysis/Complex/Schwarz.lean",
    "teorema": "lemma Complex.norm_deriv_le_div_of_mapsTo_ball (E : Type u_1) (R‚ÇÅ : ‚Ñù) (R‚ÇÇ : ‚Ñù) (c : ‚ÑÇ) (f : ‚ÑÇ ‚Üí E) : ‚Äñderiv f c‚Äñ ‚â§ R‚ÇÇ / R‚ÇÅ := by"
  },
  {
    "full_name": "SemiNormedGrp.explicitCokernelIso_hom_desc",
    "file_path": "Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",
    "teorema": "theorem SemiNormedGrp.explicitCokernelIso_hom_desc (X : SemiNormedGrp) (Y : SemiNormedGrp) (Z : SemiNormedGrp) (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (w : f ‚â´ g = 0) : (explicitCokernelIso f).hom ‚â´ cokernel.desc f g w = explicitCokernelDesc w := by"
  },
  {
    "full_name": "HolderOnWith.dimH_image_le",
    "file_path": "Mathlib/Topology/MetricSpace/HausdorffDimension.lean",
    "teorema": "theorem HolderOnWith.dimH_image_le (X : Type u_2) (Y : Type u_3) (f : X ‚Üí Y) (r : ‚Ñù‚â•0) (s : Set X) : dimH (f '' s) ‚â§ dimH s / ‚Üër := by"
  },
  {
    "full_name": "Metric.continuousOn_iff",
    "file_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
    "teorema": "lemma Metric.continuousOn_iff (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (Œ± : Type u) (Œ≤ : Type v) (Œ¥ : ‚Ñù) (Œµ : ‚Ñù) : ContinuousOn f s ‚Üî ‚àÄ b ‚àà s, ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ a ‚àà s, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ := by"
  },
  {
    "full_name": "WithZeroTopology.nhds_eq_update",
    "file_path": "Mathlib/Topology/Algebra/WithZeroTopology.lean",
    "teorema": "lemma WithZeroTopology.nhds_eq_update (Œì‚ÇÄ : Type u_2) (Œ≥ : Œì‚ÇÄ) : ùìù = update pure 0 (‚®Ö Œ≥, ‚®Ö (_ : Œ≥ ‚â† 0), ùìü (Iio Œ≥)) := by"
  },
  {
    "full_name": "EulerProduct.prod_primesBelow_geometric_eq_tsum_smoothNumbers",
    "file_path": "Mathlib/NumberTheory/EulerProduct/Basic.lean",
    "teorema": "theorem EulerProduct.prod_primesBelow_geometric_eq_tsum_smoothNumbers (F : Type u_1) (N : ‚Ñï) (f : ‚Ñï ‚Üí* F) : ‚àè p ‚àà N.primesBelow, (1 - f p)‚Åª¬π = ‚àë' (m : ‚ÜëN.smoothNumbers), f ‚Üëm := by"
  },
  {
    "full_name": "WithBot.map‚ÇÇ_bot_right",
    "file_path": "Mathlib/Order/WithBot.lean",
    "teorema": "theorem WithBot.map‚ÇÇ_bot_right (a : WithBot Œ±) (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : map‚ÇÇ f a ‚ä• = ‚ä• := by"
  },
  {
    "full_name": "Submodule.lt_sup_iff_not_mem",
    "file_path": "Mathlib/LinearAlgebra/Span.lean",
    "teorema": "theorem Submodule.lt_sup_iff_not_mem (I : Submodule R M) (M : Type u_4) (R : Type u_1) (a : M) : I < I ‚äî span R {a} ‚Üî a ‚àâ I := by"
  },
  {
    "full_name": "Isometry.hausdorffMeasure_preimage",
    "file_path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
    "teorema": "lemma Isometry.hausdorffMeasure_preimage (X : Type u_2) (Y : Type u_3) (d : ‚Ñù) (f : X ‚Üí Y) (s : Set Y) : ŒºH[d] (f ‚Åª¬π' s) = ŒºH[d] (s ‚à© range f) := by"
  },
  {
    "full_name": "lowerSemicontinuousWithinAt_tsum",
    "file_path": "Mathlib/Topology/Semicontinuous.lean",
    "teorema": "lemma lowerSemicontinuousWithinAt_tsum (f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Set Œ±) (x : Œ±) (Œ± : Type u_1) (Œπ : Type u_3) : LowerSemicontinuousWithinAt (fun x' => ‚àë' (i : Œπ), f i x') s x := by"
  },
  {
    "full_name": "Multiset.count_replicate",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.count_replicate (a : Œ±) (b : Œ±) (n : ‚Ñï) (Œ± : Type u_1) : count a (replicate n b) = if a = b then n else 0 := by"
  },
  {
    "full_name": "MeasureTheory.JordanDecomposition.toSignedMeasure_injective",
    "file_path": "Mathlib/MeasureTheory/Decomposition/Jordan.lean",
    "teorema": "theorem MeasureTheory.JordanDecomposition.toSignedMeasure_injective : Injective toSignedMeasure := by"
  },
  {
    "full_name": "PartialHomeomorph.tendsto_extend_comp_iff",
    "file_path": "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean",
    "teorema": "theorem PartialHomeomorph.tendsto_extend_comp_iff (E : Type u_2) (H : Type u_4) (I : ModelWithCorners ùïú E H) (M : Type u_3) (f : PartialHomeomorph M H) (g : Œ± ‚Üí M) (l : Filter Œ±) (y : M) (Œ± : Type u_8) (ùïú : Type u_1) : Tendsto (‚Üë(f.extend I) ‚àò g) l (ùìù (‚Üë(f.extend I) y)) ‚Üî Tendsto g l (ùìù y) := by"
  },
  {
    "full_name": "MvPolynomial.totalDegree_le_degrees_card",
    "file_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
    "teorema": "lemma MvPolynomial.totalDegree_le_degrees_card (R : Type u) (p : MvPolynomial œÉ R) (œÉ : Type u_1) : p.totalDegree ‚â§ Multiset.card p.degrees := by"
  },
  {
    "full_name": "SimpleGraph.adj_replaceVertex_iff_of_ne",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Operations.lean",
    "teorema": "lemma SimpleGraph.adj_replaceVertex_iff_of_ne (G : SimpleGraph V) (V : Type u_1) (s : V) (t : V) (v : V) (w : V) : (G.replaceVertex s t).Adj v w ‚Üî G.Adj v w := by"
  },
  {
    "full_name": "NumberField.ComplexEmbedding.place_conjugate",
    "file_path": "Mathlib/NumberTheory/NumberField/Embeddings.lean",
    "teorema": "lemma NumberField.ComplexEmbedding.place_conjugate (K : Type u_1) (œÜ : K ‚Üí+* ‚ÑÇ) : place (conjugate œÜ) = place œÜ := by"
  },
  {
    "full_name": "Real.one_le_rpow_of_pos_of_le_one_of_nonpos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
    "teorema": "theorem Real.one_le_rpow_of_pos_of_le_one_of_nonpos (x : ‚Ñù) (z : ‚Ñù) : 1 ‚â§ x ^ z := by"
  },
  {
    "full_name": "RCLike.inv_im",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "theorem RCLike.inv_im (K : Type u_1) (z : K) : im z‚Åª¬π = -im z / normSq z := by"
  },
  {
    "full_name": "Set.MapsTo.piecewise_ite",
    "file_path": "Mathlib/Data/Set/Function.lean",
    "teorema": "theorem Set.MapsTo.piecewise_ite (f‚ÇÅ : Œ± ‚Üí Œ≤) (f‚ÇÇ : Œ± ‚Üí Œ≤) (s : Set Œ±) (s‚ÇÅ : Set Œ±) (s‚ÇÇ : Set Œ±) (t : Set Œ≤) (t‚ÇÅ : Set Œ≤) (t‚ÇÇ : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : MapsTo (s.piecewise f‚ÇÅ f‚ÇÇ) (s.ite s‚ÇÅ s‚ÇÇ) (t.ite t‚ÇÅ t‚ÇÇ) := by"
  },
  {
    "full_name": "IsLowerSet.mem_interior_of_forall_lt",
    "file_path": "Mathlib/Analysis/Normed/Order/UpperLower.lean",
    "teorema": "lemma IsLowerSet.mem_interior_of_forall_lt (s : Set (Œπ ‚Üí ‚Ñù)) (y : Œπ ‚Üí ‚Ñù) (Œπ : Type u_2) : y ‚àà interior s := by"
  },
  {
    "full_name": "MeasureTheory.Measure.singularPart_eq_zero",
    "file_path": "Mathlib/MeasureTheory/Decomposition/Lebesgue.lean",
    "teorema": "theorem MeasureTheory.Measure.singularPart_eq_zero (Œ± : Type u_1) (Œº : Measure Œ±) (ŒΩ : Measure Œ±) : Œº.singularPart ŒΩ = 0 ‚Üî Œº ‚â™ ŒΩ := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_prod_symm",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "theorem MeasureTheory.lintegral_prod_symm (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œ≤ : Type u_3) (Œº : Measure Œ±) (ŒΩ : Measure Œ≤) : ‚à´‚Åª (z : Œ± √ó Œ≤), f z ‚àÇŒº.prod ŒΩ = ‚à´‚Åª (y : Œ≤), ‚à´‚Åª (x : Œ±), f (x, y) ‚àÇŒº ‚àÇŒΩ := by"
  },
  {
    "full_name": "Set.InjOn.image_subset_image_iff",
    "file_path": "Mathlib/Data/Set/Function.lean",
    "teorema": "theorem Set.InjOn.image_subset_image_iff (f : Œ± ‚Üí Œ≤) (s‚ÇÅ : Set Œ±) (s‚ÇÇ : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : f '' s‚ÇÅ ‚äÜ f '' s‚ÇÇ ‚Üî s‚ÇÅ ‚äÜ s‚ÇÇ := by"
  },
  {
    "full_name": "Finset.card_le_mul_card_image_of_maps_to",
    "file_path": "Mathlib/Algebra/Order/BigOperators/Group/Finset.lean",
    "teorema": "lemma Finset.card_le_mul_card_image_of_maps_to (n : ‚Ñï) (t : Finset Œ≤) (Œ≤ : Type u_3) : ‚àë _a ‚àà t, n = n * t.card := by"
  },
  {
    "full_name": "rTensorHomEquivHomRTensor_toLinearMap",
    "file_path": "Mathlib/LinearAlgebra/Contraction.lean",
    "teorema": "lemma rTensorHomEquivHomRTensor_toLinearMap (M : Type v‚ÇÅ) (P : Type v‚ÇÉ) (Q : Type v‚ÇÑ) (R : Type u) : ‚Üë(rTensorHomEquivHomRTensor R M P Q) = rTensorHomToHomRTensor R M P Q := by"
  },
  {
    "full_name": "MulRingNorm.equiv_symm",
    "file_path": "Mathlib/Analysis/Normed/Ring/Seminorm.lean",
    "teorema": "lemma MulRingNorm.equiv_symm (R : Type u_4) (f : MulRingNorm R) (g : MulRingNorm R) : g.equiv f := by"
  },
  {
    "full_name": "LinearMap.trace_comp_eq_mul_of_commute_of_isNilpotent",
    "file_path": "Mathlib/LinearAlgebra/Trace.lean",
    "teorema": "theorem LinearMap.trace_comp_eq_mul_of_commute_of_isNilpotent (M : Type u_2) (R : Type u_1) (f : Module.End R M) (g : Module.End R M) (Œº : R) : (trace R M) (f ‚àò‚Çó g) = Œº * (trace R M) f := by"
  },
  {
    "full_name": "CategoryTheory.Limits.prod.map_swap",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
    "teorema": "lemma CategoryTheory.Limits.prod.map_swap (A : C) (B : C) (C : Type u) (X : C) (Y : C) (f : A ‚ü∂ B) (g : X ‚ü∂ Y) : map (ùüô X) f ‚â´ map g (ùüô B) = map g (ùüô A) ‚â´ map (ùüô Y) f := by"
  },
  {
    "full_name": "HasMFDerivWithinAt.mul",
    "file_path": "Mathlib/Geometry/Manifold/MFDeriv/SpecificFunctions.lean",
    "teorema": "theorem HasMFDerivWithinAt.mul (E : Type u_2) (H : Type u_3) (I : ModelWithCorners ùïú E H) (M : Type u_4) (p : M ‚Üí F') (q : M ‚Üí F') (s : Set M) (z : M) (ùïú : Type u_1) : HasMFDerivWithinAt I ùìò(ùïú, F') (p * q) s z (p z ‚Ä¢ q' + q z ‚Ä¢ p') := by"
  },
  {
    "full_name": "QPF.liftpPreservation_iff_uniform",
    "file_path": "Mathlib/Data/QPF/Univariate/Basic.lean",
    "teorema": "lemma QPF.liftpPreservation_iff_uniform : LiftpPreservation ‚Üî IsUniform := by"
  },
  {
    "full_name": "Multiset.card_singleton",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.card_singleton (a : Œ±) (Œ± : Type u_1) : card {a} = 1 := by"
  },
  {
    "full_name": "Nat.pred_eq_succ_iff",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "lemma Nat.pred_eq_succ_iff (m : ‚Ñï) (n : ‚Ñï) : n - 1 = m + 1 ‚Üî n = m + 2 := by"
  },
  {
    "full_name": "MvPolynomial.NewtonIdentities.mem_pairs",
    "file_path": "Mathlib/RingTheory/MvPolynomial/NewtonIdentities.lean",
    "teorema": "lemma MvPolynomial.NewtonIdentities.mem_pairs (k : ‚Ñï) (t : Finset œÉ √ó œÉ) (œÉ : Type u_1) : t ‚àà MvPolynomial.NewtonIdentities.pairs œÉ k ‚Üî t.1.card ‚â§ k ‚àß (t.1.card = k ‚Üí t.2 ‚àà t.1) := by"
  },
  {
    "full_name": "HNNExtension.NormalWord.prod_group_smul",
    "file_path": "Mathlib/GroupTheory/HNNExtension.lean",
    "teorema": "lemma HNNExtension.NormalWord.prod_group_smul (A : Subgroup G) (B : Subgroup G) (G : Type u_1) (d : TransversalPair G A B) (g : G) (w : NormalWord d) (œÜ : ‚Ü•A ‚âÉ* ‚Ü•B) : ReducedWord.prod œÜ (g ‚Ä¢ w).toReducedWord = of g * ReducedWord.prod œÜ w.toReducedWord := by"
  },
  {
    "full_name": "lt_or_lt_of_div_lt_div",
    "file_path": "Mathlib/Algebra/Order/Group/Defs.lean",
    "teorema": "lemma lt_or_lt_of_div_lt_div (a : Œ±) (b : Œ±) (c : Œ±) (d : Œ±) (Œ± : Type u) : a / d < b / c ‚Üí a < b ‚à® c < d := by"
  },
  {
    "full_name": "CategoryTheory.eqToHom_iso_inv_naturality",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "teorema": "lemma CategoryTheory.eqToHom_iso_inv_naturality (C : Type u‚ÇÅ) (f : Œ≤ ‚Üí C) (j : Œ≤) (Œ≤ : Sort u_1) : f j = f j' := by"
  },
  {
    "full_name": "PowerSeries.eq_divided_by_X_pow_order_Iff_Unit",
    "file_path": "Mathlib/RingTheory/PowerSeries/Inverse.lean",
    "teorema": "lemma PowerSeries.eq_divided_by_X_pow_order_Iff_Unit (f : k‚ü¶X‚üß) (k : Type u_2) : IsUnit f := by"
  },
  {
    "full_name": "SemiconjBy.zpow_right‚ÇÄ",
    "file_path": "Mathlib/Algebra/GroupWithZero/Semiconj.lean",
    "teorema": "lemma SemiconjBy.zpow_right‚ÇÄ (G‚ÇÄ : Type u_3) (a : G‚ÇÄ) (n : ‚Ñï) (x : G‚ÇÄ) (y : G‚ÇÄ) : SemiconjBy a (x ^ ‚Üën) (y ^ ‚Üën) := by"
  },
  {
    "full_name": "BooleanRing.sup_comm",
    "file_path": "Mathlib/Algebra/Ring/BooleanRing.lean",
    "teorema": "theorem BooleanRing.sup_comm (a : Œ±) (b : Œ±) (Œ± : Type u_1) : a + b + a * b = b + a + b * a := by"
  },
  {
    "full_name": "intervalIntegral.integral_const_of_cdf",
    "file_path": "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean",
    "teorema": "lemma intervalIntegral.integral_const_of_cdf (E : Type u_3) (a : ‚Ñù) (b : ‚Ñù) (c : E) (Œº : Measure ‚Ñù) : ‚à´ (x : ‚Ñù) in a..b, c ‚àÇŒº = ((Œº (Iic b)).toReal - (Œº (Iic a)).toReal) ‚Ä¢ c := by"
  },
  {
    "full_name": "norm_injOn_ray_left",
    "file_path": "Mathlib/Analysis/NormedSpace/Ray.lean",
    "teorema": "theorem norm_injOn_ray_left (F : Type u_2) (x : F) (y : F) : Set.InjOn Norm.norm {y | SameRay ‚Ñù x y} := by"
  },
  {
    "full_name": "Ideal.dvd_iff_le",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Ideal.lean",
    "teorema": "lemma Ideal.dvd_iff_le (A : Type u_2) (I : Ideal A) (J : Ideal A) : I ‚à£ J := by"
  },
  {
    "full_name": "Filter.Tendsto.eventually_forall_ge_atTop",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "lemma Filter.Tendsto.eventually_forall_ge_atTop (f : Œ± ‚Üí Œ≤) (l : Filter Œ±) (p : Œ≤ ‚Üí Prop) (Œ± : Type u_3) (Œ≤ : Type u_4) : ‚àÄ·∂† (x : Œ±) in l, ‚àÄ (y : Œ≤), f x ‚â§ y ‚Üí p y := by"
  },
  {
    "full_name": "List.singleton_disjoint",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "theorem List.singleton_disjoint (a : Œ±‚úù) (l : List Œ±‚úù) : [a].Disjoint l ‚Üî ¬¨a ‚àà l := by"
  },
  {
    "full_name": "Set.RightInvOn.extendDomain",
    "file_path": "Mathlib/Data/Set/Function.lean",
    "teorema": "theorem Set.RightInvOn.extendDomain (f : Œ± ‚âÉ Subtype p) (g‚ÇÅ : Perm Œ±) (g‚ÇÇ : Perm Œ±) (p : Œ≤ ‚Üí Prop) (t : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : RightInvOn (‚áë(g‚ÇÅ.extendDomain f)) (‚áë(g‚ÇÇ.extendDomain f)) (Subtype.val ‚àò ‚áëf '' t) := by"
  },
  {
    "full_name": "Fin.succAbove_right_injective",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "lemma Fin.succAbove_right_injective (n : ‚Ñï) (p : Fin (n + 1)) : Injective p.succAbove := by"
  },
  {
    "full_name": "Int.subgroup_cyclic",
    "file_path": "Mathlib/GroupTheory/Archimedean.lean",
    "teorema": "lemma Int.subgroup_cyclic (H : AddSubgroup ‚Ñ§) : Disjoint (‚ÜëH) (Ioo 0 1) := by"
  },
  {
    "full_name": "Relation.transGen_reflGen",
    "file_path": "Mathlib/Logic/Relation.lean",
    "teorema": "lemma Relation.transGen_reflGen (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : TransGen (ReflGen r) = ReflTransGen r := by"
  },
  {
    "full_name": "AlgebraicTopology.DoldKan.identity_N‚ÇÇ",
    "file_path": "Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean",
    "teorema": "theorem AlgebraicTopology.DoldKan.identity_N‚ÇÇ : (ùüô N‚ÇÇ ‚ó´ N‚ÇÇŒì‚ÇÇ.inv) ‚â´ (N‚ÇÇ.associator Œì‚ÇÇ N‚ÇÇ).inv ‚â´ Œì‚ÇÇN‚ÇÇ.natTrans ‚ó´ ùüô N‚ÇÇ = ùüô N‚ÇÇ := by"
  },
  {
    "full_name": "Multiset.prod_dvd_prod_of_dvd",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
    "teorema": "theorem Multiset.prod_dvd_prod_of_dvd (S : Multiset Œ±) (g1 : Œ± ‚Üí Œ≤) (g2 : Œ± ‚Üí Œ≤) (Œ± : Type u_3) (Œ≤ : Type u_4) : (map g1 S).prod ‚à£ (map g2 S).prod := by"
  },
  {
    "full_name": "Bimod.whisker_exchange_bimod",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Bimod.lean",
    "teorema": "lemma Bimod.whisker_exchange_bimod (C : Type u‚ÇÅ) (M : Bimod X Y) (N : Bimod X Y) (P : Bimod Y Z) (Q : Bimod Y Z) (X : Mon_ C) (Y : Mon_ C) (Z : Mon_ C) (f : M ‚ü∂ N) (g : P ‚ü∂ Q) : M.whiskerLeft g ‚â´ whiskerRight f Q = whiskerRight f P ‚â´ N.whiskerLeft g := by"
  },
  {
    "full_name": "algebraicIndependent_comp_subtype",
    "file_path": "Mathlib/RingTheory/AlgebraicIndependent.lean",
    "teorema": "lemma algebraicIndependent_comp_subtype (A : Type u_5) (R : Type u_3) (s : Set Œπ) (x : Œπ ‚Üí A) (Œπ : Type u_1) : AlgebraicIndependent R (x ‚àò Subtype.val) ‚Üî ‚àÄ p ‚àà supported R s, (aeval x) p = 0 ‚Üí p = 0 := by"
  },
  {
    "full_name": "LinearIsometry.im_apply_eq_im",
    "file_path": "Mathlib/Analysis/Complex/Isometry.lean",
    "teorema": "theorem LinearIsometry.im_apply_eq_im (f : ‚ÑÇ ‚Üí‚Çó·µ¢[‚Ñù] ‚ÑÇ) (z : ‚ÑÇ) : z + (starRingEnd ‚ÑÇ) z = f z + (starRingEnd ‚ÑÇ) (f z) := by"
  },
  {
    "full_name": "Asymptotics.IsTheta.tendsto_norm_atTop_iff",
    "file_path": "Mathlib/Analysis/Asymptotics/Theta.lean",
    "teorema": "theorem Asymptotics.IsTheta.tendsto_norm_atTop_iff (E : Type u_3) (F : Type u_4) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) (l : Filter Œ±) (Œ± : Type u_1) : Tendsto (norm ‚àò f') l atTop ‚Üî Tendsto (norm ‚àò g') l atTop := by"
  },
  {
    "full_name": "MeasurableSet.const_smul",
    "file_path": "Mathlib/MeasureTheory/Group/Pointwise.lean",
    "teorema": "lemma MeasurableSet.const_smul (G : Type u_1) (a : G) (s : Set Œ±) (Œ± : Type u_2) : MeasurableSet (a ‚Ä¢ s) := by"
  },
  {
    "full_name": "Polynomial.divX_C_mul_X_pow",
    "file_path": "Mathlib/Algebra/Polynomial/Inductions.lean",
    "teorema": "lemma Polynomial.divX_C_mul_X_pow (R : Type u) (a : R) (n : ‚Ñï) : (C a * X ^ n).divX = if n = 0 then 0 else C a * X ^ (n - 1) := by"
  },
  {
    "full_name": "Bimod.AssociatorBimod.hom_left_act_hom'",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Bimod.lean",
    "teorema": "lemma Bimod.AssociatorBimod.hom_left_act_hom' (C : Type u‚ÇÅ) (L : Bimod T U) (P : Bimod R S) (Q : Bimod S T) (R : Mon_ C) (S : Mon_ C) (T : Mon_ C) (U : Mon_ C) : ((P.tensorBimod Q).tensorBimod L).actLeft ‚â´ hom P Q L = R.X ‚óÅ hom P Q L ‚â´ (P.tensorBimod (Q.tensorBimod L)).actLeft := by"
  },
  {
    "full_name": "Int.lor_bit",
    "file_path": "Mathlib/Data/Int/Bitwise.lean",
    "teorema": "lemma Int.lor_bit (a : Bool) (b : Bool) (m : ‚Ñ§) (n : ‚Ñ§) : (bit a m).lor (bit b n) = bit (a || b) (m.lor n) := by"
  },
  {
    "full_name": "combo_mem_ball_of_ne",
    "file_path": "Mathlib/Analysis/Convex/StrictConvexSpace.lean",
    "teorema": "theorem combo_mem_ball_of_ne (E : Type u_2) (a : ‚Ñù) (b : ‚Ñù) (r : ‚Ñù) (x : E) (y : E) (z : E) : a ‚Ä¢ x + b ‚Ä¢ y ‚àà ball z r := by"
  },
  {
    "full_name": "Finset.mem_upShadow_iff_exists_mem_card_add_one",
    "file_path": "Mathlib/Combinatorics/SetFamily/Shadow.lean",
    "teorema": "theorem Finset.mem_upShadow_iff_exists_mem_card_add_one (s : Finset Œ±) (t : Finset Œ±) (Œ± : Type u_1) (ùíú : Finset (Finset Œ±)) : t ‚àà ‚àÇ‚Å∫ ùíú ‚Üî ‚àÉ s ‚àà ùíú, s ‚äÜ t ‚àß t.card = s.card + 1 := by"
  },
  {
    "full_name": "Commute.list_prod_right",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "lemma Commute.list_prod_right (M : Type u_4) (l : List M) (y : M) : Commute y l.prod := by"
  },
  {
    "full_name": "FinVec.seq_eq",
    "file_path": "Mathlib/Data/Fin/Tuple/Reflection.lean",
    "teorema": "theorem FinVec.seq_eq (f : Fin (n + 1) ‚Üí Œ± ‚Üí Œ≤) (i : Fin (n + 1)) (n : ‚Ñï) (v : Fin (n + 1) ‚Üí Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : seq f v i = f i (v i) := by"
  },
  {
    "full_name": "ProbabilityTheory.gammaPDFReal_nonneg",
    "file_path": "Mathlib/Probability/Distributions/Gamma.lean",
    "teorema": "lemma ProbabilityTheory.gammaPDFReal_nonneg (a : ‚Ñù) (r : ‚Ñù) (x : ‚Ñù) : 0 ‚â§ gammaPDFReal a r x := by"
  },
  {
    "full_name": "NNReal.young_inequality_real",
    "file_path": "Mathlib/Analysis/MeanInequalities.lean",
    "teorema": "lemma NNReal.young_inequality_real (a : ‚Ñù‚â•0) (b : ‚Ñù‚â•0) (p : ‚Ñù) (q : ‚Ñù) : a * b ‚â§ a ^ p / p.toNNReal + b ^ q / q.toNNReal := by"
  },
  {
    "full_name": "IsFractionRing.isAlgebraic_iff",
    "file_path": "Mathlib/RingTheory/Localization/Integral.lean",
    "teorema": "lemma IsFractionRing.isAlgebraic_iff (A : Type u_4) (C : Type u_6) (K : Type u_5) (x : C) : IsAlgebraic A x ‚Üî IsAlgebraic K x := by"
  },
  {
    "full_name": "List.Perm.prod_eq'",
    "file_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
    "teorema": "lemma List.Perm.prod_eq' (M : Type u_4) (l‚ÇÅ : List M) (l‚ÇÇ : List M) : l‚ÇÅ.prod = l‚ÇÇ.prod := by"
  },
  {
    "full_name": "Set.mem_dite_univ_right",
    "file_path": "Mathlib/Data/Set/Basic.lean",
    "teorema": "lemma Set.mem_dite_univ_right (p : Prop) (t : p ‚Üí Set Œ±) (u : Set Œ±) (x : Œ±) (Œ± : Type u) : (x ‚àà if h : p then t h else univ) ‚Üî ‚àÄ (h : p), x ‚àà t h := by"
  },
  {
    "full_name": "IsAssociatedPrime.eq_radical",
    "file_path": "Mathlib/RingTheory/Ideal/AssociatedPrime.lean",
    "teorema": "theorem IsAssociatedPrime.eq_radical (I : Ideal R) (J : Ideal R) (R : Type u_1) : J = I.radical := by"
  },
  {
    "full_name": "Complex.exp_eq_exp_re_mul_sin_add_cos",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.exp_eq_exp_re_mul_sin_add_cos (x : ‚ÑÇ) : cexp x = cexp ‚Üëx.re * (cos ‚Üëx.im + sin ‚Üëx.im * I) := by"
  },
  {
    "full_name": "variationOnFromTo.eq_zero_iff_of_le",
    "file_path": "Mathlib/Analysis/BoundedVariation.lean",
    "teorema": "lemma variationOnFromTo.eq_zero_iff_of_le (E : Type u_2) (a : Œ±) (b : Œ±) (f : Œ± ‚Üí E) (s : Set Œ±) (Œ± : Type u_1) : variationOnFromTo f s a b = 0 ‚Üî ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚à© Icc a b ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà s ‚à© Icc a b ‚Üí edist (f x) (f y) = 0 := by"
  },
  {
    "full_name": "MonoidAlgebra.ringHom_ext",
    "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean",
    "teorema": "lemma MonoidAlgebra.ringHom_ext (G : Type u‚ÇÇ) (R : Type u_3) (a : G) (b : k) (f : MonoidAlgebra k G ‚Üí+* R) (g : MonoidAlgebra k G ‚Üí+* R) (k : Type u‚ÇÅ) : ((fun f => ‚Üëf) f) (Finsupp.single a b) = ((fun f => ‚Üëf) g) (Finsupp.single a b) := by"
  },
  {
    "full_name": "Equiv.Perm.nodup_toList",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean",
    "teorema": "theorem Equiv.Perm.nodup_toList (p : Perm Œ±) (x : Œ±) (Œ± : Type u_1) : (p.toList x).Nodup := by"
  },
  {
    "full_name": "exists_extension_norm_eq",
    "file_path": "Mathlib/Analysis/NormedSpace/HahnBanach/Extension.lean",
    "teorema": "theorem exists_extension_norm_eq (E : Type u_2) (f : ‚Ü•p ‚ÜíL[ùïú] ùïú) (p : Subspace ùïú E) (ùïú : Type u_1) : ‚àÉ g, (‚àÄ (x : ‚Ü•p), g ‚Üëx = f x) ‚àß ‚Äñg‚Äñ = ‚Äñf‚Äñ := by"
  },
  {
    "full_name": "IsIntegralClosure.mk'_add",
    "file_path": "Mathlib/RingTheory/IntegralClosure.lean",
    "teorema": "theorem IsIntegralClosure.mk'_add (A : Type u_2) (B : Type u_3) (R : Type u_1) (hx : IsIntegral R x) (hy : IsIntegral R y) (x : B) (y : B) : (algebraMap A B) (mk' A (x + y) ‚ãØ) = (algebraMap A B) (mk' A x hx + mk' A y hy) := by"
  },
  {
    "full_name": "RingCon.ext",
    "file_path": "Mathlib/RingTheory/Congruence/Basic.lean",
    "teorema": "lemma RingCon.ext (R : Type u_2) (c : RingCon R) (d : RingCon R) : ‚áëc = ‚áëd := by"
  },
  {
    "full_name": "Monoid.fg_of_surjective",
    "file_path": "Mathlib/GroupTheory/Finiteness.lean",
    "teorema": "lemma Monoid.fg_of_surjective (M : Type u_1) : FG M' := by"
  },
  {
    "full_name": "MeasureTheory.ae_restrict_uIoc_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "theorem MeasureTheory.ae_restrict_uIoc_iff (P : Œ± ‚Üí Prop) (a : Œ±) (b : Œ±) (Œ± : Type u_2) (Œº : Measure Œ±) : (‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict (Œô a b), P x) ‚Üî := by"
  },
  {
    "full_name": "AlternatingMap.domCoprod.summand_add_swap_smul_eq_zero",
    "file_path": "Mathlib/LinearAlgebra/Alternating/DomCoprod.lean",
    "teorema": "theorem AlternatingMap.domCoprod.summand_add_swap_smul_eq_zero (M·µ¢ : Type u_4) (N‚ÇÅ : Type u_5) (N‚ÇÇ : Type u_6) (a : M·µ¢ [‚ãÄ^Œπa]‚Üí‚Çó[R'] N‚ÇÅ) (b : M·µ¢ [‚ãÄ^Œπb]‚Üí‚Çó[R'] N‚ÇÇ) (i : Œπa ‚äï Œπb) (j : Œπa ‚äï Œπb) (v : Œπa ‚äï Œπb ‚Üí M·µ¢) (Œπa : Type u_1) (Œπb : Type u_2) (œÉ : Perm.ModSumCongr Œπa Œπb) : (summand a b œÉ) v + (summand a b (swap i j ‚Ä¢ œÉ)) v = 0 := by"
  },
  {
    "full_name": "star_lt_star_iff",
    "file_path": "Mathlib/Algebra/Star/Order.lean",
    "teorema": "lemma star_lt_star_iff (R : Type u) (x : R) (y : R) : star x < star y ‚Üî x < y := by"
  },
  {
    "full_name": "jacobiSym.mod_left'",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean",
    "teorema": "theorem jacobiSym.mod_left' (a‚ÇÅ : ‚Ñ§) (a‚ÇÇ : ‚Ñ§) (b : ‚Ñï) : J(a‚ÇÅ | b) = J(a‚ÇÇ | b) := by"
  },
  {
    "full_name": "Multiset.map_surjective_of_surjective",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.map_surjective_of_surjective (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type v) : Surjective (map f) := by"
  },
  {
    "full_name": "CategoryTheory.Abelian.epi_of_epi_of_epi_of_mono",
    "file_path": "Mathlib/CategoryTheory/Abelian/DiagramLemmas/Four.lean",
    "teorema": "theorem CategoryTheory.Abelian.epi_of_epi_of_epi_of_mono (C : Type u_1) (R‚ÇÇ : ComposableArrows C 3) : R‚ÇÇ.map' 1 3 ‚ãØ ‚ãØ = 0 := by"
  },
  {
    "full_name": "CategoryTheory.Subobject.ofMkLE_arrow",
    "file_path": "Mathlib/CategoryTheory/Subobject/Basic.lean",
    "teorema": "theorem CategoryTheory.Subobject.ofMkLE_arrow (A : C) (B : C) (C : Type u‚ÇÅ) (X : Subobject B) (f : A ‚ü∂ B) (h : mk f ‚â§ X) : ofMkLE f X h ‚â´ X.arrow = f := by"
  },
  {
    "full_name": "CategoryTheory.NatTrans.CommShift.of_isIso",
    "file_path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
    "teorema": "lemma CategoryTheory.NatTrans.CommShift.of_isIso (A : Type u_5) (C : Type u_1) (D : Type u_2) (F‚ÇÅ : C ‚•§ D) (F‚ÇÇ : C ‚•§ D) (œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ) : CommShift (inv œÑ) A := by"
  },
  {
    "full_name": "Finset.prod_range_one",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "theorem Finset.prod_range_one (f : ‚Ñï ‚Üí Œ≤) (Œ≤ : Type u_4) : ‚àè k ‚àà range 1, f k = f 0 := by"
  },
  {
    "full_name": "Equiv.Perm.formPerm_toList",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean",
    "teorema": "lemma Equiv.Perm.formPerm_toList (f : Perm Œ±) (x : Œ±) (Œ± : Type u_1) : (f.toList x).formPerm = f.cycleOf x := by"
  },
  {
    "full_name": "hasDerivAt_sqrt_mul_log",
    "file_path": "Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean",
    "teorema": "lemma hasDerivAt_sqrt_mul_log (x : ‚Ñù) : HasDerivAt (fun x => ‚àöx * log x) ((2 + log x) / (2 * ‚àöx)) x := by"
  },
  {
    "full_name": "cauchySeq_finset_iff_prod_vanishing",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Group.lean",
    "teorema": "lemma cauchySeq_finset_iff_prod_vanishing (f : Œ≤ ‚Üí Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : Tendsto (fun x => (‚àè b ‚àà x.2, f b) / ‚àè b ‚àà x.1, f b) atTop (ùìù 1) ‚Üî := by"
  },
  {
    "full_name": "CategoryTheory.CostructuredArrow.projectQuotient_factors",
    "file_path": "Mathlib/CategoryTheory/Subobject/Comma.lean",
    "teorema": "theorem CategoryTheory.CostructuredArrow.projectQuotient_factors (A : CostructuredArrow S T) (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (P : (CostructuredArrow S T)·µí·µñ) (S : C ‚•§ D) (T : D) (f : P ‚ü∂ { unop := A }) : S.map (projectQuotient (Subobject.mk f)).arrow.unop ‚â´ S.map (Subobject.underlyingIso (MonoOver.mk' f).arrow.unop.left.op).unop.inv ‚â´ P.unop.hom = A.hom := by"
  },
  {
    "full_name": "Set.not_subsingleton_iff",
    "file_path": "Mathlib/Data/Set/Subsingleton.lean",
    "teorema": "theorem Set.not_subsingleton_iff (s : Set Œ±) (Œ± : Type u) : ¬¨s.Subsingleton ‚Üî s.Nontrivial := by"
  },
  {
    "full_name": "Commute.exp_right",
    "file_path": "Mathlib/Analysis/NormedSpace/Exponential.lean",
    "teorema": "lemma Commute.exp_right (x : ùî∏) (y : ùî∏) (ùî∏ : Type u_2) (ùïÇ : Type u_1) : Commute x (exp ùïÇ y) := by"
  },
  {
    "full_name": "OrthogonalFamily.inner_right_dfinsupp",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
    "teorema": "theorem OrthogonalFamily.inner_right_dfinsupp (E : Type u_2) (G : Œπ ‚Üí Type u_5) (V : (i : Œπ) ‚Üí G i ‚Üí‚Çó·µ¢[ùïú] E) (i : Œπ) (l : ‚®Å (i : Œπ), G i) (v : G i) (Œπ : Type u_4) (ùïú : Type u_1) : (DFinsupp.sum l fun j w => if i = j then ‚ü™(V i) v, (V j) w‚ü´_ùïú else 0) = ‚ü™v, l i‚ü´_ùïú := by"
  },
  {
    "full_name": "CategoryTheory.OplaxFunctor.map‚ÇÇ_eqToHom",
    "file_path": "Mathlib/CategoryTheory/Bicategory/LocallyDiscrete.lean",
    "teorema": "lemma CategoryTheory.OplaxFunctor.map‚ÇÇ_eqToHom (B : Type u‚ÇÅ) (C : Type u‚ÇÇ) (F : OplaxFunctor B C) (a : B) (b : B) (f : a ‚ü∂ b) (g : a ‚ü∂ b) (h : f = g) : F.map‚ÇÇ (eqToHom h) = eqToHom ‚ãØ := by"
  },
  {
    "full_name": "Finset.aestronglyMeasurable_prod",
    "file_path": "Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean",
    "teorema": "lemma Finset.aestronglyMeasurable_prod (M : Type u_5) (f : Œπ ‚Üí Œ± ‚Üí M) (s : Finset Œπ) (Œ± : Type u_1) (Œπ : Type u_6) (Œº : Measure Œ±) : AEStronglyMeasurable (fun a => ‚àè i ‚àà s, f i a) Œº := by"
  },
  {
    "full_name": "Int.ediv_two_mul_two_add_one_of_odd",
    "file_path": "Mathlib/Algebra/Ring/Int.lean",
    "teorema": "theorem Int.ediv_two_mul_two_add_one_of_odd (n : ‚Ñ§) : Odd n ‚Üí n / 2 * 2 + 1 = n := by"
  },
  {
    "full_name": "hasFTaylorSeriesUpToOn_pi",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "lemma hasFTaylorSeriesUpToOn_pi (E : Type uE) (F : Type uF) (m : ‚Ñï‚àû) (n : ‚Ñï‚àû) (p : E ‚Üí FormalMultilinearSeries ùïú E F) (s : Set E) (x : E) (Œπ : Type u_3) (œÜ : (i : Œπ) ‚Üí E ‚Üí F' i) (ùïú : Type u_1) : HasFTaylorSeriesUpToOn n (fun x i => œÜ i x) (fun x m => ContinuousMultilinearMap.pi fun i => p' i x m) s ‚Üî := by"
  },
  {
    "full_name": "IsGŒ¥.iInter",
    "file_path": "Mathlib/Topology/GDelta.lean",
    "teorema": "theorem IsGŒ¥.iInter (X : Type u_1) (s : Œπ' ‚Üí Set X) (Œπ : Type u_3) : IsGŒ¥ (‚ãÇ i, s i) := by"
  },
  {
    "full_name": "Finset.biUnion_singleton",
    "file_path": "Mathlib/Data/Finset/Image.lean",
    "teorema": "theorem Finset.biUnion_singleton (a : Œ±) (f : Œ± ‚Üí Œ≤) (s : Finset Œ±) (x : Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (x ‚àà s.biUnion fun a => {f a}) ‚Üî x ‚àà image f s := by"
  },
  {
    "full_name": "MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_quotientMeasure",
    "file_path": "Mathlib/MeasureTheory/Group/FundamentalDomain.lean",
    "teorema": "lemma MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_quotientMeasure (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_3) (ŒΩ : Measure Œ±) : Measure.map (Quotient.mk Œ±_mod_G) (ŒΩ.restrict s) = Measure.map (Quotient.mk Œ±_mod_G) (ŒΩ.restrict t) := by"
  },
  {
    "full_name": "Sum.isLeft_swap",
    "file_path": ".lake/packages/batteries/Batteries/Data/Sum/Lemmas.lean",
    "teorema": "lemma Sum.isLeft_swap (x : Œ± ‚äï Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : x.swap.isLeft = x.isRight := by"
  },
  {
    "full_name": "MeasureTheory.SignedMeasure.eq_singularPart",
    "file_path": "Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean",
    "teorema": "theorem MeasureTheory.SignedMeasure.eq_singularPart (s : SignedMeasure Œ±) (t : SignedMeasure Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : t = s.singularPart Œº := by"
  },
  {
    "full_name": "PFun.mem_fix_iff",
    "file_path": "Mathlib/Data/PFun.lean",
    "teorema": "theorem PFun.mem_fix_iff (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí. Œ≤ ‚äï Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : Sum.inl b ‚àà f a ‚à® ‚àÉ a', Sum.inr a' ‚àà f a ‚àß b ‚àà f.fix a' := by"
  },
  {
    "full_name": "Equiv.Perm.apply_pow_apply_eq_iff",
    "file_path": "Mathlib/GroupTheory/Perm/Support.lean",
    "teorema": "theorem Equiv.Perm.apply_pow_apply_eq_iff (f : Perm Œ±) (n : ‚Ñï) (x : Œ±) (Œ± : Type u_1) : f ((f ^ n) x) = (f ^ n) x ‚Üî f x = x := by"
  },
  {
    "full_name": "Finset.pimage_eq_image_filter",
    "file_path": "Mathlib/Data/Finset/PImage.lean",
    "teorema": "theorem Finset.pimage_eq_image_filter (f : Œ± ‚Üí. Œ≤) (s : Finset Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : pimage f s = image (fun x => (f ‚Üëx).get ‚ãØ) (filter (fun x => (f x).Dom) s).attach := by"
  },
  {
    "full_name": "MonovaryOn.sum_mul_sum_le_card_mul_sum",
    "file_path": "Mathlib/Algebra/Order/Chebyshev.lean",
    "teorema": "lemma MonovaryOn.sum_mul_sum_le_card_mul_sum (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ±) (s : Finset Œπ) (Œ± : Type u_2) (Œπ : Type u_1) : (‚àë i ‚àà s, f i) * ‚àë i ‚àà s, g i ‚â§ ‚Üës.card * ‚àë i ‚àà s, f i * g i := by"
  },
  {
    "full_name": "ContinuousLinearMap.reApplyInnerSelf_smul",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
    "teorema": "lemma ContinuousLinearMap.reApplyInnerSelf_smul (E : Type u_2) (T : E ‚ÜíL[ùïú] E) (c : ùïú) (x : E) (ùïú : Type u_1) : T.reApplyInnerSelf (c ‚Ä¢ x) = ‚Äñc‚Äñ ^ 2 * T.reApplyInnerSelf x := by"
  },
  {
    "full_name": "Set.Infinite.exists_superset_ncard_eq",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "lemma Set.Infinite.exists_superset_ncard_eq (k : ‚Ñï) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) : ‚àÉ s', s ‚äÜ s' ‚àß s' ‚äÜ t ‚àß s'.ncard = k := by"
  },
  {
    "full_name": "rank_fun_infinite",
    "file_path": "Mathlib/LinearAlgebra/Dimension/DivisionRing.lean",
    "teorema": "theorem rank_fun_infinite (K : Type u) (Œπ : Type v) : Module.rank K (Œπ ‚Üí K) = #(Œπ ‚Üí K) := by"
  },
  {
    "full_name": "Grp.SurjectiveOfEpiAuxs.mul_smul",
    "file_path": "Mathlib/Algebra/Category/Grp/EpiMono.lean",
    "teorema": "theorem Grp.SurjectiveOfEpiAuxs.mul_smul (A : Grp) (B : Grp) (b : ‚ÜëB) (f : A ‚ü∂ B) (x : X') (y : ‚Üë(Set.range fun x => x ‚Ä¢ ‚Üë(MonoidHom.range f))) : (b * b') ‚Ä¢ fromCoset y = b ‚Ä¢ b' ‚Ä¢ fromCoset y := by"
  },
  {
    "full_name": "isAlgebraic_algebraMap",
    "file_path": "Mathlib/RingTheory/Algebraic.lean",
    "teorema": "lemma isAlgebraic_algebraMap (A : Type v) (R : Type u) (x : R) : (aeval ((algebraMap R A) x)) (X - C x) = 0 := by"
  },
  {
    "full_name": "List.toFinset_nonempty_iff",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma List.toFinset_nonempty_iff (l : List Œ±) (Œ± : Type u_1) : l.toFinset.Nonempty ‚Üî l ‚â† [] := by"
  },
  {
    "full_name": "MeasureTheory.Lp.cauchySeq_Lp_iff_cauchySeq_‚Ñíp",
    "file_path": "Mathlib/MeasureTheory/Function/LpSpace.lean",
    "teorema": "theorem MeasureTheory.Lp.cauchySeq_Lp_iff_cauchySeq_‚Ñíp (E : Type u_2) (f : Œπ ‚Üí ‚Ü•(Lp E p Œº)) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œπ : Type u_5) (Œº : Measure Œ±) : CauchySeq f ‚Üî Tendsto (fun n => snorm (‚Üë‚Üë(f n.1) - ‚Üë‚Üë(f n.2)) p Œº) atTop (ùìù 0) := by"
  },
  {
    "full_name": "PiTensorProduct.injectiveSeminorm_le_projectiveSeminorm",
    "file_path": "Mathlib/Analysis/NormedSpace/PiTensorProduct/InjectiveSeminorm.lean",
    "teorema": "theorem PiTensorProduct.injectiveSeminorm_le_projectiveSeminorm : injectiveSeminorm ‚â§ projectiveSeminorm := by"
  },
  {
    "full_name": "LinearMap.BilinForm.comp_symmCompOfNondegenerate_apply",
    "file_path": "Mathlib/LinearAlgebra/BilinearForm/Properties.lean",
    "teorema": "theorem LinearMap.BilinForm.comp_symmCompOfNondegenerate_apply (B‚ÇÅ : BilinForm K V) (B‚ÇÇ : BilinForm K V) (K : Type u_6) (V : Type u_5) (b‚ÇÇ : B‚ÇÇ.Nondegenerate) (v : V) : B‚ÇÇ ((B‚ÇÅ.symmCompOfNondegenerate B‚ÇÇ b‚ÇÇ) v) = B‚ÇÅ v := by"
  },
  {
    "full_name": "IsGLB.biUnion_Ici_eq_Ioi",
    "file_path": "Mathlib/Order/Interval/Set/Disjoint.lean",
    "teorema": "theorem IsGLB.biUnion_Ici_eq_Ioi (a : Œ±) (s : Set Œ±) (Œ± : Type v) : ‚ãÉ x ‚àà s, Ici x = Ioi a := by"
  },
  {
    "full_name": "one_add_mul_self_le_rpow_one_add",
    "file_path": "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean",
    "teorema": "theorem one_add_mul_self_le_rpow_one_add (p : ‚Ñù) (s : ‚Ñù) : 1 + p * s ‚â§ (1 + s) ^ p := by"
  },
  {
    "full_name": "ImplicitFunctionData.map_nhds_eq",
    "file_path": "Mathlib/Analysis/Calculus/Implicit.lean",
    "teorema": "theorem ImplicitFunctionData.map_nhds_eq (E : Type u_2) (F : Type u_3) (G : Type u_4) (œÜ : ImplicitFunctionData ùïú E F G) (ùïú : Type u_1) : map (Prod.fst ‚àò œÜ.prodFun) (ùìù œÜ.pt) = ùìù (œÜ.prodFun œÜ.pt).1 := by"
  },
  {
    "full_name": "CircleDeg1Lift.tendsto_translationNumber",
    "file_path": "Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean",
    "teorema": "theorem CircleDeg1Lift.tendsto_translationNumber (f : CircleDeg1Lift) (x : ‚Ñù) : Tendsto (fun n => ((f ^ n) x - x) / ‚Üën) atTop (ùìù (œÑ f)) := by"
  },
  {
    "full_name": "MeasureTheory.addHaar_image_le_mul_of_det_lt",
    "file_path": "Mathlib/MeasureTheory/Function/Jacobian.lean",
    "teorema": "lemma MeasureTheory.addHaar_image_le_mul_of_det_lt (A : E ‚ÜíL[‚Ñù] E) (E : Type u_1) (f : E ‚Üí E) (m : ‚Ñù‚â•0) (s : Set E) (Œº : Measure E) : ‚àÄ·∂† (Œ¥ : ‚Ñù‚â•0) in ùìù[>] 0, ‚àÄ (s : Set E) (f : E ‚Üí E), ApproximatesLinearOn f A s Œ¥ ‚Üí Œº (f '' s) ‚â§ ‚Üëm * Œº s := by"
  },
  {
    "full_name": "CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv",
    "file_path": "Mathlib/CategoryTheory/Limits/IsLimit.lean",
    "teorema": "lemma CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv (C : Type u‚ÇÉ) (F : J ‚•§ C) (J : Type u‚ÇÅ) (P : IsLimit s) (Q : IsLimit t) (r : Cone F) (s : Cone F) (t : Cone F) : ‚àÄ (j : J), (Q.lift r ‚â´ (P.conePointUniqueUpToIso Q).inv) ‚â´ s.œÄ.app j = r.œÄ.app j := by"
  },
  {
    "full_name": "List.Nat.map_swap_antidiagonal",
    "file_path": "Mathlib/Data/List/NatAntidiagonal.lean",
    "teorema": "theorem List.Nat.map_swap_antidiagonal (n : ‚Ñï) : map Prod.swap (antidiagonal n) = (antidiagonal n).reverse := by"
  },
  {
    "full_name": "Matrix.det_fromBlocks_zero‚ÇÅ‚ÇÇ",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
    "teorema": "theorem Matrix.det_fromBlocks_zero‚ÇÅ‚ÇÇ (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R) (R : Type v) (m : Type u_1) (n : Type u_2) : (fromBlocks A 0 C D).det = A.det * D.det := by"
  },
  {
    "full_name": "Submonoid.LocalizationMap.mk'_eq_iff_eq'",
    "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean",
    "teorema": "theorem Submonoid.LocalizationMap.mk'_eq_iff_eq' (M : Type u_1) (N : Type u_2) (S : Submonoid M) (f : S.LocalizationMap N) (x‚ÇÅ : M) (x‚ÇÇ : M) (y‚ÇÅ : ‚Ü•S) (y‚ÇÇ : ‚Ü•S) : f.mk' x‚ÇÅ y‚ÇÅ = f.mk' x‚ÇÇ y‚ÇÇ ‚Üî f.toMap (x‚ÇÅ * ‚Üëy‚ÇÇ) = f.toMap (x‚ÇÇ * ‚Üëy‚ÇÅ) := by"
  },
  {
    "full_name": "FirstOrder.Language.Formula.realize_relabel",
    "file_path": "Mathlib/ModelTheory/Semantics.lean",
    "teorema": "lemma FirstOrder.Language.Formula.realize_relabel (L : Language) (M : Type w) (g : Œ± ‚Üí Œ≤) (v : Œ≤ ‚Üí M) (Œ± : Type u') (Œ≤ : Type v') (œÜ : L.Formula Œ±) : (relabel g œÜ).Realize v ‚Üî œÜ.Realize (v ‚àò g) := by"
  },
  {
    "full_name": "mul_dvd_mul_iff_left",
    "file_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
    "teorema": "lemma mul_dvd_mul_iff_left (a : Œ±) (b : Œ±) (c : Œ±) (d : Œ±) (Œ± : Type u_1) : a * c = a * b * d ‚Üî c = b * d := by"
  },
  {
    "full_name": "Cardinal.one_lt_ofENat",
    "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean",
    "teorema": "theorem Cardinal.one_lt_ofENat (m : ‚Ñï‚àû) : 1 < ‚Üëm ‚Üî 1 < m := by"
  },
  {
    "full_name": "WeierstrassCurve.Œ¶_ofNat",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "teorema": "lemma WeierstrassCurve.Œ¶_ofNat (R : Type r) (W : WeierstrassCurve R) (n : ‚Ñï) : W.Œ¶ (‚Üën + 1) = (X * W.preŒ®' (n + 1) ^ 2 * if Even n then 1 else W.Œ®‚ÇÇSq) - W.preŒ®' (n + 2) * W.preŒ®' n * if Even n then W.Œ®‚ÇÇSq else 1 := by"
  },
  {
    "full_name": "Nat.one_add_div_two_mul_two_of_odd",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "theorem Nat.one_add_div_two_mul_two_of_odd (n : ‚Ñï) : 1 + n / 2 * 2 = n := by"
  },
  {
    "full_name": "Finset.pow_subset_pow",
    "file_path": "Mathlib/Data/Finset/Pointwise.lean",
    "teorema": "lemma Finset.pow_subset_pow (s : Finset Œ±) (t : Finset Œ±) (Œ± : Type u_2) : s ^ 0 ‚äÜ t ^ 0 := by"
  },
  {
    "full_name": "WithTop.add_top",
    "file_path": "Mathlib/Algebra/Order/Monoid/WithTop.lean",
    "teorema": "theorem WithTop.add_top (a : WithTop Œ±) (Œ± : Type u) : a + ‚ä§ = ‚ä§ := by"
  },
  {
    "full_name": "List.IsSuffix.filter",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "theorem List.IsSuffix.filter (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (p : Œ± ‚Üí Bool) (Œ± : Type u_1) : List.filter p l‚ÇÅ <:+ List.filter p l‚ÇÇ := by"
  },
  {
    "full_name": "smul_lt_of_lt_one_left",
    "file_path": "Mathlib/Algebra/Order/Module/Defs.lean",
    "teorema": "theorem smul_lt_of_lt_one_left (a : Œ±) (b : Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : a ‚Ä¢ b < b := by"
  },
  {
    "full_name": "Polynomial.IsSplittingField.of_algEquiv",
    "file_path": "Mathlib/FieldTheory/SplittingField/IsSplittingField.lean",
    "teorema": "lemma Polynomial.IsSplittingField.of_algEquiv (K : Type v) (L : Type w) (p : K[X]) : IsSplittingField K L p := by"
  },
  {
    "full_name": "Summable.mul_of_nonneg",
    "file_path": "Mathlib/Analysis/Normed/Field/InfiniteSum.lean",
    "teorema": "theorem Summable.mul_of_nonneg (f : Œπ ‚Üí ‚Ñù) (g : Œπ' ‚Üí ‚Ñù) (Œπ : Type u_2) : Summable fun x => ‚àë' (y : Œπ'), f (x, y).1 * g (x, y).2 := by"
  },
  {
    "full_name": "Nat.ModEq.mul_right_cancel'",
    "file_path": "Mathlib/Data/Nat/ModEq.lean",
    "teorema": "theorem Nat.ModEq.mul_right_cancel' (a : ‚Ñï) (b : ‚Ñï) (c : ‚Ñï) (m : ‚Ñï) : a * c ‚â° b * c [MOD m * c] ‚Üí a ‚â° b [MOD m] := by"
  },
  {
    "full_name": "RCLike.re_ofReal_mul",
    "file_path": "Mathlib/Analysis/RCLike/Basic.lean",
    "teorema": "lemma RCLike.re_ofReal_mul (K : Type u_1) (r : ‚Ñù) (z : K) : re (‚Üër * z) = r * re z := by"
  },
  {
    "full_name": "Finset.Colex.IsInitSeg.exists_initSeg",
    "file_path": "Mathlib/Combinatorics/Colex.lean",
    "teorema": "lemma Finset.Colex.IsInitSeg.exists_initSeg (r : ‚Ñï) (s : Finset Œ±) (Œ± : Type u_1) (ùíú : Finset (Finset Œ±)) : ‚àÉ s, s.card = r ‚àß ùíú = initSeg s := by"
  },
  {
    "full_name": "NonUnitalStarSubalgebra.toNonUnitalSubring_injective",
    "file_path": "Mathlib/Algebra/Star/NonUnitalSubalgebra.lean",
    "teorema": "lemma NonUnitalStarSubalgebra.toNonUnitalSubring_injective (A : Type v) (R : Type u) (S : NonUnitalStarSubalgebra R A) (T : NonUnitalStarSubalgebra R A) (x : A) : x ‚àà S ‚Üî x ‚àà T := by"
  },
  {
    "full_name": "Int.nnnorm_coe_units",
    "file_path": "Mathlib/Analysis/NormedSpace/Int.lean",
    "teorema": "lemma Int.nnnorm_coe_units (e : ‚Ñ§À£) : ‚Äñ‚Üëe‚Äñ‚Çä = 1 := by"
  },
  {
    "full_name": "Cardinal.one_le_lift_iff",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "lemma Cardinal.one_le_lift_iff (a : Cardinal.{u}) : 1 ‚â§ lift.{v, u} a ‚Üî 1 ‚â§ a := by"
  },
  {
    "full_name": "HurwitzZeta.hurwitzZeta_neg_two_mul_nat",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaValues.lean",
    "teorema": "lemma HurwitzZeta.hurwitzZeta_neg_two_mul_nat (k : ‚Ñï) (x : ‚Ñù) : hurwitzZeta (‚Üëx) (-(2 * ‚Üëk)) = -1 / (2 * ‚Üëk + 1) * Polynomial.eval (‚Üëx) (Polynomial.map (algebraMap ‚Ñö ‚ÑÇ) (Polynomial.bernoulli (2 * k + 1))) := by"
  },
  {
    "full_name": "irrational_sqrt_two",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "lemma irrational_sqrt_two : Irrational ‚àö2 := by"
  },
  {
    "full_name": "equicontinuous_restrict_iff",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "theorem equicontinuous_restrict_iff (F : Œπ ‚Üí X ‚Üí Œ±) (S : Set X) (X : Type u_3) (Œ± : Type u_7) (Œπ : Type u_1) : Equicontinuous (S.restrict ‚àò F) ‚Üî EquicontinuousOn F S := by"
  },
  {
    "full_name": "ENNReal.trichotomy‚ÇÇ",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "teorema": "lemma ENNReal.trichotomy‚ÇÇ (p : ‚Ñù‚â•0‚àû) (q : ‚Ñù‚â•0‚àû) : p = 0 ‚àß q = 0 ‚à® p = 0 ‚àß q = ‚ä§ ‚à® p = 0 ‚àß 0 < q.toReal ‚à® p = ‚ä§ ‚àß q = ‚ä§ ‚à® 0 < p.toReal ‚àß q = ‚ä§ ‚à® 0 < p.toReal ‚àß 0 < q.toReal ‚àß p.toReal ‚â§ q.toReal := by"
  },
  {
    "full_name": "Filter.Tendsto.mul_atTop",
    "file_path": "Mathlib/Topology/Algebra/Order/Field.lean",
    "teorema": "theorem Filter.Tendsto.mul_atTop (f : Œ± ‚Üí ùïú) (g : Œ± ‚Üí ùïú) (l : Filter Œ±) (Œ± : Type u_2) (ùïú : Type u_1) : Tendsto (fun x => f x * g x) l atTop := by"
  },
  {
    "full_name": "HasFPowerSeriesOnBall.prod",
    "file_path": "Mathlib/Analysis/Analytic/Constructions.lean",
    "teorema": "lemma HasFPowerSeriesOnBall.prod (E : Type u_3) (F : Type u_4) (G : Type u_5) (p : FormalMultilinearSeries ùïú E F) (q : FormalMultilinearSeries ùïú E G) (r : ‚Ñù‚â•0‚àû) (s : ‚Ñù‚â•0‚àû) (ùïú : Type u_2) : min r s ‚â§ (p.prod q).radius := by"
  },
  {
    "full_name": "elementalStarAlgebra.starAlgHomClass_ext",
    "file_path": "Mathlib/Topology/Algebra/StarSubalgebra.lean",
    "teorema": "theorem elementalStarAlgebra.starAlgHomClass_ext (F : Type u_4) (œÜ : F) (œà : F) : œÜ = œà := by"
  },
  {
    "full_name": "PiLp.nnnorm_equiv_symm_single",
    "file_path": "Mathlib/Analysis/NormedSpace/PiLp.lean",
    "teorema": "lemma PiLp.nnnorm_equiv_symm_single (b : Œ≤ i) (i : Œπ) (p : ‚Ñù‚â•0‚àû) (Œ≤ : Œπ ‚Üí Type u_4) (Œπ : Type u_2) : ‚Äñ(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b)‚Äñ‚Çä = ‚Äñb‚Äñ‚Çä := by"
  },
  {
    "full_name": "GaussianInt.natAbs_norm_eq",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
    "teorema": "lemma GaussianInt.natAbs_norm_eq (x : ‚Ñ§[i]) : Int.ofNat (norm x).natAbs = Int.ofNat (x.re.natAbs * x.re.natAbs + x.im.natAbs * x.im.natAbs) := by"
  },
  {
    "full_name": "Function.IsPeriodicPt.gcd",
    "file_path": "Mathlib/Dynamics/PeriodicPts.lean",
    "teorema": "theorem Function.IsPeriodicPt.gcd (f : Œ± ‚Üí Œ±) (m : ‚Ñï) (n : ‚Ñï) (x : Œ±) (Œ± : Type u_1) : IsPeriodicPt f (m.gcd n) x := by"
  },
  {
    "full_name": "ProbabilityTheory.measure_le_le_exp_mul_mgf",
    "file_path": "Mathlib/Probability/Moments.lean",
    "teorema": "lemma ProbabilityTheory.measure_le_le_exp_mul_mgf (X : Œ© ‚Üí ‚Ñù) (t : ‚Ñù) (Œ© : Type u_1) (Œµ : ‚Ñù) (Œº : Measure Œ©) : (Œº {œâ | X œâ ‚â§ Œµ}).toReal ‚â§ rexp (-t * Œµ) * mgf X Œº t := by"
  },
  {
    "full_name": "Module.injective_module_of_injective_object",
    "file_path": "Mathlib/Algebra/Module/Injective.lean",
    "teorema": "theorem Module.injective_module_of_injective_object (Q : Type v) (R : Type u) (X : Type v) (Y : Type v) (f : X ‚Üí‚Çó[R] Y) (g : X ‚Üí‚Çó[R] Q) : ‚àÉ h, ‚àÄ (x : X), h (f x) = g x := by"
  },
  {
    "full_name": "isCompact_iff_ultrafilter_le_nhds'",
    "file_path": "Mathlib/Topology/Compactness/Compact.lean",
    "teorema": "theorem isCompact_iff_ultrafilter_le_nhds' (X : Type u) (s : Set X) : IsCompact s ‚Üî ‚àÄ (f : Ultrafilter X), s ‚àà f ‚Üí ‚àÉ x ‚àà s, ‚Üëf ‚â§ ùìù x := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_max",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "theorem MeasureTheory.lintegral_max (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (g : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±), max (f x) (g x) ‚àÇŒº = ‚à´‚Åª (x : Œ±) in {x | f x ‚â§ g x}, g x ‚àÇŒº + ‚à´‚Åª (x : Œ±) in {x | g x < f x}, f x ‚àÇŒº := by"
  },
  {
    "full_name": "Multiset.prod_add",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
    "teorema": "theorem Multiset.prod_add (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (Œ± : Type u_3) : (‚ü¶l‚ÇÅ‚üß + ‚ü¶l‚ÇÇ‚üß).prod = prod ‚ü¶l‚ÇÅ‚üß * prod ‚ü¶l‚ÇÇ‚üß := by"
  },
  {
    "full_name": "Nat.dist_eq_sub_of_le",
    "file_path": "Mathlib/Data/Nat/Dist.lean",
    "teorema": "theorem Nat.dist_eq_sub_of_le (m : ‚Ñï) (n : ‚Ñï) : n.dist m = m - n := by"
  },
  {
    "full_name": "SeminormFamily.withSeminorms_iff_nhds_eq_iInf",
    "file_path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean",
    "teorema": "theorem SeminormFamily.withSeminorms_iff_nhds_eq_iInf (E : Type u_5) (p : SeminormFamily ùïú E Œπ) (Œπ : Type u_8) (ùïú : Type u_1) : WithSeminorms p ‚Üî ùìù 0 = ‚®Ö i, comap (‚áë(p i)) (ùìù 0) := by"
  },
  {
    "full_name": "MeasureTheory.L1.setToL1_mono",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "lemma MeasureTheory.L1.setToL1_mono (C : ‚Ñù) (G : Type u_5) (T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G'') (f : ‚Ü•(Lp G' 1 Œº)) (g : ‚Ü•(Lp G' 1 Œº)) (hT : DominatedFinMeasAdditive Œº T C) (Œ± : Type u_1) (Œº : Measure Œ±) : (setToL1 hT) f ‚â§ (setToL1 hT) g := by"
  },
  {
    "full_name": "CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget",
    "file_path": "Mathlib/CategoryTheory/Sites/Sheaf.lean",
    "teorema": "theorem CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget (A : Type u‚ÇÇ) (C : Type u‚ÇÅ) (J : GrothendieckTopology C) (P : C·µí·µñ ‚•§ A) (s : A' ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) : IsSheaf J P' ‚Üî IsSheaf J (P' ‚ãô s) := by"
  },
  {
    "full_name": "div_nonneg",
    "file_path": "Mathlib/Algebra/Order/Field/Defs.lean",
    "teorema": "theorem div_nonneg (a : Œ±) (b : Œ±) (Œ± : Type u_1) : 0 ‚â§ a / b := by"
  },
  {
    "full_name": "ZMod.cast_sub_one",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "teorema": "theorem ZMod.cast_sub_one (k : ZMod n) (n : ‚Ñï) : (k - 1).cast = (if k = 0 then ‚Üën else k.cast) - 1 := by"
  },
  {
    "full_name": "UniformOnFun.isClosed_setOf_continuous_of_le",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "teorema": "lemma UniformOnFun.isClosed_setOf_continuous_of_le (u : Set Œ±) (Œ± : Type u_1) : IsOpen u := by"
  },
  {
    "full_name": "CategoryTheory.isIso_unop_iff",
    "file_path": "Mathlib/CategoryTheory/Opposites.lean",
    "teorema": "theorem CategoryTheory.isIso_unop_iff (X : C·µí·µñ) (Y : C·µí·µñ) (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f := by"
  },
  {
    "full_name": "ConvexOn.translate_right",
    "file_path": "Mathlib/Analysis/Convex/Function.lean",
    "teorema": "lemma ConvexOn.translate_right (E : Type u_2) (a : ùïú) (b : ùïú) (c : E) (f : E ‚Üí Œ≤) (x : E) (y : E) (Œ≤ : Type u_5) (ùïú : Type u_1) : f (c + (a ‚Ä¢ x + b ‚Ä¢ y)) = f (a ‚Ä¢ (c + x) + b ‚Ä¢ (c + y)) := by"
  },
  {
    "full_name": "measurableSet_of_differentiableAt_of_isComplete",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Measurable.lean",
    "teorema": "theorem measurableSet_of_differentiableAt_of_isComplete (E : Type u_2) (F : Type u_3) (K : Set (E ‚ÜíL[ùïú] F)) (f : E ‚Üí F) (ùïú : Type u_1) : MeasurableSet {x | DifferentiableAt ùïú f x ‚àß fderiv ùïú f x ‚àà K} := by"
  },
  {
    "full_name": "String.Iterator.ValidFor.prev_nil",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "lemma String.Iterator.ValidFor.prev_nil (it : Iterator) (r : List Char) : ValidFor [] r it.prev := by"
  },
  {
    "full_name": "exists_pos_right_iff_sameRay",
    "file_path": "Mathlib/LinearAlgebra/Ray.lean",
    "teorema": "lemma exists_pos_right_iff_sameRay (M : Type u_2) (R : Type u_1) (x : M) (y : M) : (‚àÉ r, 0 < r ‚àß x = r ‚Ä¢ y) ‚Üî SameRay R x y := by"
  },
  {
    "full_name": "Cardinal.lift_iSup",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "theorem Cardinal.lift_iSup (f : Œπ ‚Üí Cardinal.{w}) (Œπ : Type v) : lift.{u, w} (iSup f) = ‚®Ü i, lift.{u, w} (f i) := by"
  },
  {
    "full_name": "Finset.sum_boole_mul",
    "file_path": "Mathlib/Algebra/BigOperators/Ring.lean",
    "teorema": "lemma Finset.sum_boole_mul (f : Œπ ‚Üí Œ±) (i : Œπ) (s : Finset Œπ) (Œ± : Type u_2) (Œπ : Type u_1) : ‚àë j ‚àà s, (if i = j then 1 else 0) * f j = if i ‚àà s then f i else 0 := by"
  },
  {
    "full_name": "Finset.prod_union",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "theorem Finset.prod_union (f : Œ± ‚Üí Œ≤) (s‚ÇÅ : Finset Œ±) (s‚ÇÇ : Finset Œ±) (Œ± : Type u_3) (Œ≤ : Type u_4) : ‚àè x ‚àà s‚ÇÅ ‚à™ s‚ÇÇ, f x = (‚àè x ‚àà s‚ÇÅ, f x) * ‚àè x ‚àà s‚ÇÇ, f x := by"
  },
  {
    "full_name": "Submodule.ne_bot_iff",
    "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean",
    "teorema": "theorem Submodule.ne_bot_iff (M : Type u_3) (R : Type u_1) (p : Submodule R M) : p ‚â† ‚ä• ‚Üî ‚àÉ x ‚àà p, x ‚â† 0 := by"
  },
  {
    "full_name": "CategoryTheory.Limits.Pi.map_id",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Products.lean",
    "teorema": "lemma CategoryTheory.Limits.Pi.map_id (C : Type u) (f : Œ± ‚Üí C) (Œ± : Type w‚ÇÇ) : (map fun a => ùüô (f a)) = ùüô (‚àè·∂ú f) := by"
  },
  {
    "full_name": "MeasureTheory.le_measure_diff",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
    "teorema": "theorem MeasureTheory.le_measure_diff (s‚ÇÅ : Set Œ±) (s‚ÇÇ : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : Œº (s‚ÇÅ ‚à© s‚ÇÇ) + Œº (s‚ÇÅ \\ s‚ÇÇ) ‚â§ Œº s‚ÇÇ + Œº (s‚ÇÅ \\ s‚ÇÇ) := by"
  },
  {
    "full_name": "Filter.mem_prod_iff_left",
    "file_path": "Mathlib/Order/Filter/Prod.lean",
    "teorema": "theorem Filter.mem_prod_iff_left (f : Filter Œ±) (g : Filter Œ≤) (s : Set (Œ± √ó Œ≤)) (t : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : s ‚àà f √óÀ¢ g ‚Üî ‚àÉ t ‚àà f, ‚àÄ·∂† (y : Œ≤) in g, ‚àÄ x ‚àà t, (x, y) ‚àà s := by"
  },
  {
    "full_name": "MeasureTheory.exists_upperSemicontinuous_le_integral_le",
    "file_path": "Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean",
    "teorema": "lemma MeasureTheory.exists_upperSemicontinuous_le_integral_le : ‚àÉ g, := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.exists_boundedContinuous_lintegral_sub_le",
    "file_path": "Mathlib/MeasureTheory/Function/ContinuousMapDense.lean",
    "teorema": "lemma MeasureTheory.Integrable.exists_boundedContinuous_lintegral_sub_le (E : Type u_2) (f : Œ± ‚Üí E) (Œ± : Type u_1) (Œµ : ‚Ñù‚â•0‚àû) (Œº : Measure Œ±) : ‚àÉ g, ‚à´‚Åª (x : Œ±), ‚Üë‚Äñf x - g x‚Äñ‚Çä ‚àÇŒº ‚â§ Œµ ‚àß Integrable (‚áëg) Œº := by"
  },
  {
    "full_name": "MeasureTheory.SignedMeasure.rnDeriv_neg",
    "file_path": "Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean",
    "teorema": "theorem MeasureTheory.SignedMeasure.rnDeriv_neg (s : SignedMeasure Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : (-s).rnDeriv Œº =·∂†[ae Œº] -s.rnDeriv Œº := by"
  },
  {
    "full_name": "Polynomial.cyclotomic_dvd_geom_sum_of_dvd",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
    "teorema": "lemma Polynomial.cyclotomic_dvd_geom_sum_of_dvd (R : Type u_1) (d : ‚Ñï) (n : ‚Ñï) : cyclotomic d R ‚à£ ‚àë i ‚àà range n, X ^ i := by"
  },
  {
    "full_name": "CovBy.Iio_eq",
    "file_path": "Mathlib/Order/Cover.lean",
    "teorema": "lemma CovBy.Iio_eq (a : Œ±) (b : Œ±) (Œ± : Type u_1) : Iio b = Iic a := by"
  },
  {
    "full_name": "SimpleGraph.CliqueFree.comap",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "teorema": "theorem SimpleGraph.CliqueFree.comap (G : SimpleGraph Œ±) (H : SimpleGraph Œ≤) (n : ‚Ñï) (Œ± : Type u_1) (Œ≤ : Type u_2) : G.CliqueFree n ‚Üí H.CliqueFree n := by"
  },
  {
    "full_name": "unitLattice_rank",
    "file_path": "Mathlib/NumberTheory/NumberField/Units/DirichletTheorem.lean",
    "teorema": "theorem unitLattice_rank (K : Type u_1) : finrank ‚Ñ§ ‚Ü•(unitLattice K) = rank K := by"
  },
  {
    "full_name": "CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal_inv",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
    "teorema": "theorem CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal_inv (C : Type u) (X : C) (t : IsTerminal X) : (zeroIsoIsTerminal t).inv = 0 := by"
  },
  {
    "full_name": "Nat.Coprime.coprime_dvd_left",
    "file_path": ".lake/packages/batteries/Batteries/Data/Nat/Gcd.lean",
    "teorema": "lemma Nat.Coprime.coprime_dvd_left (m : Nat) (n : Nat) : m.Coprime n := by"
  },
  {
    "full_name": "Polynomial.one_lt_rootMultiplicity_iff_isRoot_iterate_derivative",
    "file_path": "Mathlib/Algebra/Polynomial/FieldDivision.lean",
    "teorema": "lemma Polynomial.one_lt_rootMultiplicity_iff_isRoot_iterate_derivative (R : Type u) : ‚Üë(Nat.factorial 1) ‚àà nonZeroDivisors R := by"
  },
  {
    "full_name": "MeasureTheory.GridLines.T_univ",
    "file_path": "Mathlib/Analysis/FunctionalSpaces/SobolevInequality.lean",
    "teorema": "theorem MeasureTheory.GridLines.T_univ (A : Œπ ‚Üí Type u_2) (f : ((i : Œπ) ‚Üí A i) ‚Üí ‚Ñù‚â•0‚àû) (p : ‚Ñù) (x : (i : Œπ) ‚Üí A i) (Œπ : Type u_1) (Œº : (i : Œπ) ‚Üí Measure (A i)) : T Œº p f Finset.univ x = := by"
  },
  {
    "full_name": "IsCyclotomicExtension.iff_singleton",
    "file_path": "Mathlib/NumberTheory/Cyclotomic/Basic.lean",
    "teorema": "lemma IsCyclotomicExtension.iff_singleton (A : Type u) (B : Type v) (n : ‚Ñï+) : IsCyclotomicExtension {n} A B ‚Üî (‚àÉ r, IsPrimitiveRoot r ‚Üën) ‚àß ‚àÄ (x : B), x ‚àà adjoin A {b | b ^ ‚Üën = 1} := by"
  },
  {
    "full_name": "Real.sInf_smul_of_nonneg",
    "file_path": "Mathlib/Data/Real/Pointwise.lean",
    "teorema": "lemma Real.sInf_smul_of_nonneg (a : Œ±) (s : Set ‚Ñù) (Œ± : Type u_2) : sInf (a ‚Ä¢ s) = a ‚Ä¢ sInf s := by"
  },
  {
    "full_name": "MeasurableEmbedding.comap_apply",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "theorem MeasurableEmbedding.comap_apply (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œº : Measure Œ≤) : (Measure.comap f Œº) s = (Measure.comap f Œº) (f ‚Åª¬π' (f '' s)) := by"
  },
  {
    "full_name": "Tropical.add_eq_iff",
    "file_path": "Mathlib/Algebra/Tropical/Basic.lean",
    "teorema": "theorem Tropical.add_eq_iff (R : Type u) (x : Tropical R) (y : Tropical R) (z : Tropical R) : x + y = z ‚Üî x = z ‚àß x ‚â§ y ‚à® y = z ‚àß y ‚â§ x := by"
  },
  {
    "full_name": "counit_eq_from",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Cartesian/Comon_.lean",
    "teorema": "theorem counit_eq_from (A : Comon_ C) (C : Type u) : A.counit = terminal.from A.X := by"
  },
  {
    "full_name": "NonemptyFinLinOrd.mono_iff_injective",
    "file_path": "Mathlib/Order/Category/NonemptyFinLinOrd.lean",
    "teorema": "lemma NonemptyFinLinOrd.mono_iff_injective (A : NonemptyFinLinOrd) (B : NonemptyFinLinOrd) (f : A ‚ü∂ B) : Mono f ‚Üî Function.Injective ‚áëf := by"
  },
  {
    "full_name": "List.Nodup.erase_get",
    "file_path": "Mathlib/Data/List/Nodup.lean",
    "teorema": "lemma List.Nodup.erase_get (i : Fin l.length) (l : List Œ±) (Œ± : Type u) : l.erase (l.get i) = l.eraseIdx ‚Üëi := by"
  },
  {
    "full_name": "OrderIso.bddBelow_preimage",
    "file_path": "Mathlib/Order/GaloisConnection.lean",
    "teorema": "lemma OrderIso.bddBelow_preimage (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) (Œ± : Type u) (Œ≤ : Type v) : BddBelow (‚áëe ‚Åª¬π' s) ‚Üî BddBelow s := by"
  },
  {
    "full_name": "MeasurableEmbedding.comp",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Embedding.lean",
    "teorema": "theorem MeasurableEmbedding.comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : MeasurableSet (g ‚àò f '' s) := by"
  },
  {
    "full_name": "TrivSqZeroExt.inl_mul_eq_smul",
    "file_path": "Mathlib/Algebra/TrivSqZeroExt.lean",
    "teorema": "lemma TrivSqZeroExt.inl_mul_eq_smul (M : Type v) (R : Type u) (r : R) (x : tsze R M) : (inl r * x).snd = (r ‚Ä¢> x).snd := by"
  },
  {
    "full_name": "padicValNat.zero",
    "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
    "teorema": "lemma padicValNat.zero (p : ‚Ñï) : padicValNat p 0 = 0 := by"
  },
  {
    "full_name": "Orientation.rightAngleRotation_neg_orientation",
    "file_path": "Mathlib/Analysis/InnerProductSpace/TwoDim.lean",
    "teorema": "theorem Orientation.rightAngleRotation_neg_orientation (E : Type u_1) (o : Orientation ‚Ñù E (Fin 2)) (x : E) : (-o).rightAngleRotation x = -o.rightAngleRotation x := by"
  },
  {
    "full_name": "CategoryTheory.PreGaloisCategory.AutGalois.ext",
    "file_path": "Mathlib/CategoryTheory/Galois/Prorepresentability.lean",
    "teorema": "lemma CategoryTheory.PreGaloisCategory.AutGalois.ext (C : Type u‚ÇÅ) (F : C ‚•§ FintypeCat) (f : AutGalois F) (g : AutGalois F) : f = g := by"
  },
  {
    "full_name": "AkraBazziRecurrence.growsPolynomially_id",
    "file_path": "Mathlib/Computability/AkraBazzi/GrowsPolynomially.lean",
    "teorema": "lemma AkraBazziRecurrence.growsPolynomially_id : GrowsPolynomially fun x => x := by"
  },
  {
    "full_name": "MeasureTheory.toMeasure_apply‚ÇÄ",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
    "teorema": "theorem MeasureTheory.toMeasure_apply‚ÇÄ (h : ms ‚â§ m.caratheodory) (m : OuterMeasure Œ±) (ms : MeasurableSpace Œ±) (s : Set Œ±) (Œ± : Type u_1) : (m.toMeasure h) s = m s := by"
  },
  {
    "full_name": "IsPrimitiveRoot.pow_eq_one_iff_dvd",
    "file_path": "Mathlib/RingTheory/RootsOfUnity/Basic.lean",
    "teorema": "lemma IsPrimitiveRoot.pow_eq_one_iff_dvd (M : Type u_1) (k : ‚Ñï) (l : ‚Ñï) (Œ∂ : M) : k ‚à£ l ‚Üí Œ∂ ^ l = 1 := by"
  },
  {
    "full_name": "Matrix.toLin_toMatrix",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean",
    "teorema": "theorem Matrix.toLin_toMatrix (M‚ÇÅ : Type u_5) (M‚ÇÇ : Type u_6) (R : Type u_1) (f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ) (m : Type u_3) (n : Type u_4) (v‚ÇÅ : Basis n R M‚ÇÅ) (v‚ÇÇ : Basis m R M‚ÇÇ) : (toLin v‚ÇÅ v‚ÇÇ) ((toMatrix v‚ÇÅ v‚ÇÇ) f) = f := by"
  },
  {
    "full_name": "Submonoid.eq_bot_of_subsingleton",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Operations.lean",
    "teorema": "theorem Submonoid.eq_bot_of_subsingleton (M : Type u_1) (S : Submonoid M) : S = ‚ä• := by"
  },
  {
    "full_name": "MeasureTheory.integral_pos_iff_support_of_nonneg_ae",
    "file_path": "Mathlib/MeasureTheory/Integral/Bochner.lean",
    "teorema": "lemma MeasureTheory.integral_pos_iff_support_of_nonneg_ae (f : Œ± ‚Üí ‚Ñù) (Œ± : Type u_1) (Œº : Measure Œ±) : 0 < ‚à´ (x : Œ±), f x ‚àÇŒº ‚Üî 0 < Œº (Function.support f) := by"
  },
  {
    "full_name": "mem_principal_ideals_iff",
    "file_path": "Mathlib/RingTheory/ClassGroup.lean",
    "teorema": "lemma mem_principal_ideals_iff (I : (FractionalIdeal R‚Å∞ K)À£) (K : Type u_2) (R : Type u_1) : I ‚àà (toPrincipalIdeal R K).range ‚Üî ‚àÉ x, spanSingleton R‚Å∞ x = ‚ÜëI := by"
  },
  {
    "full_name": "Pi.apply_mulSingle",
    "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean",
    "teorema": "lemma Pi.apply_mulSingle (I : Type u) (f : I ‚Üí Type v‚ÇÅ) (i : I) (j : I) (x : f i) : f' j (mulSingle i x j) = mulSingle i (f' i x) j := by"
  },
  {
    "full_name": "NonUnitalStarAlgebra.iInf_toNonUnitalSubalgebra",
    "file_path": "Mathlib/Algebra/Star/NonUnitalSubalgebra.lean",
    "teorema": "lemma NonUnitalStarAlgebra.iInf_toNonUnitalSubalgebra (A : Type v) (R : Type u) (S : Œπ ‚Üí NonUnitalStarSubalgebra R A) (Œπ : Sort u_1) : ‚Üë(‚®Ö i, S i).toNonUnitalSubalgebra = ‚Üë(‚®Ö i, (S i).toNonUnitalSubalgebra) := by"
  },
  {
    "full_name": "StructureGroupoid.LocalInvariantProp.liftPropWithinAt_mono_of_mem",
    "file_path": "Mathlib/Geometry/Manifold/LocalInvariantProperties.lean",
    "teorema": "theorem StructureGroupoid.LocalInvariantProp.liftPropWithinAt_mono_of_mem (H : Type u_1) (M : Type u_2) (P : (H ‚Üí H') ‚Üí Set H ‚Üí H ‚Üí Prop) (g : M ‚Üí M') (t : Set M) (x : M) : LiftPropWithinAt P g t x := by"
  },
  {
    "full_name": "Nat.xor_zero",
    "file_path": "Mathlib/Data/Nat/Bitwise.lean",
    "teorema": "theorem Nat.xor_zero (n : ‚Ñï) : n ^^^ 0 = n := by"
  },
  {
    "full_name": "Subgroup.inf_mul_assoc",
    "file_path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
    "teorema": "lemma Subgroup.inf_mul_assoc (A : Subgroup G) (B : Subgroup G) (C : Subgroup G) (G : Type u_2) : ‚Üë(A ‚äì B) * ‚ÜëC = ‚ÜëA ‚à© (‚ÜëB * ‚ÜëC) := by"
  },
  {
    "full_name": "Set.Infinite.encard_eq",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "lemma Set.Infinite.encard_eq (s : Set Œ±) (Œ± : Type u_1) : s.encard = ‚ä§ := by"
  },
  {
    "full_name": "CategoryTheory.IsKernelPair.comp_of_mono",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/KernelPair.lean",
    "teorema": "lemma CategoryTheory.IsKernelPair.comp_of_mono (C : Type u) (R : C) (X : C) (Y : C) (Z : C) (a : R ‚ü∂ X) (b : R ‚ü∂ X) (f‚ÇÅ : X ‚ü∂ Y) (f‚ÇÇ : Y ‚ü∂ Z) : a ‚â´ f‚ÇÅ ‚â´ f‚ÇÇ = b ‚â´ f‚ÇÅ ‚â´ f‚ÇÇ := by"
  },
  {
    "full_name": "Asymptotics.isLittleO_of_subsingleton",
    "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean",
    "teorema": "lemma Asymptotics.isLittleO_of_subsingleton (E : Type u_3) (F : Type u_4) (c : ‚Ñù) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) (l : Filter Œ±) (Œ± : Type u_1) : ‚àÄ·∂† (x : Œ±) in l, ‚Äñf' x‚Äñ ‚â§ c * ‚Äñg' x‚Äñ := by"
  },
  {
    "full_name": "CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism‚ÇÅ",
    "file_path": "Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean",
    "teorema": "theorem CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism‚ÇÅ (C : Type u) (T‚ÇÅ : Triangle C) (T‚ÇÇ : Triangle C) (b : T‚ÇÅ.obj‚ÇÇ ‚ü∂ T‚ÇÇ.obj‚ÇÇ) (c : T‚ÇÅ.obj‚ÇÉ ‚ü∂ T‚ÇÇ.obj‚ÇÉ) : ‚àÉ a, T‚ÇÅ.mor‚ÇÅ ‚â´ b = a ‚â´ T‚ÇÇ.mor‚ÇÅ ‚àß T‚ÇÅ.mor‚ÇÉ ‚â´ (shiftFunctor C 1).map a = c ‚â´ T‚ÇÇ.mor‚ÇÉ := by"
  },
  {
    "full_name": "InnerProductGeometry.angle_smul_smul",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "teorema": "theorem InnerProductGeometry.angle_smul_smul (V : Type u_1) (c : ‚Ñù) (x : V) (y : V) : angle (c ‚Ä¢ x) (c ‚Ä¢ y) = angle x y := by"
  },
  {
    "full_name": "AffineSubspace.mem_direction_iff_eq_vsub_left",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "lemma AffineSubspace.mem_direction_iff_eq_vsub_left (P : Type u_3) (V : Type u_2) (k : Type u_1) (p : P) (s : AffineSubspace k P) (v : V) : v ‚àà s.direction ‚Üî ‚àÉ p2 ‚àà s, v = p -·µ• p2 := by"
  },
  {
    "full_name": "LinearMap.associated_det_of_eq_comp",
    "file_path": "Mathlib/LinearAlgebra/Determinant.lean",
    "teorema": "theorem LinearMap.associated_det_of_eq_comp (M : Type u_2) (R : Type u_1) (f : M ‚Üí‚Çó[R] M) : Associated (LinearMap.det f) (LinearMap.det f') := by"
  },
  {
    "full_name": "Mathlib.Tactic.Coherence.insert_id_lhs",
    "file_path": "Mathlib/Tactic/CategoryTheory/Coherence.lean",
    "teorema": "theorem Mathlib.Tactic.Coherence.insert_id_lhs (C : Type u_1) (X : C) (Y : C) (f : X ‚ü∂ Y) (g : X ‚ü∂ Y) : f = g := by"
  },
  {
    "full_name": "Nat.squarefree_and_prime_pow_iff_prime",
    "file_path": "Mathlib/Data/Nat/Squarefree.lean",
    "teorema": "theorem Nat.squarefree_and_prime_pow_iff_prime (n : ‚Ñï) : Squarefree n ‚àß IsPrimePow n ‚Üî Prime n := by"
  },
  {
    "full_name": "ProbabilityTheory.evariance_eq_zero_iff",
    "file_path": "Mathlib/Probability/Variance.lean",
    "teorema": "theorem ProbabilityTheory.evariance_eq_zero_iff (X : Œ© ‚Üí ‚Ñù) (Œ© : Type u_1) (Œº : Measure Œ©) : evariance X Œº = 0 ‚Üî X =·∂†[ae Œº] fun x => ‚à´ (x : Œ©), X x ‚àÇŒº := by"
  },
  {
    "full_name": "Real.coe_fib_eq",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "teorema": "theorem Real.coe_fib_eq : ‚àÄ (n : ‚Ñï), ‚Üë(Nat.fib n) = (œÜ ^ n - œà ^ n) / ‚àö5 := by"
  },
  {
    "full_name": "Nat.minFac_eq_two_iff",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "lemma Nat.minFac_eq_two_iff (n : ‚Ñï) : n.minFac = 2 ‚Üî 2 ‚à£ n := by"
  },
  {
    "full_name": "EReal.coe_toReal",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "teorema": "lemma EReal.coe_toReal (x : EReal) : ‚Üëx.toReal = x := by"
  },
  {
    "full_name": "Holor.holor_index_cons_decomp",
    "file_path": "Mathlib/Data/Holor.lean",
    "teorema": "theorem Holor.holor_index_cons_decomp (d : ‚Ñï) (ds : List ‚Ñï) (i : ‚Ñï) (is : List ‚Ñï) : Forall‚ÇÇ (fun x x_1 => x < x_1) (i :: is) (d :: ds) := by"
  },
  {
    "full_name": "ProbabilityTheory.cond_inter_self",
    "file_path": "Mathlib/Probability/ConditionalProbability.lean",
    "teorema": "lemma ProbabilityTheory.cond_inter_self (s : Set Œ©) (t : Set Œ©) (Œ© : Type u_1) (Œº : Measure Œ©) : Œº[|s] (s ‚à© t) = Œº[|s] t := by"
  },
  {
    "full_name": "AdjoinRoot.isAdjoinRootMonic_root_eq_root",
    "file_path": "Mathlib/RingTheory/IsAdjoinRoot.lean",
    "teorema": "lemma AdjoinRoot.isAdjoinRootMonic_root_eq_root (R : Type u) (f : R[X]) (hf : f.Monic) : (AdjoinRoot.isAdjoinRootMonic f hf).root = root f := by"
  },
  {
    "full_name": "contMDiff_prod_iff",
    "file_path": "Mathlib/Geometry/Manifold/ContMDiff/Product.lean",
    "teorema": "theorem contMDiff_prod_iff (E : Type u_2) (F : Type u_11) (G : Type u_12) (H : Type u_3) (I : ModelWithCorners ùïú E H) (J : ModelWithCorners ùïú F G) (M : Type u_4) (N : Type u_13) (f : M ‚Üí M' √ó N') (n : ‚Ñï‚àû) (ùïú : Type u_1) : ContMDiff I (I'.prod J') n f := by"
  },
  {
    "full_name": "Real.GammaIntegral_convergent",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean",
    "teorema": "lemma Real.GammaIntegral_convergent (s : ‚Ñù) : IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Ioi 0) volume := by"
  },
  {
    "full_name": "Polynomial.natDegree_iterate_comp",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Lemmas.lean",
    "teorema": "theorem Polynomial.natDegree_iterate_comp (R : Type u) (k : ‚Ñï) (p : R[X]) (q : R[X]) : (p.comp^[k] q).natDegree = p.natDegree ^ k * q.natDegree := by"
  },
  {
    "full_name": "LieAlgebra.toEnd_pow_apply_mem",
    "file_path": "Mathlib/Algebra/Lie/Weights/Cartan.lean",
    "teorema": "theorem LieAlgebra.toEnd_pow_apply_mem (H : LieSubalgebra R L) (L : Type u_2) (M : Type u_3) (R : Type u_1) (m : M) (n : ‚Ñï) (x : L) (œá‚ÇÅ : ‚Ü•H ‚Üí R) (œá‚ÇÇ : ‚Ü•H ‚Üí R) : ((toEnd R L M) x ^ n) m ‚àà weightSpace M (n ‚Ä¢ œá‚ÇÅ + œá‚ÇÇ) := by"
  },
  {
    "full_name": "hasStrictFDerivAt_exp_zero_of_radius_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Exponential.lean",
    "teorema": "theorem hasStrictFDerivAt_exp_zero_of_radius_pos (ùïÇ : Type u_1) : HasStrictFDerivAt (exp ùïÇ) 1 0 := by"
  },
  {
    "full_name": "HomologicalComplex.pOpcycles_opcyclesIsoSc'_inv",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean",
    "teorema": "theorem HomologicalComplex.pOpcycles_opcyclesIsoSc'_inv (C : Type u_1) (K : HomologicalComplex C c) (c : ComplexShape Œπ) (hi : c.prev j = i) (hk : c.next j = k) (i : Œπ) (j : Œπ) (k : Œπ) (Œπ : Type u_2) : (K.sc' i j k).pOpcycles ‚â´ (K.opcyclesIsoSc' i j k hi hk).inv = K.pOpcycles j := by"
  },
  {
    "full_name": "HasStrictFDerivAt.iterate",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Comp.lean",
    "teorema": "lemma HasStrictFDerivAt.iterate (E : Type u_2) (f : E ‚Üí E) (n : ‚Ñï) (x : E) : HasStrictFDerivAt f^[n] (f' ^ n) x := by"
  },
  {
    "full_name": "PythagoreanTriple.gcd_dvd",
    "file_path": "Mathlib/NumberTheory/PythagoreanTriples.lean",
    "teorema": "lemma PythagoreanTriple.gcd_dvd (x : ‚Ñ§) (y : ‚Ñ§) (z : ‚Ñ§) : ‚Üë(x.gcd y) ‚à£ z := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_eq_top_of_measure_eq_top_ne_zero",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "theorem MeasureTheory.lintegral_eq_top_of_measure_eq_top_ne_zero (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚ä§ = ‚ä§ * Œº {x | ‚ä§ ‚â§ f x} := by"
  },
  {
    "full_name": "ContinuousMap.idealOfSet_closed",
    "file_path": "Mathlib/Topology/ContinuousFunction/Ideals.lean",
    "teorema": "lemma ContinuousMap.idealOfSet_closed (R : Type u_2) (X : Type u_1) (s : Set X) : IsClosed ‚Üë(idealOfSet R s) := by"
  },
  {
    "full_name": "Set.injOn_of_ncard_image_eq",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "theorem Set.injOn_of_ncard_image_eq (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : InjOn f s := by"
  },
  {
    "full_name": "CancelDenoms.neg_subst",
    "file_path": "Mathlib/Tactic/CancelDenoms/Core.lean",
    "teorema": "theorem CancelDenoms.neg_subst (e : Œ±) (n : Œ±) (t : Œ±) (Œ± : Type u_1) : n * -e = -t := by"
  },
  {
    "full_name": "Matrix.transpose_invOf",
    "file_path": "Mathlib/Data/Matrix/Invertible.lean",
    "teorema": "lemma Matrix.transpose_invOf : (‚ÖüA)·µÄ = ‚ÖüA·µÄ := by"
  },
  {
    "full_name": "AddSubmonoid.closure_singleton_zero",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
    "teorema": "lemma AddSubmonoid.closure_singleton_zero : closure {0} = ‚ä• := by"
  },
  {
    "full_name": "isRelPrime_mul_unit_right_right",
    "file_path": "Mathlib/Algebra/Divisibility/Units.lean",
    "teorema": "theorem isRelPrime_mul_unit_right_right (x : Œ±) (y : Œ±) (z : Œ±) (Œ± : Type u_1) : IsRelPrime y (z * x) ‚Üî IsRelPrime y z := by"
  },
  {
    "full_name": "ContinuousLinearMap.comp_cPolynomialOn",
    "file_path": "Mathlib/Analysis/Analytic/CPolynomial.lean",
    "teorema": "theorem ContinuousLinearMap.comp_cPolynomialOn (E : Type u_2) (F : Type u_3) (G : Type u_4) (f : E ‚Üí F) (g : F ‚ÜíL[ùïú] G) (s : Set E) (ùïú : Type u_1) : CPolynomialOn ùïú (‚áëg ‚àò f) s := by"
  },
  {
    "full_name": "CategoryTheory.Sieve.sieveOfSubfunctor_functorInclusion",
    "file_path": "Mathlib/CategoryTheory/Sites/Sieves.lean",
    "teorema": "theorem CategoryTheory.Sieve.sieveOfSubfunctor_functorInclusion (C : Type u‚ÇÅ) (S : Sieve X) (X : C) : sieveOfSubfunctor S.functorInclusion = S := by"
  },
  {
    "full_name": "Commute.add_pow'",
    "file_path": "Mathlib/Data/Nat/Choose/Sum.lean",
    "teorema": "theorem Commute.add_pow' (R : Type u_1) (n : ‚Ñï) (x : R) (y : R) : (x + y) ^ n = ‚àë m ‚àà antidiagonal n, n.choose m.1 ‚Ä¢ (x ^ m.1 * y ^ m.2) := by"
  },
  {
    "full_name": "PadicInt.norm_lt_one_iff_dvd",
    "file_path": "Mathlib/NumberTheory/Padics/PadicIntegers.lean",
    "teorema": "theorem PadicInt.norm_lt_one_iff_dvd (p : ‚Ñï) (x : ‚Ñ§_[p]) : ‚Äñx‚Äñ < 1 ‚Üî ‚Üëp ‚à£ x := by"
  },
  {
    "full_name": "SimpleGraph.Walk.fst_mem_support_of_mem_edges",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
    "teorema": "theorem SimpleGraph.Walk.fst_mem_support_of_mem_edges (G : SimpleGraph V) (V : Type u) (p : G.Walk v w) (t : V) (u : V) (v : V) (w : V) : t ‚àà p.support := by"
  },
  {
    "full_name": "LinearEquiv.rTensor_refl_apply",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean",
    "teorema": "theorem LinearEquiv.rTensor_refl_apply (M : Type u_4) (N : Type u_5) (R : Type u_1) (y : N ‚äó[R] M) : (rTensor M (refl R N)) y = y := by"
  },
  {
    "full_name": "MeasureTheory.SignedMeasure.mutuallySingular_iff",
    "file_path": "Mathlib/MeasureTheory/Decomposition/Jordan.lean",
    "teorema": "theorem MeasureTheory.SignedMeasure.mutuallySingular_iff (s : SignedMeasure Œ±) (t : SignedMeasure Œ±) (Œ± : Type u_1) : s ‚üÇ·µ• t ‚Üî s.totalVariation ‚üÇ‚Çò t.totalVariation := by"
  },
  {
    "full_name": "Complex.natCast_cpow_natCast_mul",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean",
    "teorema": "lemma Complex.natCast_cpow_natCast_mul (m : ‚Ñï) (n : ‚Ñï) (z : ‚ÑÇ) : ‚Üën ^ (‚Üëm * z) = (‚Üën ^ m) ^ z := by"
  },
  {
    "full_name": "CategoryTheory.Limits.MonoCoprod.binaryCofan_inr",
    "file_path": "Mathlib/CategoryTheory/Limits/MonoCoprod.lean",
    "teorema": "lemma CategoryTheory.Limits.MonoCoprod.binaryCofan_inr (A : C) (B : C) (C : Type u_1) (c : BinaryCofan A B) : Mono c.inr := by"
  },
  {
    "full_name": "Filter.tendsto_Iic_atBot",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "lemma Filter.tendsto_Iic_atBot (a : Œ±) (f : Œ≤ ‚Üí ‚Üë(Iic a)) (l : Filter Œ≤) (Œ± : Type u_3) (Œ≤ : Type u_4) : Tendsto f l atBot ‚Üî Tendsto (fun x => ‚Üë(f x)) l atBot := by"
  },
  {
    "full_name": "ContinuousMap.adjoin_id_eq_span_one_add",
    "file_path": "Mathlib/Topology/ContinuousFunction/StoneWeierstrass.lean",
    "teorema": "lemma ContinuousMap.adjoin_id_eq_span_one_add (s : Set ùïú) (ùïú : Type u_2) : ‚Üë(StarAlgebra.adjoin ùïú {restrict s (ContinuousMap.id ùïú)}) = ‚Üë(span ùïú {1}) + ‚Üë(adjoin ùïú {restrict s (ContinuousMap.id ùïú)}) := by"
  },
  {
    "full_name": "List.getElem_range'",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "lemma List.getElem_range' (i : Nat) (m : Nat) : i < m := by"
  },
  {
    "full_name": "StrictConvex.smul_mem_of_zero_mem",
    "file_path": "Mathlib/Analysis/Convex/Strict.lean",
    "teorema": "theorem StrictConvex.smul_mem_of_zero_mem (E : Type u_3) (s : Set E) (t : ùïú) (x : E) (ùïú : Type u_1) : t ‚Ä¢ x ‚àà interior s := by"
  },
  {
    "full_name": "Orthonormal.inner_finsupp_eq_zero",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
    "teorema": "theorem Orthonormal.inner_finsupp_eq_zero (E : Type u_2) (i : Œπ) (l : Œπ ‚Üí‚ÇÄ ùïú) (v : Œπ ‚Üí E) (Œπ : Type u_4) (ùïú : Type u_1) : ‚ü™(Finsupp.total Œπ E ùïú v) l, v i‚ü´_ùïú = 0 := by"
  },
  {
    "full_name": "AddTorsor.connectedSpace",
    "file_path": "Mathlib/Topology/Algebra/MulAction.lean",
    "teorema": "lemma AddTorsor.connectedSpace : IsPreconnected Set.univ := by"
  },
  {
    "full_name": "Polynomial.coeff_prod_of_natDegree_le",
    "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
    "teorema": "lemma Polynomial.coeff_prod_of_natDegree_le (R : Type u) (f : Œπ ‚Üí R[X]) (n : ‚Ñï) (s : Finset Œπ) (Œπ : Type w) : (‚àè i ‚àà s, f i).coeff (s.card * n) = ‚àè i ‚àà s, (f i).coeff n := by"
  },
  {
    "full_name": "Turing.PartrecToTM2.copy_ok",
    "file_path": "Mathlib/Computability/TMToPartrec.lean",
    "teorema": "theorem Turing.PartrecToTM2.copy_ok (a : List Œì') (b : List Œì') (c : List Œì') (d : List Œì') (q : Œõ') (s : Option Œì') : Reaches‚ÇÅ (TM2.step tr) { l := some q.copy, var := s, stk := elim a b c d } := by"
  },
  {
    "full_name": "Subsemiring.coe_sSup_of_directedOn",
    "file_path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
    "teorema": "lemma Subsemiring.coe_sSup_of_directedOn (R : Type u) (S : Set (Subsemiring R)) (x : R) : x ‚àà ‚Üë(sSup S) ‚Üî x ‚àà ‚ãÉ s ‚àà S, ‚Üës := by"
  },
  {
    "full_name": "Dense.open_subset_closure_inter",
    "file_path": "Mathlib/Topology/Basic.lean",
    "teorema": "theorem Dense.open_subset_closure_inter (X : Type u) (s : Set X) (t : Set X) : t = t ‚à© closure s := by"
  },
  {
    "full_name": "Zsqrtd.intCast_val",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/Basic.lean",
    "teorema": "lemma Zsqrtd.intCast_val (n : ‚Ñ§) : ‚Üën = { re := n, im := 0 } := by"
  },
  {
    "full_name": "qrSign.eq_iff_eq",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean",
    "teorema": "lemma qrSign.eq_iff_eq (m : ‚Ñï) (n : ‚Ñï) (x : ‚Ñ§) (y : ‚Ñ§) : qrSign m n * x = y ‚Üî x = qrSign m n * y := by"
  },
  {
    "full_name": "Ideal.ramificationIdx_ne_zero",
    "file_path": "Mathlib/NumberTheory/RamificationInertia.lean",
    "teorema": "theorem Ideal.ramificationIdx_ne_zero (P : Ideal S) (R : Type u) (S : Type v) (f : R ‚Üí+* S) (p : Ideal R) : ramificationIdx f p P ‚â† 0 := by"
  },
  {
    "full_name": "Multiset.singleton_eq_cons_iff",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "theorem Multiset.singleton_eq_cons_iff (a : Œ±) (b : Œ±) (m : Multiset Œ±) (Œ± : Type u_1) : {a} = b ::‚Çò m ‚Üî a = b ‚àß m = 0 := by"
  },
  {
    "full_name": "Metric.tendsto_dist_left_atTop_iff",
    "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean",
    "teorema": "lemma Metric.tendsto_dist_left_atTop_iff (c : Œ±) (f : Œ≤ ‚Üí Œ±) (l : Filter Œ≤) (x : Œ±) (Œ± : Type u) (Œ≤ : Type v) : Tendsto (fun x => dist c (f x)) l atTop ‚Üî Tendsto f l (cobounded Œ±) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.cocone_fac",
    "file_path": "Mathlib/CategoryTheory/Limits/IsLimit.lean",
    "teorema": "lemma CategoryTheory.Limits.IsColimit.OfNatIso.cocone_fac (C : Type u‚ÇÉ) (F : J ‚•§ C) (J : Type u‚ÇÅ) (X : C) (h : coyoneda.obj { unop := X } ‚ãô uliftFunctor.{u‚ÇÅ, v‚ÇÉ} ‚âÖ F.cocones) (s : Cocone F) : (colimitCocone h).extend (homOfCocone h s) = s := by"
  },
  {
    "full_name": "NNRat.den_mul_eq_num",
    "file_path": "Mathlib/Data/NNRat/Defs.lean",
    "teorema": "theorem NNRat.den_mul_eq_num (q : ‚Ñö‚â•0) : ‚Üëq.den * q = ‚Üëq.num := by"
  },
  {
    "full_name": "isOpen_extChartAt_preimage",
    "file_path": "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean",
    "teorema": "lemma isOpen_extChartAt_preimage (E : Type u_2) (H : Type u_4) (I : ModelWithCorners ùïú E H) (M : Type u_3) (s : Set E) (x : M) (ùïú : Type u_1) : IsOpen ((chartAt H x).source ‚à© ‚Üë(extChartAt I x) ‚Åª¬π' s) := by"
  },
  {
    "full_name": "Nat.add_factorial_succ_lt_factorial_add_succ",
    "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
    "teorema": "theorem Nat.add_factorial_succ_lt_factorial_add_succ (i : ‚Ñï) (n : ‚Ñï) : i + (n + 1)! < (i + n + 1)! := by"
  },
  {
    "full_name": "Complex.cosh_zero",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.cosh_zero : cosh 0 = 1 := by"
  },
  {
    "full_name": "Real.Gamma_pos_of_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean",
    "teorema": "lemma Real.Gamma_pos_of_pos (s : ‚Ñù) : 0 < Gamma s := by"
  },
  {
    "full_name": "mem_parallelepiped_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean",
    "teorema": "lemma mem_parallelepiped_iff (E : Type u_3) (v : Œπ ‚Üí E) (x : E) (Œπ : Type u_1) : x ‚àà parallelepiped v ‚Üî ‚àÉ t ‚àà Icc 0 1, x = ‚àë i : Œπ, t i ‚Ä¢ v i := by"
  },
  {
    "full_name": "Polynomial.smeval_X_pow",
    "file_path": "Mathlib/Algebra/Polynomial/Smeval.lean",
    "teorema": "theorem Polynomial.smeval_X_pow (S : Type u_2) (n : ‚Ñï) (x : S) : (X ^ n).smeval x = x ^ n := by"
  },
  {
    "full_name": "Set.infsep_pos",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "teorema": "theorem Set.infsep_pos (s : Set Œ±) (Œ± : Type u_1) : 0 < s.infsep ‚Üî 0 < s.einfsep ‚àß s.einfsep < ‚ä§ := by"
  },
  {
    "full_name": "Ordinal.bsup_eq_blsub_of_lt_succ_limit",
    "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
    "teorema": "theorem Ordinal.bsup_eq_blsub_of_lt_succ_limit (f : (a : Ordinal.{u}) ‚Üí a < o ‚Üí Ordinal.{max u v}) (o : Ordinal.{u}) : o.bsup f = o.blsub f := by"
  },
  {
    "full_name": "Associated.map",
    "file_path": "Mathlib/Algebra/Associated.lean",
    "teorema": "theorem Associated.map (F : Type u_7) (M : Type u_5) (f : F) (x : M) (y : M) : f x ~·µ§ f y := by"
  },
  {
    "full_name": "CategoryTheory.regularTopology.isSheafFor_regular_of_projective",
    "file_path": "Mathlib/CategoryTheory/Sites/Coherent/RegularSheaves.lean",
    "teorema": "lemma CategoryTheory.regularTopology.isSheafFor_regular_of_projective (C : Type u_1) (F : C·µí·µñ ‚•§ Type u_4) (S : Presieve X) (X : C) : IsSheafFor F S := by"
  },
  {
    "full_name": "MeasureTheory.L1.setToL1_congr_left'",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "theorem MeasureTheory.L1.setToL1_congr_left' (C : ‚Ñù) (E : Type u_2) (F : Type u_3) (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) (f : ‚Ü•(Lp E 1 Œº)) (hT : DominatedFinMeasAdditive Œº T C) (Œ± : Type u_1) (Œº : Measure Œ±) : (setToL1 hT) f = (setToL1 hT') f := by"
  },
  {
    "full_name": "Uniform.continuousWithinAt_iff'_right",
    "file_path": "Mathlib/Topology/UniformSpace/Basic.lean",
    "teorema": "lemma Uniform.continuousWithinAt_iff'_right (b : Œ≤) (f : Œ≤ ‚Üí Œ±) (s : Set Œ≤) (Œ± : Type ua) (Œ≤ : Type ub) : ContinuousWithinAt f s b ‚Üî Tendsto (fun x => (f b, f x)) (ùìù[s] b) (ùì§ Œ±) := by"
  },
  {
    "full_name": "Orthonormal.inner_sum",
    "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
    "teorema": "theorem Orthonormal.inner_sum (E : Type u_2) (l‚ÇÅ : Œπ ‚Üí ùïú) (l‚ÇÇ : Œπ ‚Üí ùïú) (s : Finset Œπ) (v : Œπ ‚Üí E) (Œπ : Type u_4) (ùïú : Type u_1) : ‚ü™‚àë i ‚àà s, l‚ÇÅ i ‚Ä¢ v i, ‚àë i ‚àà s, l‚ÇÇ i ‚Ä¢ v i‚ü´_ùïú = ‚àë i ‚àà s, (starRingEnd ùïú) (l‚ÇÅ i) * l‚ÇÇ i := by"
  },
  {
    "full_name": "Real.Angle.toReal_coe_eq_self_sub_two_pi_iff",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "theorem Real.Angle.toReal_coe_eq_self_sub_two_pi_iff (Œ∏ : ‚Ñù) : (‚ÜëŒ∏).toReal = Œ∏ - 2 * œÄ ‚Üî Œ∏ ‚àà Set.Ioc œÄ (3 * œÄ) := by"
  },
  {
    "full_name": "Nat.mem_divisorsAntidiagonal",
    "file_path": "Mathlib/NumberTheory/Divisors.lean",
    "teorema": "theorem Nat.mem_divisorsAntidiagonal (n : ‚Ñï) (x : ‚Ñï √ó ‚Ñï) : x ‚àà n.divisorsAntidiagonal ‚Üî x.1 * x.2 = n ‚àß n ‚â† 0 := by"
  },
  {
    "full_name": "Filter.nhds_nhds",
    "file_path": "Mathlib/Topology/Filter.lean",
    "teorema": "lemma Filter.nhds_nhds (X : Type u_4) (x : X) : ùìù (ùìù x) = ‚®Ö s, ‚®Ö (_ : IsOpen s), ‚®Ö (_ : x ‚àà s), ùìü (Iic (ùìü s)) := by"
  },
  {
    "full_name": "CategoryTheory.Idempotents.Karoubi.p_comm",
    "file_path": "Mathlib/CategoryTheory/Idempotents/Karoubi.lean",
    "teorema": "theorem CategoryTheory.Idempotents.Karoubi.p_comm (C : Type u_1) (P : Karoubi C) (Q : Karoubi C) (f : P.Hom Q) : P.p ‚â´ f.f = f.f ‚â´ Q.p := by"
  },
  {
    "full_name": "QuadraticForm.IsOrtho.zero_left",
    "file_path": "Mathlib/LinearAlgebra/QuadraticForm/Basic.lean",
    "teorema": "lemma QuadraticForm.IsOrtho.zero_left (M : Type u_4) (Q : QuadraticForm R M) (R : Type u_3) (x : M) : Q.IsOrtho 0 x := by"
  },
  {
    "full_name": "prod_mul_tprod_subtype_compl",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Group.lean",
    "teorema": "lemma prod_mul_tprod_subtype_compl (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : (‚àè x ‚àà s, f x) * ‚àè' (x : { x // x ‚àâ s }), f ‚Üëx = ‚àè' (x : Œ≤), f x := by"
  },
  {
    "full_name": "affineSpan_pair_le_of_mem_of_mem",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "lemma affineSpan_pair_le_of_mem_of_mem (P : Type u_3) (k : Type u_1) (p‚ÇÅ : P) (p‚ÇÇ : P) (s : AffineSubspace k P) : affineSpan k {p‚ÇÅ, p‚ÇÇ} ‚â§ s := by"
  },
  {
    "full_name": "Real.cos_pi_div_two_sub",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
    "teorema": "lemma Real.cos_pi_div_two_sub (x : ‚Ñù) : cos (œÄ / 2 - x) = sin x := by"
  },
  {
    "full_name": "IsPGroup.of_injective",
    "file_path": "Mathlib/GroupTheory/PGroup.lean",
    "teorema": "lemma IsPGroup.of_injective (H : Type u_2) (p : ‚Ñï) : IsPGroup p H := by"
  },
  {
    "full_name": "Set.singleton_op_unop",
    "file_path": "Mathlib/Data/Set/Opposite.lean",
    "teorema": "lemma Set.singleton_op_unop (x : Œ±) (Œ± : Type u_1) : {{ unop := x }}.unop = {x} := by"
  },
  {
    "full_name": "WithTop.lt_iff_exists_coe",
    "file_path": "Mathlib/Order/WithBot.lean",
    "teorema": "lemma WithTop.lt_iff_exists_coe (a : WithTop Œ±) (b : WithTop Œ±) (Œ± : Type u_1) : a < b ‚Üî ‚àÉ p, a = ‚Üëp ‚àß ‚Üëp < b := by"
  },
  {
    "full_name": "Submodule.mapQ_zero",
    "file_path": "Mathlib/LinearAlgebra/Quotient.lean",
    "teorema": "theorem Submodule.mapQ_zero (M : Type u_2) (M‚ÇÇ : Type u_4) (R : Type u_1) (R‚ÇÇ : Type u_3) (p : Submodule R M) (q : Submodule R‚ÇÇ M‚ÇÇ) : p ‚â§ comap 0 q := by"
  },
  {
    "full_name": "HasFTaylorSeriesUpToOn.zero_eq'",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean",
    "teorema": "lemma HasFTaylorSeriesUpToOn.zero_eq' (E : Type uE) (F : Type uF) (f : E ‚Üí F) (p : E ‚Üí FormalMultilinearSeries ùïú E F) (u : Set E) (x : E) (ùïú : Type u) : p x 0 = (continuousMultilinearCurryFin0 ùïú E F).symm (f x) := by"
  },
  {
    "full_name": "CategoryTheory.Adjunction.unit_leftAdjointUniq_hom",
    "file_path": "Mathlib/CategoryTheory/Adjunction/Unique.lean",
    "teorema": "theorem CategoryTheory.Adjunction.unit_leftAdjointUniq_hom (C : Type u_1) (D : Type u_2) (F : C ‚•§ D) (G : D ‚•§ C) (adj1 : F ‚ä£ G) (adj2 : F' ‚ä£ G) : adj1.unit ‚â´ whiskerRight (adj1.leftAdjointUniq adj2).hom G = adj2.unit := by"
  },
  {
    "full_name": "PiTensorProduct.liftAux_tprod",
    "file_path": "Mathlib/LinearAlgebra/PiTensorProduct.lean",
    "teorema": "lemma PiTensorProduct.liftAux_tprod (E : Type u_9) (R : Type u_4) (f : (i : Œπ) ‚Üí s i) (s : Œπ ‚Üí Type u_7) (Œπ : Type u_1) (œÜ : MultilinearMap R s E) : (liftAux œÜ) ((tprod R) f) = œÜ f := by"
  },
  {
    "full_name": "aemeasurable_of_re_im",
    "file_path": "Mathlib/MeasureTheory/Function/SpecialFunctions/RCLike.lean",
    "teorema": "theorem aemeasurable_of_re_im (f : Œ± ‚Üí ùïú) (Œ± : Type u_1) (Œº : MeasureTheory.Measure Œ±) (ùïú : Type u_2) : AEMeasurable f Œº := by"
  },
  {
    "full_name": "HomologicalComplex.homologyMap_neg",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean",
    "teorema": "theorem HomologicalComplex.homologyMap_neg (C : Type u_1) (K : HomologicalComplex C c) (L : HomologicalComplex C c) (c : ComplexShape Œπ) (i : Œπ) (Œπ : Type u_2) (œÜ : K ‚ü∂ L) : homologyMap (-œÜ) i = -homologyMap œÜ i := by"
  },
  {
    "full_name": "Equiv.Perm.subtypePerm_zpow",
    "file_path": "Mathlib/GroupTheory/Perm/Basic.lean",
    "teorema": "theorem Equiv.Perm.subtypePerm_zpow (f : Perm Œ±) (hf : ‚àÄ (x : Œ±), p x ‚Üî p (f x)) (n : ‚Ñ§) (p : Œ± ‚Üí Prop) (Œ± : Type u) : f.subtypePerm hf ^ n = (f ^ n).subtypePerm ‚ãØ := by"
  },
  {
    "full_name": "summable_indicator_mod_iff_summable",
    "file_path": "Mathlib/Analysis/SumOverResidueClass.lean",
    "teorema": "lemma summable_indicator_mod_iff_summable (R : Type u_1) (f : ‚Ñï ‚Üí R) (k : ‚Ñï) (m : ‚Ñï) : Summable ({n | ‚Üën = ‚Üëk}.indicator f) ‚Üî Summable fun n => f (m * n + k) := by"
  },
  {
    "full_name": "eq_of_fderiv_eq",
    "file_path": "Mathlib/Analysis/Calculus/MeanValue.lean",
    "teorema": "theorem eq_of_fderiv_eq (E : Type u_5) (G : Type u_4) (f : E ‚Üí G) (g : E ‚Üí G) : f = g := by"
  },
  {
    "full_name": "FinEnum.mem_toList",
    "file_path": "Mathlib/Data/FinEnum.lean",
    "teorema": "lemma FinEnum.mem_toList (x : Œ±) (Œ± : Type u) : x ‚àà toList Œ± := by"
  },
  {
    "full_name": "Polynomial.erase_ne",
    "file_path": "Mathlib/Algebra/Polynomial/Basic.lean",
    "teorema": "theorem Polynomial.erase_ne (R : Type u) (i : ‚Ñï) (n : ‚Ñï) (p : R[X]) : (erase n p).coeff i = p.coeff i := by"
  },
  {
    "full_name": "MeasureTheory.Measure.haar.index_empty",
    "file_path": "Mathlib/MeasureTheory/Measure/Haar/Basic.lean",
    "teorema": "lemma MeasureTheory.Measure.haar.index_empty (G : Type u_1) (V : Set G) : index ‚àÖ V = 0 := by"
  },
  {
    "full_name": "Finset.map_subtype_embedding_Iio",
    "file_path": "Mathlib/Order/Interval/Finset/Defs.lean",
    "teorema": "theorem Finset.map_subtype_embedding_Iio (a : Subtype p) (p : Œ± ‚Üí Prop) (Œ± : Type u_1) : map (Embedding.subtype p) (Iio a) = Iio ‚Üëa := by"
  },
  {
    "full_name": "MeasureTheory.VectorMeasure.MutuallySingular.smul_right",
    "file_path": "Mathlib/MeasureTheory/Measure/VectorMeasure.lean",
    "teorema": "lemma MeasureTheory.VectorMeasure.MutuallySingular.smul_right (N : Type u_5) (R : Type u_6) (r : R) (t : Set Œ±) (w : VectorMeasure Œ± N) (Œ± : Type u_1) : ‚Üë(r ‚Ä¢ w) t = 0 := by"
  },
  {
    "full_name": "CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists",
    "file_path": "Mathlib/CategoryTheory/Filtered/Final.lean",
    "teorema": "theorem CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (F : C ‚•§ D) (d : D) : IsCofiltered (CostructuredArrow F d) := by"
  },
  {
    "full_name": "AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion.isoRestrict_hom_ofRestrict",
    "file_path": "Mathlib/Geometry/RingedSpace/OpenImmersion.lean",
    "teorema": "lemma AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion.isoRestrict_hom_ofRestrict (X : LocallyRingedSpace) (Y : LocallyRingedSpace) (f : X ‚ü∂ Y) : (isoRestrict f).hom ‚â´ Y.ofRestrict ‚ãØ = f := by"
  },
  {
    "full_name": "Lagrange.basis_eq_prod_sub_inv_mul_nodal_div",
    "file_path": "Mathlib/LinearAlgebra/Lagrange.lean",
    "teorema": "theorem Lagrange.basis_eq_prod_sub_inv_mul_nodal_div (F : Type u_1) (i : Œπ) (s : Finset Œπ) (v : Œπ ‚Üí F) (Œπ : Type u_2) : Lagrange.basis s v i = C (nodalWeight s v i) * (nodal s v / (X - C (v i))) := by"
  },
  {
    "full_name": "Rat.divInt_div_divInt_cancel_right",
    "file_path": "Mathlib/Algebra/Ring/Rat.lean",
    "teorema": "lemma Rat.divInt_div_divInt_cancel_right (d : ‚Ñ§) (n : ‚Ñ§) (x : ‚Ñ§) : x /. n / (x /. d) = d /. n := by"
  },
  {
    "full_name": "Matrix.TransvectionStruct.mul_inv",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Transvection.lean",
    "teorema": "theorem Matrix.TransvectionStruct.mul_inv (R : Type u‚ÇÇ) (n : Type u_1) (t : TransvectionStruct n R) : t.toMatrix * t.inv.toMatrix = 1 := by"
  },
  {
    "full_name": "AddGroupWithOne.ext",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "teorema": "theorem AddGroupWithOne.ext (R : Type u) (inst‚ÇÅ : AddGroupWithOne R) (inst‚ÇÇ : AddGroupWithOne R) : inst‚ÇÅ = inst‚ÇÇ := by"
  },
  {
    "full_name": "EMetric.hausdorffEdist_closure",
    "file_path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean",
    "teorema": "theorem EMetric.hausdorffEdist_closure (s : Set Œ±) (t : Set Œ±) (u : Set Œ±) (Œ± : Type u) : hausdorffEdist (closure s) (closure t) = hausdorffEdist s t := by"
  },
  {
    "full_name": "FiberBundleCore.mem_trivChange_source",
    "file_path": "Mathlib/Topology/FiberBundle/Basic.lean",
    "teorema": "theorem FiberBundleCore.mem_trivChange_source (B : Type u_2) (F : Type u_3) (Z : FiberBundleCore Œπ B F) (i : Œπ) (j : Œπ) (p : B √ó F) (Œπ : Type u_1) : p ‚àà (Z.trivChange i j).source ‚Üî p.1 ‚àà Z.baseSet i ‚à© Z.baseSet j := by"
  },
  {
    "full_name": "Profinite.NobelingProof.CC_comp_zero",
    "file_path": "Mathlib/Topology/Category/Profinite/Nobeling.lean",
    "teorema": "lemma Profinite.NobelingProof.CC_comp_zero (C : Set (I ‚Üí Bool)) (I : Type u) (ho : o < Ordinal.type fun x x_1 => x < x_1) (hsC : contained C (Order.succ o)) (o : Ordinal.{u}) : ‚àÄ (y : LocallyConstant ‚Üë(œÄ C fun x => ord I x < o) ‚Ñ§), (Linear_CC' C hsC ho) ((œÄs C o) y) = 0 := by"
  },
  {
    "full_name": "hyperoperation_ge_two_eq_self",
    "file_path": "Mathlib/Data/Nat/Hyperoperation.lean",
    "teorema": "theorem hyperoperation_ge_two_eq_self (m : ‚Ñï) (n : ‚Ñï) : hyperoperation (n + 2) m 1 = m := by"
  },
  {
    "full_name": "SetTheory.PGame.le_zero",
    "file_path": "Mathlib/SetTheory/Game/PGame.lean",
    "teorema": "lemma SetTheory.PGame.le_zero (x : PGame) : x ‚â§ 0 ‚Üî ‚àÄ (i : x.LeftMoves), ‚àÉ j, (x.moveLeft i).moveRight j ‚â§ 0 := by"
  },
  {
    "full_name": "Filter.tendsto_div_const_atBot_of_pos",
    "file_path": "Mathlib/Order/Filter/AtTopBot.lean",
    "teorema": "lemma Filter.tendsto_div_const_atBot_of_pos (f : Œ≤ ‚Üí Œ±) (l : Filter Œ≤) (r : Œ±) (Œ± : Type u_3) (Œ≤ : Type u_4) : Tendsto (fun x => f x / r) l atBot ‚Üî Tendsto f l atBot := by"
  },
  {
    "full_name": "MeasureTheory.MeasurePreserving.restrict_preimage_emb",
    "file_path": "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean",
    "teorema": "lemma MeasureTheory.MeasurePreserving.restrict_preimage_emb (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œºa : Measure Œ±) (Œºb : Measure Œ≤) : map f (Œºa.restrict (f ‚Åª¬π' s)) = Œºb.restrict s := by"
  },
  {
    "full_name": "FreeGroup.Red.Step.cons_cons_iff",
    "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean",
    "teorema": "theorem FreeGroup.Red.Step.cons_cons_iff (L‚ÇÅ : List (Œ± √ó Bool)) (L‚ÇÇ : List (Œ± √ó Bool)) (Œ± : Type u) : ‚àÄ {p : Œ± √ó Bool}, Step (p :: L‚ÇÅ) (p :: L‚ÇÇ) ‚Üî Step L‚ÇÅ L‚ÇÇ := by"
  },
  {
    "full_name": "FirstOrder.Language.Term.realize_lt",
    "file_path": "Mathlib/ModelTheory/Order.lean",
    "teorema": "theorem FirstOrder.Language.Term.realize_lt (L : Language) (M : Type w') (n : ‚Ñï) (t‚ÇÅ : L.Term (Œ± ‚äï Fin n)) (t‚ÇÇ : L.Term (Œ± ‚äï Fin n)) (v : Œ± ‚Üí M) (xs : Fin n ‚Üí M) (Œ± : Type w) : (t‚ÇÅ.lt t‚ÇÇ).Realize v xs ‚Üî realize (Sum.elim v xs) t‚ÇÅ < realize (Sum.elim v xs) t‚ÇÇ := by"
  },
  {
    "full_name": "MeasurableEmbedding.prod_mk_right",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "lemma MeasurableEmbedding.prod_mk_right (f : Œ≥ ‚Üí Œ≤) (x : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_7) (Œ≥ : Type u_8) : Injective fun y => (f y, x) := by"
  },
  {
    "full_name": "ValuationSubring.coe_mem_principalUnitGroup_iff",
    "file_path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean",
    "teorema": "lemma ValuationSubring.coe_mem_principalUnitGroup_iff (A : ValuationSubring K) (K : Type u) (x : ‚Ü•A.unitGroup) : ‚Üëx ‚àà A.principalUnitGroup ‚Üî A.unitGroupMulEquiv x ‚àà (Units.map ‚Üë(LocalRing.residue ‚Ü•A)).ker := by"
  },
  {
    "full_name": "Polynomial.mirror_eq_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Mirror.lean",
    "teorema": "lemma Polynomial.mirror_eq_zero (R : Type u_1) (p : R[X]) : p = 0 := by"
  },
  {
    "full_name": "LinearMap.prod_eq_sup_map",
    "file_path": "Mathlib/LinearAlgebra/Prod.lean",
    "teorema": "theorem LinearMap.prod_eq_sup_map (M : Type v) (M‚ÇÇ : Type w) (R : Type u) (p : Submodule R M) (q : Submodule R M‚ÇÇ) : p.prod q = map (inl R M M‚ÇÇ) p ‚äî map (inr R M M‚ÇÇ) q := by"
  },
  {
    "full_name": "Multiset.card_coe",
    "file_path": "Mathlib/Data/Multiset/Fintype.lean",
    "teorema": "lemma Multiset.card_coe (m : Multiset Œ±) (Œ± : Type u_1) : Fintype.card m.ToType = card m := by"
  },
  {
    "full_name": "TopologicalSpace.IsSeparable.mono",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "lemma TopologicalSpace.IsSeparable.mono (u : Set Œ±) (Œ± : Type u) : IsSeparable u := by"
  },
  {
    "full_name": "Polynomial.trailingCoeff_mul",
    "file_path": "Mathlib/Algebra/Polynomial/Reverse.lean",
    "teorema": "lemma Polynomial.trailingCoeff_mul (R : Type u_2) (p : R[X]) (q : R[X]) : (p * q).trailingCoeff = p.trailingCoeff * q.trailingCoeff := by"
  },
  {
    "full_name": "FirstOrder.Language.constantsOnMap_isExpansionOn",
    "file_path": "Mathlib/ModelTheory/LanguageMap.lean",
    "teorema": "theorem FirstOrder.Language.constantsOnMap_isExpansionOn (M : Type w) (f : Œ± ‚Üí Œ≤) (Œ± : Type u') (Œ≤ : Type v') : (LHom.constantsOnMap f).IsExpansionOn M := by"
  },
  {
    "full_name": "Real.arccos_le_pi",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean",
    "teorema": "lemma Real.arccos_le_pi (x : ‚Ñù) : arccos x ‚â§ œÄ := by"
  },
  {
    "full_name": "MeasureTheory.NullMeasurableSet.right_of_prod",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "theorem MeasureTheory.NullMeasurableSet.right_of_prod (t : Set Œ≤) (Œ≤ : Type u_3) (ŒΩ : Measure Œ≤) : NullMeasurableSet t ŒΩ := by"
  },
  {
    "full_name": "WithZero.map'_map'",
    "file_path": "Mathlib/Algebra/GroupWithZero/WithZero.lean",
    "teorema": "theorem WithZero.map'_map' (f : Œ± ‚Üí* Œ≤) (g : Œ≤ ‚Üí* Œ≥) (x : WithZero Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : (map' g) ((map' f) x) = (map' (g.comp f)) x := by"
  },
  {
    "full_name": "Polynomial.prod_multiset_X_sub_C_dvd",
    "file_path": "Mathlib/Algebra/Polynomial/Roots.lean",
    "teorema": "theorem Polynomial.prod_multiset_X_sub_C_dvd (R : Type u) (a : R) (p : R[X]) : (Multiset.map (fun a => X - C a) p.roots).prod ‚à£ p := by"
  },
  {
    "full_name": "Computation.map_think",
    "file_path": "Mathlib/Data/Seq/Computation.lean",
    "teorema": "lemma Computation.map_think (al : ‚àÄ ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éa : Œ±‚¶Ñ, s n = some a ‚Üí s (n + 1) = some a) (f : Œ± ‚Üí Œ≤) (s : Stream' (Option Œ±)) (Œ± : Type u) (Œ≤ : Type v) : map f (think ‚ü®s, al‚ü©) = (map f ‚ü®s, al‚ü©).think := by"
  },
  {
    "full_name": "UniqueFactorizationMonoid.factors_one",
    "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean",
    "teorema": "lemma UniqueFactorizationMonoid.factors_one : factors 1 = 0 := by"
  },
  {
    "full_name": "Nat.eq_prime_pow_of_unique_prime_dvd",
    "file_path": "Mathlib/Data/Nat/Factors.lean",
    "teorema": "theorem Nat.eq_prime_pow_of_unique_prime_dvd (n : ‚Ñï) (p : ‚Ñï) : n = p ^ n.factors.length := by"
  },
  {
    "full_name": "antivary_iff_smul_rearrangement",
    "file_path": "Mathlib/Algebra/Order/Monovary.lean",
    "teorema": "lemma antivary_iff_smul_rearrangement (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œπ : Type u_1) : Monovary f (‚áëOrderDual.toDual ‚àò g) ‚Üî ‚àÄ (i j : Œπ), f i ‚Ä¢ g i + f j ‚Ä¢ g j ‚â§ f i ‚Ä¢ g j + f j ‚Ä¢ g i := by"
  },
  {
    "full_name": "DFinsupp.subset_support_tsub",
    "file_path": "Mathlib/Data/DFinsupp/Order.lean",
    "teorema": "lemma DFinsupp.subset_support_tsub (f : Œ†‚ÇÄ (i : Œπ), Œ± i) (g : Œ†‚ÇÄ (i : Œπ), Œ± i) (i : Œπ) (Œ± : Œπ ‚Üí Type u_2) (Œπ : Type u_1) : f.support \\ g.support ‚äÜ (f - g).support := by"
  },
  {
    "full_name": "Module.End.exp_ne_zero_of_hasGenEigenvalue",
    "file_path": "Mathlib/LinearAlgebra/Eigenspace/Basic.lean",
    "teorema": "lemma Module.End.exp_ne_zero_of_hasGenEigenvalue (k : ‚Ñï) : k ‚â† 0 := by"
  },
  {
    "full_name": "Rel.image_eq_dom_of_codomain_subset",
    "file_path": "Mathlib/Data/Rel.lean",
    "teorema": "theorem Rel.image_eq_dom_of_codomain_subset (r : Rel Œ± Œ≤) (s : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : r.preimage s = r.dom := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_nnnorm_zero",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "theorem MeasureTheory.lintegral_nnnorm_zero (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±), ‚Üë‚Äñ0‚Äñ‚Çä ‚àÇŒº = 0 := by"
  },
  {
    "full_name": "tprod_setProd_singleton_right",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean",
    "teorema": "theorem tprod_setProd_singleton_right (c : Œ≥) (f : Œ≤ √ó Œ≥ ‚Üí Œ±) (s : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : ‚àè' (x : ‚Üë(s √óÀ¢ {c})), f ‚Üëx = ‚àè' (b : ‚Üës), f (‚Üëb, c) := by"
  },
  {
    "full_name": "Set.not_bounded_iff",
    "file_path": "Mathlib/Order/RelClasses.lean",
    "teorema": "theorem Set.not_bounded_iff (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Set Œ±) (Œ± : Type u) : ¬¨Bounded r s ‚Üî Unbounded r s := by"
  },
  {
    "full_name": "PiTensorProduct.reindex_symm",
    "file_path": "Mathlib/LinearAlgebra/PiTensorProduct.lean",
    "teorema": "theorem PiTensorProduct.reindex_symm (M : Type u_8) (R : Type u_4) (e : Œπ ‚âÉ Œπ‚ÇÇ) (Œπ : Type u_1) (Œπ‚ÇÇ : Type u_2) : (reindex R (fun x => M) e).symm = reindex R (fun x => M) e.symm := by"
  },
  {
    "full_name": "MeasureTheory.Integrable.comp_snd_map_prod_id",
    "file_path": "Mathlib/Probability/Kernel/Condexp.lean",
    "teorema": "theorem MeasureTheory.Integrable.comp_snd_map_prod_id (F : Type u_2) (f : Œ© ‚Üí F) (Œ© : Type u_1) (Œº : Measure Œ©) : Integrable (fun x => f x.2) (Measure.map (fun œâ => (id œâ, id œâ)) Œº) := by"
  },
  {
    "full_name": "Fin.rev_pred",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "teorema": "theorem Fin.rev_pred (h : i ‚â† 0) (i : Fin (n + 1)) (n : ‚Ñï) : (i.pred h).rev = i.rev.castPred h' := by"
  },
  {
    "full_name": "iterateFrobenius_mul_apply",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "teorema": "theorem iterateFrobenius_mul_apply (R : Type u) (m : ‚Ñï) (n : ‚Ñï) (p : ‚Ñï) (x : R) : (iterateFrobenius R p (m * n)) x = (‚áë(iterateFrobenius R p m))^[n] x := by"
  },
  {
    "full_name": "Real.cos_pos_of_mem_Ioo",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
    "teorema": "lemma Real.cos_pos_of_mem_Ioo (x : ‚Ñù) : 0 < x + œÄ / 2 := by"
  },
  {
    "full_name": "Equiv.forall_congr_right",
    "file_path": "Mathlib/Logic/Equiv/Defs.lean",
    "teorema": "lemma Equiv.forall_congr_right (a : Œ≤) (q : Œ≤ ‚Üí Prop) (Œ≤ : Sort v) : q a := by"
  },
  {
    "full_name": "Nat.count_modEq_card",
    "file_path": "Mathlib/Data/Int/CardIntervalMod.lean",
    "teorema": "lemma Nat.count_modEq_card (b : ‚Ñï) (r : ‚Ñï) (v : ‚Ñï) : count (fun x => x ‚â° v [MOD r]) b = b / r + if v % r < b % r then 1 else 0 := by"
  },
  {
    "full_name": "MeasureTheory.ae_restrict_biUnion_iff",
    "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean",
    "teorema": "lemma MeasureTheory.ae_restrict_biUnion_iff (p : Œ± ‚Üí Prop) (s : Œπ ‚Üí Set Œ±) (t : Set Œπ) (Œ± : Type u_2) (Œπ : Type u_6) (Œº : Measure Œ±) : (‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict (‚ãÉ i ‚àà t, s i), p x) ‚Üî ‚àÄ i ‚àà t, ‚àÄ·µê (x : Œ±) ‚àÇŒº.restrict (s i), p x := by"
  },
  {
    "full_name": "DirectSum.Gmodule.one_smul'",
    "file_path": "Mathlib/Algebra/Module/GradedModule.lean",
    "teorema": "lemma DirectSum.Gmodule.one_smul' (M : ŒπB ‚Üí Type u_4) (x : ‚®Å (i : ŒπB), M i) (ŒπB : Type u_2) : 1 ‚Ä¢ x = x := by"
  },
  {
    "full_name": "PartialEquiv.image_source_inter_eq",
    "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean",
    "teorema": "theorem PartialEquiv.image_source_inter_eq (e : PartialEquiv Œ± Œ≤) (s : Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : ‚Üëe '' (e.source ‚à© s) = e.target ‚à© ‚Üëe.symm ‚Åª¬π' (e.source ‚à© s) := by"
  },
  {
    "full_name": "Subgroup.IsComplement.equiv_one",
    "file_path": "Mathlib/GroupTheory/Complement.lean",
    "teorema": "lemma Subgroup.IsComplement.equiv_one (G : Type u_1) (S : Set G) (T : Set G) (hST : IsComplement S T) (hs1 : 1 ‚àà S) (ht1 : 1 ‚àà T) : hST.equiv 1 = (‚ü®1, hs1‚ü©, ‚ü®1, ht1‚ü©) := by"
  },
  {
    "full_name": "isPathConnected_range",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "teorema": "lemma isPathConnected_range (X : Type u_1) (Y : Type u_2) (f : X ‚Üí Y) : IsPathConnected (range f) := by"
  },
  {
    "full_name": "GroupFilterBasis.N_one",
    "file_path": "Mathlib/Topology/Algebra/FilterBasis.lean",
    "teorema": "theorem GroupFilterBasis.N_one (B : GroupFilterBasis G) (G : Type u) : B.N 1 = toFilterBasis.filter := by"
  },
  {
    "full_name": "Real.log_nat_eq_sum_factorization",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "teorema": "theorem Real.log_nat_eq_sum_factorization (n : ‚Ñï) : log ‚Üën = n.factorization.sum fun p t => ‚Üët * log ‚Üëp := by"
  },
  {
    "full_name": "FloorRing.exists_prime_mul_pow_lt_factorial",
    "file_path": "Mathlib/Algebra/Order/Floor/Prime.lean",
    "teorema": "lemma FloorRing.exists_prime_mul_pow_lt_factorial (K : Type u_1) (a : K) (c : K) (n : ‚Ñï) : ‚àÉ p > n, Nat.Prime p ‚àß a * c ^ p < ‚Üë(p - 1)! := by"
  },
  {
    "full_name": "Real.tan_div_sqrt_one_add_tan_sq",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Real.tan_div_sqrt_one_add_tan_sq (x : ‚Ñù) : tan x / ‚àö(1 + tan x ^ 2) = sin x := by"
  },
  {
    "full_name": "LinearMap.isCompl_range_inl_inr",
    "file_path": "Mathlib/LinearAlgebra/Prod.lean",
    "teorema": "theorem LinearMap.isCompl_range_inl_inr (M : Type v) (M‚ÇÇ : Type w) (R : Type u) : IsCompl (range (inl R M M‚ÇÇ)) (range (inr R M M‚ÇÇ)) := by"
  },
  {
    "full_name": "SimpleGraph.Subgraph.coe_degree",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean",
    "teorema": "lemma SimpleGraph.Subgraph.coe_degree (G : SimpleGraph V) (V : Type u) (v : ‚ÜëG'.verts) : G'.coe.degree v = G'.degree ‚Üëv := by"
  },
  {
    "full_name": "ConvexOn.le_right_of_left_le'",
    "file_path": "Mathlib/Analysis/Convex/Function.lean",
    "teorema": "lemma ConvexOn.le_right_of_left_le' (E : Type u_2) (a : ùïú) (b : ùïú) (f : E ‚Üí Œ≤) (x : E) (y : E) (Œ≤ : Type u_5) (ùïú : Type u_1) : f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ f y := by"
  },
  {
    "full_name": "SymAlg.unsym_mul_self",
    "file_path": "Mathlib/Algebra/Symmetrized.lean",
    "teorema": "theorem SymAlg.unsym_mul_self (a : Œ±À¢ ∏·µê) : unsym (a * a) = unsym a * unsym a := by"
  },
  {
    "full_name": "neg_eq_neg_one_mul",
    "file_path": "Mathlib/Algebra/Ring/Defs.lean",
    "teorema": "theorem neg_eq_neg_one_mul (a : Œ±) (Œ± : Type u) : -a = -1 * a := by"
  },
  {
    "full_name": "FunctionField.inftyValuation.X",
    "file_path": "Mathlib/NumberTheory/FunctionField.lean",
    "teorema": "theorem FunctionField.inftyValuation.X (Fq : Type) : inftyValuationDef Fq RatFunc.X = ‚Üë(Multiplicative.ofAdd 1) := by"
  },
  {
    "full_name": "FintypeCat.Skeleton.is_skeletal",
    "file_path": "Mathlib/CategoryTheory/FintypeCat.lean",
    "teorema": "lemma FintypeCat.Skeleton.is_skeletal (X : Skeleton) (Y : Skeleton) (h : X ‚âÖ Y) : Function.LeftInverse (fun x => (h.inv { down := x }).down) fun x => (h.hom { down := x }).down := by"
  },
  {
    "full_name": "Stream'.WSeq.head_cons",
    "file_path": "Mathlib/Data/Seq/WSeq.lean",
    "teorema": "lemma Stream'.WSeq.head_cons (a : Œ±) (s : WSeq Œ±) (Œ± : Type u) : (cons a s).head = Computation.pure (some a) := by"
  },
  {
    "full_name": "PosNum.cast_succ",
    "file_path": "Mathlib/Data/Num/Lemmas.lean",
    "teorema": "theorem PosNum.cast_succ (n : PosNum) : ‚Üën.succ = ‚Üën + 1 := by"
  },
  {
    "full_name": "Batteries.RBNode.Ordered.setRed",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "teorema": "lemma Batteries.RBNode.Ordered.setRed (cmp : Œ± ‚Üí Œ± ‚Üí Ordering) (t : RBNode Œ±) (Œ± : Type u_1) : Ordered cmp t.setRed ‚Üî Ordered cmp t := by"
  },
  {
    "full_name": "Directed.convex_iUnion",
    "file_path": "Mathlib/Analysis/Convex/Basic.lean",
    "teorema": "theorem Directed.convex_iUnion (E : Type u_2) (s : Œπ ‚Üí Set E) (Œπ : Sort u_5) (ùïú : Type u_1) : Convex ùïú (‚ãÉ i, s i) := by"
  },
  {
    "full_name": "Field.lift_rank_mul_lift_sepDegree_of_isSeparable",
    "file_path": "Mathlib/FieldTheory/PurelyInseparable.lean",
    "teorema": "lemma Field.lift_rank_mul_lift_sepDegree_of_isSeparable (E : Type v) (F : Type u) (K : Type w) : Cardinal.lift.{w, v} (Module.rank F E) * Cardinal.lift.{v, w} (sepDegree E K) = Cardinal.lift.{v, w} (sepDegree F K) := by"
  },
  {
    "full_name": "MeasureTheory.AEEqFun.toGerm_injective",
    "file_path": "Mathlib/MeasureTheory/Function/AEEqFun.lean",
    "teorema": "lemma MeasureTheory.AEEqFun.toGerm_injective (f : Œ± ‚Üí‚Çò[Œº] Œ≤) (g : Œ± ‚Üí‚Çò[Œº] Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) : ‚Üë‚Üëf = ‚Üë‚Üëg := by"
  },
  {
    "full_name": "Finset.Icc_subset_Icc_iff",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "teorema": "lemma Finset.Icc_subset_Icc_iff (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÅ : Œ±) (b‚ÇÇ : Œ±) (Œ± : Type u_2) : Icc a‚ÇÅ b‚ÇÅ ‚äÜ Icc a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÇ ‚â§ a‚ÇÅ ‚àß b‚ÇÅ ‚â§ b‚ÇÇ := by"
  },
  {
    "full_name": "EuclideanGeometry.oangle_rotate_sign",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean",
    "teorema": "lemma EuclideanGeometry.oangle_rotate_sign (P : Type u_2) (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) : (‚à° p‚ÇÇ p‚ÇÉ p‚ÇÅ).sign = (‚à° p‚ÇÅ p‚ÇÇ p‚ÇÉ).sign := by"
  },
  {
    "full_name": "MeasureTheory.unifIntegrable_subsingleton",
    "file_path": "Mathlib/MeasureTheory/Function/UniformIntegrable.lean",
    "teorema": "lemma MeasureTheory.unifIntegrable_subsingleton (f : Œπ ‚Üí Œ± ‚Üí Œ≤) (p : ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œπ : Type u_3) (Œº : Measure Œ±) : UnifIntegrable f p Œº := by"
  },
  {
    "full_name": "Matrix.zero_vecMul",
    "file_path": "Mathlib/Data/Matrix/Basic.lean",
    "teorema": "theorem Matrix.zero_vecMul (A : Matrix m n Œ±) (m : Type u_2) (n : Type u_3) (Œ± : Type v) : 0 ·µ•* A = 0 := by"
  },
  {
    "full_name": "Subgroup.normalClosure_le_normal",
    "file_path": "Mathlib/Algebra/Group/Subgroup/Basic.lean",
    "teorema": "theorem Subgroup.normalClosure_le_normal (G : Type u_1) (N : Subgroup G) (s : Set G) : normalClosure s ‚â§ N := by"
  },
  {
    "full_name": "OrderEmbedding.birkhoffSet_apply",
    "file_path": "Mathlib/Order/Birkhoff.lean",
    "teorema": "theorem OrderEmbedding.birkhoffSet_apply (a : Œ±) (Œ± : Type u_1) : birkhoffSet a = ‚Üë(OrderIso.lowerSetSupIrred a) := by"
  },
  {
    "full_name": "Batteries.RBNode.Path.zoom_del",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "teorema": "lemma Batteries.RBNode.Path.zoom_del (cut : Œ± ‚Üí Ordering) (path : Path Œ±) (t : RBNode Œ±) (Œ± : Type u_1) : zoom cut t path = (t', path') ‚Üí path.del (RBNode.del cut t) (match t with | node c l v r => c | x => red) = path'.del t'.delRoot (match t' with | node c l v r => c | x => red) := by"
  },
  {
    "full_name": "CategoryTheory.Limits.Types.Pushout.condition",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Types.lean",
    "teorema": "lemma CategoryTheory.Limits.Types.Pushout.condition (S : Type u) (X‚ÇÅ : Type u) (X‚ÇÇ : Type u) (f : S ‚ü∂ X‚ÇÅ) (g : S ‚ü∂ X‚ÇÇ) : f ‚â´ inl f g = g ‚â´ inr f g := by"
  },
  {
    "full_name": "circleIntegral.integral_sub_inv_smul_sub_smul",
    "file_path": "Mathlib/MeasureTheory/Integral/CircleIntegral.lean",
    "teorema": "theorem circleIntegral.integral_sub_inv_smul_sub_smul (E : Type u_1) (R : ‚Ñù) (c : ‚ÑÇ) (f : ‚ÑÇ ‚Üí E) (w : ‚ÑÇ) : (‚àÆ (z : ‚ÑÇ) in C(c, R), (z - w)‚Åª¬π ‚Ä¢ (z - w) ‚Ä¢ f z) = ‚àÆ (z : ‚ÑÇ) in C(c, R), f z := by"
  },
  {
    "full_name": "Set.exists_seq_iSup_eq_top_iff_countable",
    "file_path": "Mathlib/Data/Set/Countable.lean",
    "teorema": "theorem Set.exists_seq_iSup_eq_top_iff_countable (p : Œ± ‚Üí Prop) (Œ± : Type u) : (‚àÉ s, (‚àÄ (n : ‚Ñï), p (s n)) ‚àß ‚®Ü n, s n = ‚ä§) ‚Üî ‚àÉ S, S.Countable ‚àß (‚àÄ s ‚àà S, p s) ‚àß sSup S = ‚ä§ := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_indicator_const‚ÇÄ",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "theorem MeasureTheory.lintegral_indicator_const‚ÇÄ (c : ‚Ñù‚â•0‚àû) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (a : Œ±), s.indicator (fun x => c) a ‚àÇŒº = c * Œº s := by"
  },
  {
    "full_name": "CategoryTheory.Limits.biproduct.whiskerEquiv_inv_eq_lift",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean",
    "teorema": "lemma CategoryTheory.Limits.biproduct.whiskerEquiv_inv_eq_lift (C : Type u) (J : Type w) (K : Type u_1) (e : J ‚âÉ K) (f : J ‚Üí C) (g : K ‚Üí C) (w : (j : J) ‚Üí g (e j) ‚âÖ f j) : (whiskerEquiv e w).inv = lift fun j => œÄ g (e j) ‚â´ (w j).hom := by"
  },
  {
    "full_name": "finrank_eq_one_iff_of_nonzero",
    "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean",
    "teorema": "lemma finrank_eq_one_iff_of_nonzero (K : Type u) (V : Type v) (v : V) : span K {v} = ‚ä§ := by"
  },
  {
    "full_name": "Polynomial.derivative_natCast_mul",
    "file_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
    "teorema": "theorem Polynomial.derivative_natCast_mul (R : Type u) (f : R[X]) (n : ‚Ñï) : derivative (‚Üën * f) = ‚Üën * derivative f := by"
  },
  {
    "full_name": "Cardinal.mk_fintype",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "theorem Cardinal.mk_fintype (Œ± : Type u) : Fintype.card Œ± = Fintype.card (ULift.{u, 0} (Fin (Fintype.card Œ±))) := by"
  },
  {
    "full_name": "Cardinal.mk_biUnion_le_lift",
    "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
    "teorema": "theorem Cardinal.mk_biUnion_le_lift (A : Œπ ‚Üí Set Œ±) (s : Set Œπ) (Œ± : Type u) (Œπ : Type v) : lift.{v, u} #‚Üë(‚ãÉ x ‚àà s, A x) ‚â§ lift.{u, v} #‚Üës * ‚®Ü x, lift.{v, u} #‚Üë(A ‚Üëx) := by"
  },
  {
    "full_name": "MvPolynomial.IsHomogeneous.totalDegree_le",
    "file_path": "Mathlib/RingTheory/MvPolynomial/Homogeneous.lean",
    "teorema": "lemma MvPolynomial.IsHomogeneous.totalDegree_le (R : Type u_3) (n : ‚Ñï) (œÉ : Type u_1) (œÜ : MvPolynomial œÉ R) : œÜ.totalDegree ‚â§ n := by"
  },
  {
    "full_name": "Gamma1_mem",
    "file_path": "Mathlib/NumberTheory/ModularForms/CongruenceSubgroups.lean",
    "teorema": "theorem Gamma1_mem (A : SL(2, ‚Ñ§)) (N : ‚Ñï) : A ‚àà Gamma1 N ‚Üî ‚Üë(‚ÜëA 0 0) = 1 ‚àß ‚Üë(‚ÜëA 1 1) = 1 ‚àß ‚Üë(‚ÜëA 1 0) = 0 := by"
  },
  {
    "full_name": "String.Iterator.hasNext_cons_addChar",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "lemma String.Iterator.hasNext_cons_addChar (c : Char) (cs : List Char) (i : Pos) : { s := { data := c :: cs }, i := i + c }.hasNext = { s := { data := cs }, i := i }.hasNext := by"
  },
  {
    "full_name": "MeasureTheory.Measure.snd_apply",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "theorem MeasureTheory.Measure.snd_apply (s : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_3) (œÅ : Measure (Œ± √ó Œ≤)) : œÅ.snd s = œÅ (Prod.snd ‚Åª¬π' s) := by"
  },
  {
    "full_name": "MeasureTheory.integral_fn_integral_add",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Integral.lean",
    "teorema": "lemma MeasureTheory.integral_fn_integral_add (E : Type u_6) (F : E ‚Üí E') (f : Œ± √ó Œ≤ ‚Üí E) (g : Œ± √ó Œ≤ ‚Üí E) (Œ± : Type u_1) (Œ≤ : Type u_3) (Œº : Measure Œ±) (ŒΩ : Measure Œ≤) : ‚à´ (x : Œ±), F (‚à´ (y : Œ≤), f (x, y) + g (x, y) ‚àÇŒΩ) ‚àÇŒº = := by"
  },
  {
    "full_name": "Codisjoint.preimage",
    "file_path": "Mathlib/Data/Set/Image.lean",
    "teorema": "theorem Codisjoint.preimage (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) (t : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : Codisjoint (f ‚Åª¬π' s) (f ‚Åª¬π' t) := by"
  },
  {
    "full_name": "ContDiffAt.real_of_complex",
    "file_path": "Mathlib/Analysis/Complex/RealDeriv.lean",
    "teorema": "theorem ContDiffAt.real_of_complex (e : ‚ÑÇ ‚Üí ‚ÑÇ) (n : ‚Ñï‚àû) (z : ‚Ñù) : ContDiffAt ‚Ñù n (fun x => (e ‚Üëx).re) z := by"
  },
  {
    "full_name": "Nat.dist_mul_right",
    "file_path": "Mathlib/Data/Nat/Dist.lean",
    "teorema": "lemma Nat.dist_mul_right (k : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) : (n * k).dist (m * k) = n.dist m * k := by"
  },
  {
    "full_name": "CategoryTheory.exact_comp_hom_inv_comp",
    "file_path": "Mathlib/Algebra/Homology/Exact.lean",
    "teorema": "lemma CategoryTheory.exact_comp_hom_inv_comp (A : V) (B : V) (C : V) (D : V) (V : Type u) (f : A ‚ü∂ B) (g : B ‚ü∂ C) (i : B ‚âÖ D) : Exact (f ‚â´ i.hom) (i.inv ‚â´ g) := by"
  },
  {
    "full_name": "le_separableClosure_iff",
    "file_path": "Mathlib/FieldTheory/SeparableClosure.lean",
    "teorema": "theorem le_separableClosure_iff (E : Type v) (F : Type u) (L : IntermediateField F E) (x : ‚Ü•L) : (minpoly F x).Separable := by"
  },
  {
    "full_name": "BoxIntegral.integrable_iff_cauchy_basis",
    "file_path": "Mathlib/Analysis/BoxIntegral/Basic.lean",
    "teorema": "theorem BoxIntegral.integrable_iff_cauchy_basis (E : Type v) (F : Type w) (I : Box Œπ) (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (l : IntegrationParams) (vol : Œπ ‚Üí·µá·µÉ[‚ä§] E ‚ÜíL[‚Ñù] F) (Œπ : Type u) : Integrable I l f vol ‚Üî ‚àÄ Œµ > 0, ‚àÉ r, := by"
  },
  {
    "full_name": "Units.mk0_prod",
    "file_path": "Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean",
    "teorema": "theorem Units.mk0_prod (G‚ÇÄ : Type u_3) (f : Œπ ‚Üí G‚ÇÄ) (h : ‚àè i ‚àà s, f i ‚â† 0) (s : Finset Œπ) (Œπ : Type u_1) : mk0 (‚àè i ‚àà s, f i) h = ‚àè i ‚àà s.attach, mk0 (f ‚Üëi) ‚ãØ := by"
  },
  {
    "full_name": "CategoryTheory.Equivalence.cancel_unit_right",
    "file_path": "Mathlib/CategoryTheory/Equivalence.lean",
    "teorema": "lemma CategoryTheory.Equivalence.cancel_unit_right (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (X : C) (Y : C) (e : C ‚âå D) (f : X ‚ü∂ Y) : f ‚â´ e.unit.app Y = f' ‚â´ e.unit.app Y ‚Üî f = f' := by"
  },
  {
    "full_name": "Polynomial.natDegree_list_sum_le",
    "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean",
    "teorema": "lemma Polynomial.natDegree_list_sum_le : natDegree 0 ‚â§ 0 := by"
  },
  {
    "full_name": "FractionalIdeal.mul_right_le_iff",
    "file_path": "Mathlib/RingTheory/DedekindDomain/Ideal.lean",
    "teorema": "theorem FractionalIdeal.mul_right_le_iff (J : FractionalIdeal A‚Å∞ K) (K : Type u_3) : ‚àÄ {I I' : FractionalIdeal A‚Å∞ K}, I * J ‚â§ I' * J ‚Üî I ‚â§ I' := by"
  },
  {
    "full_name": "ProbabilityTheory.condCount_add_compl_eq",
    "file_path": "Mathlib/Probability/CondCount.lean",
    "teorema": "lemma ProbabilityTheory.condCount_add_compl_eq (s : Set Œ©) (t : Set Œ©) (u : Set Œ©) (Œ© : Type u_1) : (condCount (s ‚à© u)) t * (condCount s) u + (condCount (s ‚à© u·∂ú)) t * (condCount s) u·∂ú = (condCount s) t := by"
  },
  {
    "full_name": "geom_sum‚ÇÇ_with_one",
    "file_path": "Mathlib/Algebra/GeomSum.lean",
    "teorema": "theorem geom_sum‚ÇÇ_with_one (i : ‚Ñï) (n : ‚Ñï) (x : Œ±) (Œ± : Type u) : x ^ i * 1 ^ (n - 1 - i) = x ^ i := by"
  },
  {
    "full_name": "Set.unbounded_inter_not",
    "file_path": "Mathlib/Order/Bounded.lean",
    "teorema": "lemma Set.unbounded_inter_not (a : Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Set Œ±) (Œ± : Type u_1) : Unbounded r (s ‚à© {b | ¬¨r b a}) ‚Üî Unbounded r s := by"
  },
  {
    "full_name": "fn_min_mul_fn_max",
    "file_path": "Mathlib/Algebra/Order/Monoid/Unbundled/MinMax.lean",
    "teorema": "lemma fn_min_mul_fn_max (a : Œ±) (b : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : f (min a b) * f (max a b) = f a * f b := by"
  },
  {
    "full_name": "CoxeterMatrix.reindex_relationsSet",
    "file_path": "Mathlib/GroupTheory/Coxeter/Basic.lean",
    "teorema": "lemma CoxeterMatrix.reindex_relationsSet (B : Type u_1) (M : CoxeterMatrix B) (e : B ‚âÉ B') : Set.range (uncurry M'.relation) = Set.range (uncurry M'.relation ‚àò Prod.map ‚áëe ‚áëe) := by"
  },
  {
    "full_name": "summable_one_div_pow_of_le",
    "file_path": "Mathlib/Analysis/SpecificLimits/Basic.lean",
    "teorema": "lemma summable_one_div_pow_of_le (f : ‚Ñï ‚Üí ‚Ñï) (m : ‚Ñù) : Summable fun i => 1 / m ^ f i := by"
  },
  {
    "full_name": "AddCircle.liftIco_coe_apply",
    "file_path": "Mathlib/Topology/Instances/AddCircle.lean",
    "teorema": "lemma AddCircle.liftIco_coe_apply (B : Type u_2) (a : ùïú) (f : ùïú ‚Üí B) (p : ùïú) (x : ùïú) (ùïú : Type u_1) : liftIco p a f ‚Üëx = f x := by"
  },
  {
    "full_name": "HomologicalComplex.mapBifunctorMapHomotopy.ŒπMapBifunctor_hom‚ÇÅ",
    "file_path": "Mathlib/Algebra/Homology/BifunctorHomotopy.lean",
    "teorema": "lemma HomologicalComplex.mapBifunctorMapHomotopy.ŒπMapBifunctor_hom‚ÇÅ (C‚ÇÅ : Type u_1) (C‚ÇÇ : Type u_2) (D : Type u_3) (F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ D) (I‚ÇÅ : Type u_4) (I‚ÇÇ : Type u_5) (J : Type u_6) (K‚ÇÅ : HomologicalComplex C‚ÇÅ c‚ÇÅ) (K‚ÇÇ : HomologicalComplex C‚ÇÇ c‚ÇÇ) (L‚ÇÅ : HomologicalComplex C‚ÇÅ c‚ÇÅ) (L‚ÇÇ : HomologicalComplex C‚ÇÇ c‚ÇÇ) (c : ComplexShape J) (c‚ÇÅ : ComplexShape I‚ÇÅ) (c‚ÇÇ : ComplexShape I‚ÇÇ) (f‚ÇÅ : K‚ÇÅ ‚ü∂ L‚ÇÅ) (f‚ÇÇ : K‚ÇÇ ‚ü∂ L‚ÇÇ) (h : c‚ÇÅ.œÄ c‚ÇÇ c (i‚ÇÅ', i‚ÇÇ) = j) (h‚ÇÅ : Homotopy f‚ÇÅ f‚ÇÅ') (i‚ÇÅ : I‚ÇÅ) (i‚ÇÇ : I‚ÇÇ) (j : J) : K‚ÇÅ.ŒπMapBifunctor K‚ÇÇ F c i‚ÇÅ' i‚ÇÇ j h ‚â´ hom‚ÇÅ h‚ÇÅ f‚ÇÇ F c j j' = c‚ÇÅ.Œµ‚ÇÅ c‚ÇÇ c (i‚ÇÅ, i‚ÇÇ) ‚Ä¢ (F.map (h‚ÇÅ.hom i‚ÇÅ' i‚ÇÅ)).app (K‚ÇÇ.X i‚ÇÇ) ‚â´ (F.obj (L‚ÇÅ.X i‚ÇÅ)).map (f‚ÇÇ.f i‚ÇÇ) ‚â´ L‚ÇÅ.ŒπMapBifunctorOrZero L‚ÇÇ F c i‚ÇÅ i‚ÇÇ j' := by"
  },
  {
    "full_name": "MeasureTheory.FiniteMeasure.tendsto_normalize_of_tendsto",
    "file_path": "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean",
    "teorema": "theorem MeasureTheory.FiniteMeasure.tendsto_normalize_of_tendsto (F : Filter Œ≥) (Œ© : Type u_1) (Œ≥ : Type u_2) (Œº : FiniteMeasure Œ©) (Œºs : Œ≥ ‚Üí FiniteMeasure Œ©) : Tendsto (fun i => (Œºs i).normalize) F (ùìù Œº.normalize) := by"
  },
  {
    "full_name": "Finset.Nat.antidiagonal_filter_le_fst_of_le",
    "file_path": "Mathlib/Data/Finset/NatAntidiagonal.lean",
    "teorema": "lemma Finset.Nat.antidiagonal_filter_le_fst_of_le (k : ‚Ñï) (n : ‚Ñï) : filter (fun a => k ‚â§ a.1) (antidiagonal n) = := by"
  },
  {
    "full_name": "IsSubgroup.eq_trivial_iff",
    "file_path": "Mathlib/Deprecated/Subgroup.lean",
    "teorema": "theorem IsSubgroup.eq_trivial_iff (G : Type u_1) (s : Set G) : s = trivial G ‚Üî ‚àÄ x ‚àà s, x = 1 := by"
  },
  {
    "full_name": "CategoryTheory.PreGaloisCategory.card_fiber_eq_of_iso",
    "file_path": "Mathlib/CategoryTheory/Galois/Basic.lean",
    "teorema": "theorem CategoryTheory.PreGaloisCategory.card_fiber_eq_of_iso (C : Type u‚ÇÅ) (F : C ‚•§ FintypeCat) (X : C) (Y : C) : Nat.card ‚Üë(F.obj X) = Nat.card ‚Üë(F.obj Y) := by"
  },
  {
    "full_name": "mul_neg_of_neg_of_pos",
    "file_path": "Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean",
    "teorema": "lemma mul_neg_of_neg_of_pos (a : Œ±) (b : Œ±) (Œ± : Type u_1) : a * b < 0 := by"
  },
  {
    "full_name": "Action.functorCategoryMonoidalEquivalence.ŒºIso_inv_app",
    "file_path": "Mathlib/RepresentationTheory/Action/Monoidal.lean",
    "teorema": "theorem Action.functorCategoryMonoidalEquivalence.ŒºIso_inv_app (A : Action V G) (B : Action V G) (G : MonCat) (V : Type (u + 1)) : ((functorCategoryMonoidalEquivalence V G).ŒºIso A B).inv.app PUnit.unit = ùüô (((functorCategoryMonoidalEquivalence V G).obj (A ‚äó B)).obj PUnit.unit) := by"
  },
  {
    "full_name": "Ordinal.principal_opow_omega",
    "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
    "teorema": "lemma Ordinal.principal_opow_omega (m : ‚Ñï) (n : ‚Ñï) : (fun x x_1 => x ^ x_1) ‚Üëm ‚Üën < œâ := by"
  },
  {
    "full_name": "continuousAt_extChartAt'",
    "file_path": "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean",
    "teorema": "lemma continuousAt_extChartAt' (H : Type u_4) (M : Type u_3) (x : M) : x' ‚àà (chartAt H x).source := by"
  },
  {
    "full_name": "Matroid.Basis.map",
    "file_path": "Mathlib/Data/Matroid/Map.lean",
    "teorema": "lemma Matroid.Basis.map (E : Set Œ±) (I : Set Œ±) (M : Matroid Œ±) (X : Set Œ±) (f : Œ± ‚Üí Œ≤) (hf : InjOn f M.E) (Œ± : Type u_1) (Œ≤ : Type u_2) : (M.map f hf).Basis (f '' I) (f '' X) := by"
  },
  {
    "full_name": "IsArtinian.surjective_of_injective_endomorphism",
    "file_path": "Mathlib/RingTheory/Artinian.lean",
    "teorema": "theorem IsArtinian.surjective_of_injective_endomorphism (M : Type u_2) (R : Type u_1) (f : M ‚Üí‚Çó[R] M) : Surjective ‚áëf := by"
  },
  {
    "full_name": "UniformEquicontinuous.closure'",
    "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean",
    "teorema": "theorem UniformEquicontinuous.closure' (Y : Type u_5) (u : Y ‚Üí Œ≤ ‚Üí Œ±) (Œ± : Type u_7) (Œ≤ : Type u_9) : UniformEquicontinuous (u ‚àò Subtype.val) := by"
  },
  {
    "full_name": "GeneralizedContinuedFraction.part_denom_eq_s_b",
    "file_path": "Mathlib/Algebra/ContinuedFractions/Translations.lean",
    "teorema": "theorem GeneralizedContinuedFraction.part_denom_eq_s_b (g : GeneralizedContinuedFraction Œ±) (gp : Pair Œ±) (n : ‚Ñï) (Œ± : Type u_1) : g.partialDenominators.get? n = some gp.b := by"
  },
  {
    "full_name": "Lagrange.derivative_nodal",
    "file_path": "Mathlib/LinearAlgebra/Lagrange.lean",
    "teorema": "lemma Lagrange.derivative_nodal (R : Type u_1) (s : Finset Œπ) (v : Œπ ‚Üí R) (Œπ : Type u_2) : derivative (nodal s v) = ‚àë i ‚àà s, nodal (s.erase i) v := by"
  },
  {
    "full_name": "hasFTaylorSeriesUpToOn_univ_iff",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean",
    "teorema": "theorem hasFTaylorSeriesUpToOn_univ_iff (E : Type uE) (F : Type uF) (f : E ‚Üí F) (n : ‚Ñï‚àû) (p : E ‚Üí FormalMultilinearSeries ùïú E F) (u : Set E) (ùïú : Type u) : HasFTaylorSeriesUpToOn n f p univ ‚Üî HasFTaylorSeriesUpTo n f p := by"
  },
  {
    "full_name": "List.getElem_insertNth_of_lt",
    "file_path": "Mathlib/Data/List/InsertNth.lean",
    "teorema": "lemma List.getElem_insertNth_of_lt (k : ‚Ñï) (l : List Œ±) (n : ‚Ñï) (x : Œ±) (Œ± : Type u) : (insertNth n x l)[k] = l[k] := by"
  },
  {
    "full_name": "Quiver.Path.reverse_comp",
    "file_path": "Mathlib/Combinatorics/Quiver/Symmetric.lean",
    "teorema": "theorem Quiver.Path.reverse_comp (V : Type u_2) (a : V) (b : V) (c : V) (p : Path a b) (q : Path b c) : (p.comp q).reverse = q.reverse.comp p.reverse := by"
  },
  {
    "full_name": "List.nodup_iff_injective_getElem",
    "file_path": "Mathlib/Data/List/Nodup.lean",
    "teorema": "lemma List.nodup_iff_injective_getElem (i : Fin l.length) (j : Fin l.length) (l : List Œ±) (Œ± : Type u) : i = j := by"
  },
  {
    "full_name": "FirstOrder.Language.BoundedFormula.realize_toPrenex",
    "file_path": "Mathlib/ModelTheory/Semantics.lean",
    "teorema": "lemma FirstOrder.Language.BoundedFormula.realize_toPrenex (L : Language) (M : Type w) (l : ‚Ñï) (n : ‚Ñï) (v : Œ± ‚Üí M) (xs : Fin l ‚Üí M) (Œ± : Type u') (œÜ : L.BoundedFormula Œ± n) : ‚àÄ {xs : Fin n ‚Üí M}, œÜ.toPrenex.Realize v xs ‚Üî œÜ.Realize v xs := by"
  },
  {
    "full_name": "Hindman.FP.finset_prod",
    "file_path": "Mathlib/Combinatorics/Hindman.lean",
    "teorema": "lemma Hindman.FP.finset_prod (M : Type u_1) (a : Stream' M) (s : Finset ‚Ñï) : ‚àè i ‚àà s, a.get i ‚àà FP a := by"
  },
  {
    "full_name": "CategoryTheory.sheafificationAdjunction_counit_app_val",
    "file_path": "Mathlib/CategoryTheory/Sites/Sheafification.lean",
    "teorema": "lemma CategoryTheory.sheafificationAdjunction_counit_app_val (C : Type u‚ÇÅ) (D : Type u_1) (J : GrothendieckTopology C) (P : Sheaf J D) : ((sheafificationAdjunction J D).counit.app P).val = sheafifyLift J (ùüô P.val) ‚ãØ := by"
  },
  {
    "full_name": "Complex.arg_coe_angle_toReal_eq_arg",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean",
    "teorema": "lemma Complex.arg_coe_angle_toReal_eq_arg (z : ‚ÑÇ) : (‚Üëz.arg).toReal = z.arg := by"
  },
  {
    "full_name": "exists_integer_of_is_root_of_monic",
    "file_path": "Mathlib/RingTheory/Polynomial/RationalRoot.lean",
    "teorema": "theorem exists_integer_of_is_root_of_monic (A : Type u_1) (K : Type u_2) (p : A[X]) (r : K) : ‚àÉ r', r = (algebraMap A K) r' ‚àß r' ‚à£ p.coeff 0 := by"
  },
  {
    "full_name": "SetTheory.PGame.le_neg_iff",
    "file_path": "Mathlib/SetTheory/Game/PGame.lean",
    "teorema": "lemma SetTheory.PGame.le_neg_iff (x : PGame) (y : PGame) : y ‚â§ -x ‚Üî x ‚â§ -y := by"
  },
  {
    "full_name": "Multiset.gcd_map_mul",
    "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
    "teorema": "theorem Multiset.gcd_map_mul (a : Œ±) (s : Multiset Œ±) (Œ± : Type u_1) : (map (fun x => a * x) s).gcd = normalize a * s.gcd := by"
  },
  {
    "full_name": "MeasureTheory.measure_eq_zero_iff_eq_empty_of_smulInvariant",
    "file_path": "Mathlib/MeasureTheory/Group/Action.lean",
    "teorema": "lemma MeasureTheory.measure_eq_zero_iff_eq_empty_of_smulInvariant (U : Set Œ±) (Œ± : Type w) (Œº : Measure Œ±) : Œº U = 0 ‚Üî U = ‚àÖ := by"
  },
  {
    "full_name": "lcm_mul_left",
    "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean",
    "teorema": "theorem lcm_mul_left (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : a = 0 ‚Üí lcm (a * b) (a * c) = normalize a * lcm b c := by"
  },
  {
    "full_name": "ContinuousOn.exists_isMinOn'",
    "file_path": "Mathlib/Topology/Algebra/Order/Compact.lean",
    "teorema": "lemma ContinuousOn.exists_isMinOn' (f : Œ≤ ‚Üí Œ±) (s : Set Œ≤) (Œ± : Type u_2) (Œ≤ : Type u_3) : ‚àÉ x ‚àà s, IsMinOn f s x := by"
  },
  {
    "full_name": "Real.fourierIntegral_iteratedFDeriv",
    "file_path": "Mathlib/Analysis/Fourier/FourierTransformDeriv.lean",
    "teorema": "lemma Real.fourierIntegral_iteratedFDeriv (E : Type u_1) (V : Type u_2) (f : V ‚Üí E) (n : ‚Ñï) : ùìï (iteratedFDeriv ‚Ñù n f) = fun w => fourierPowSMulRight (-innerSL ‚Ñù) (ùìï f) w n := by"
  },
  {
    "full_name": "CauSeq.mul_limZero_left",
    "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean",
    "teorema": "lemma CauSeq.mul_limZero_left (abv : Œ≤ ‚Üí Œ±) (f : CauSeq Œ≤ abv) (g : CauSeq Œ≤ abv) (j : ‚Ñï) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œµ : Œ±) : abv (‚Üë(f * g) j) < Œµ := by"
  },
  {
    "full_name": "Finsupp.mul_prod_erase'",
    "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean",
    "teorema": "lemma Finsupp.mul_prod_erase' (M : Type u_8) (N : Type u_10) (f : Œ± ‚Üí‚ÇÄ M) (g : Œ± ‚Üí M ‚Üí N) (y : Œ±) (Œ± : Type u_1) : g y (f y) * (erase y f).prod g = f.prod g := by"
  },
  {
    "full_name": "tendsto_rpow_atBot_of_base_gt_one",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean",
    "teorema": "theorem tendsto_rpow_atBot_of_base_gt_one (b : ‚Ñù) : Tendsto (fun x => b ^ x) atBot (ùìù 0) := by"
  },
  {
    "full_name": "nonempty_sections_of_finite_cofiltered_system",
    "file_path": "Mathlib/CategoryTheory/CofilteredSystem.lean",
    "teorema": "lemma nonempty_sections_of_finite_cofiltered_system (F : J ‚•§ Type v) (J : Type u) : F.sections.Nonempty := by"
  },
  {
    "full_name": "MulAction.pow_period_add_smul",
    "file_path": "Mathlib/Dynamics/PeriodicPts.lean",
    "teorema": "theorem MulAction.pow_period_add_smul (M : Type u) (a : Œ±) (m : M) (n : ‚Ñï) (Œ± : Type v) : m ^ (period m a + n) ‚Ä¢ a = m ^ n ‚Ä¢ a := by"
  },
  {
    "full_name": "ContinuousLinearEquiv.comp_right_fderiv",
    "file_path": "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean",
    "teorema": "theorem ContinuousLinearEquiv.comp_right_fderiv (E : Type u_2) (F : Type u_3) (G : Type u_4) (L : Filter E) (f : F ‚Üí G) (iso : E ‚âÉL[ùïú] F) (x : E) (ùïú : Type u_1) : fderiv ùïú (f ‚àò ‚áëiso) x = (fderiv ùïú f (iso x)).comp ‚Üëiso := by"
  },
  {
    "full_name": "UniqueFactorizationMonoid.multiplicative_of_coprime",
    "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean",
    "teorema": "lemma UniqueFactorizationMonoid.multiplicative_of_coprime (a : Œ±) (b : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_3) : f (a * b) = f a * f b := by"
  },
  {
    "full_name": "CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int",
    "file_path": "Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean",
    "teorema": "theorem CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int (f : CircleDeg1Lift) (m : ‚Ñ§) (n : ‚Ñï) : œÑ f = ‚Üëm / ‚Üën := by"
  },
  {
    "full_name": "Subsemiring.mem_closure_iff_exists_list",
    "file_path": "Mathlib/Algebra/Ring/Subsemiring/Basic.lean",
    "teorema": "lemma Subsemiring.mem_closure_iff_exists_list (R : Type u_1) (s : Set R) (x : R) : x ‚àà closure s ‚Üî ‚àÉ L, (‚àÄ t ‚àà L, ‚àÄ y ‚àà t, y ‚àà s) ‚àß (List.map List.prod L).sum = x := by"
  },
  {
    "full_name": "NumberField.InfinitePlace.IsReal.comap",
    "file_path": "Mathlib/NumberTheory/NumberField/Embeddings.lean",
    "teorema": "theorem NumberField.InfinitePlace.IsReal.comap (K : Type u_2) (f : k ‚Üí+* K) (k : Type u_1) (w : InfinitePlace K) : (w.comap f).IsReal := by"
  },
  {
    "full_name": "MeasureTheory.IsSetSemiring.diffFinset_subset",
    "file_path": "Mathlib/MeasureTheory/SetSemiring.lean",
    "teorema": "lemma MeasureTheory.IsSetSemiring.diffFinset_subset (C : Set (Set Œ±)) (hC : IsSetSemiring C) (hs : s ‚àà C) (ht : t ‚àà C) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) : ‚Üë(hC.diffFinset hs ht) ‚äÜ C := by"
  },
  {
    "full_name": "Nat.smoothNumbersUpTo_card_le",
    "file_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
    "teorema": "lemma Nat.smoothNumbersUpTo_card_le (N : ‚Ñï) (k : ‚Ñï) : (N.smoothNumbersUpTo k).card ‚â§ 2 ^ k.primesBelow.card * N.sqrt := by"
  },
  {
    "full_name": "IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime",
    "file_path": "Mathlib/NumberTheory/Cyclotomic/Rat.lean",
    "teorema": "theorem IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime (p : ‚Ñï+) : IsIntegralClosure (CyclotomicRing p ‚Ñ§ ‚Ñö) ‚Ñ§ (CyclotomicField p ‚Ñö) := by"
  },
  {
    "full_name": "Multiset.map_add_right_Icc",
    "file_path": "Mathlib/Algebra/Order/Interval/Multiset.lean",
    "teorema": "theorem Multiset.map_add_right_Icc (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_1) : map (fun x => x + c) (Icc a b) = Icc (a + c) (b + c) := by"
  },
  {
    "full_name": "mem_closure_iff_ultrafilter",
    "file_path": "Mathlib/Topology/Basic.lean",
    "teorema": "lemma mem_closure_iff_ultrafilter (X : Type u) (s : Set X) (x : X) : x ‚àà closure s ‚Üî ‚àÉ u, s ‚àà u ‚àß ‚Üëu ‚â§ ùìù x := by"
  },
  {
    "full_name": "QuadraticForm.associated_isOrtho",
    "file_path": "Mathlib/LinearAlgebra/QuadraticForm/Basic.lean",
    "teorema": "lemma QuadraticForm.associated_isOrtho (M : Type u_4) (Q : QuadraticForm R M) (R : Type u_3) (x : M) (y : M) : LinearMap.IsOrtho (associated Q) x y ‚Üî Q.IsOrtho x y := by"
  },
  {
    "full_name": "CategoryTheory.Sieve.overEquiv_symm_top",
    "file_path": "Mathlib/CategoryTheory/Sites/Over.lean",
    "teorema": "theorem CategoryTheory.Sieve.overEquiv_symm_top (C : Type u) (X : C) (Y : Over X) : (overEquiv Y) ((overEquiv Y).symm ‚ä§) = (overEquiv Y) ‚ä§ := by"
  },
  {
    "full_name": "MeasureTheory.Measure.quasiMeasurePreserving_smul",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean",
    "teorema": "theorem MeasureTheory.Measure.quasiMeasurePreserving_smul (E : Type u_1) (r : ‚Ñù) (Œº : Measure E) : QuasiMeasurePreserving (fun x => r ‚Ä¢ x) Œº Œº := by"
  },
  {
    "full_name": "OrderEmbedding.image_Ioo",
    "file_path": "Mathlib/Order/Interval/Set/OrdConnected.lean",
    "teorema": "lemma OrderEmbedding.image_Ioo (e : Œ± ‚Ü™o Œ≤) (x : Œ±) (y : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : ‚áëe '' Ioo x y = Ioo (e x) (e y) := by"
  },
  {
    "full_name": "Finset.image_insert_memberSubfamily",
    "file_path": "Mathlib/Combinatorics/SetFamily/Compression/Down.lean",
    "teorema": "lemma Finset.image_insert_memberSubfamily (a : Œ±) (Œ± : Type u_1) (ùíú : Finset (Finset Œ±)) : image (insert a) (memberSubfamily a ùíú) = filter (fun x => a ‚àà x) ùíú := by"
  },
  {
    "full_name": "CategoryTheory.Limits.coprod.associator_naturality",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
    "teorema": "theorem CategoryTheory.Limits.coprod.associator_naturality (C : Type u) (X‚ÇÅ : C) (X‚ÇÇ : C) (X‚ÇÉ : C) (Y‚ÇÅ : C) (Y‚ÇÇ : C) (Y‚ÇÉ : C) (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) : map (map f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom = (associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ map f‚ÇÅ (map f‚ÇÇ f‚ÇÉ) := by"
  },
  {
    "full_name": "PrimeSpectrum.union_zeroLocus",
    "file_path": "Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean",
    "teorema": "theorem PrimeSpectrum.union_zeroLocus (R : Type u) (s : Set R) : zeroLocus s ‚à™ zeroLocus s' = zeroLocus ‚Üë(Ideal.span s ‚äì Ideal.span s') := by"
  },
  {
    "full_name": "WittVector.ghostFun_natCast",
    "file_path": "Mathlib/RingTheory/WittVector/Basic.lean",
    "teorema": "theorem WittVector.ghostFun_natCast (i : ‚Ñï) : WittVector.ghostFun i.unaryCast = ‚Üëi := by"
  },
  {
    "full_name": "Function.HasTemperateGrowth.const",
    "file_path": "Mathlib/Analysis/Distribution/SchwartzSpace.lean",
    "teorema": "theorem Function.HasTemperateGrowth.const (F : Type u_5) (c : F) : Function.HasTemperateGrowth (fderiv ‚Ñù fun x => c) := by"
  },
  {
    "full_name": "MeasureTheory.snorm_le_snorm_fderiv_of_eq_inner",
    "file_path": "Mathlib/Analysis/FunctionalSpaces/SobolevInequality.lean",
    "teorema": "lemma MeasureTheory.snorm_le_snorm_fderiv_of_eq_inner (E : Type u_4) (F : Type u_3) (p : ‚Ñù‚â•0) (u : E ‚Üí F') (Œº : Measure E) : snorm u (‚Üëp') Œº ‚â§ ‚Üë(snormLESNormFDerivOfEqInnerConst Œº ‚Üëp) * snorm (fderiv ‚Ñù u) (‚Üëp) Œº := by"
  },
  {
    "full_name": "Finsupp.frange_single",
    "file_path": "Mathlib/Data/Finsupp/Basic.lean",
    "teorema": "lemma Finsupp.frange_single (M : Type u_5) (ht1 : Œ±) (x : Œ±) (y : M) (Œ± : Type u_1) : (single x y) ht1 ‚àà {y} := by"
  },
  {
    "full_name": "Ordinal.le_enum_succ",
    "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean",
    "teorema": "theorem Ordinal.le_enum_succ (o : Ordinal.{?u.104673}) : o < type fun x x_1 => x < x_1 := by"
  },
  {
    "full_name": "MonoidHom.independent_range_of_coprime_order",
    "file_path": "Mathlib/GroupTheory/NoncommPiCoprod.lean",
    "teorema": "lemma MonoidHom.independent_range_of_coprime_order (G : Type u_1) (H : Œπ ‚Üí Type u_3) (Œπ : Type u_2) (œï : (i : Œπ) ‚Üí H i ‚Üí* G) : CompleteLattice.Independent fun i => (œï i).range := by"
  },
  {
    "full_name": "bernoulli'_def",
    "file_path": "Mathlib/NumberTheory/Bernoulli.lean",
    "teorema": "lemma bernoulli'_def (n : ‚Ñï) : bernoulli' n = 1 - ‚àë k ‚àà range n, ‚Üë(n.choose k) / (‚Üën - ‚Üëk + 1) * bernoulli' k := by"
  },
  {
    "full_name": "SemidirectProduct.rightHom_inl",
    "file_path": "Mathlib/GroupTheory/SemidirectProduct.lean",
    "teorema": "lemma SemidirectProduct.rightHom_inl (N : Type u_1) (n : N) : rightHom (inl n) = 1 := by"
  },
  {
    "full_name": "Function.Periodic.div",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "teorema": "lemma Function.Periodic.div (c : Œ±) (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : Periodic (f / g) c := by"
  },
  {
    "full_name": "rieszContentAux_image_nonempty",
    "file_path": "Mathlib/MeasureTheory/Integral/RieszMarkovKakutani.lean",
    "teorema": "theorem rieszContentAux_image_nonempty (K : Compacts X) (X : Type u_1) (Œõ : (X ‚Üí·µá ‚Ñù‚â•0) ‚Üí‚Çó[‚Ñù‚â•0] ‚Ñù‚â•0) : (‚áëŒõ '' {f | ‚àÄ x ‚àà K, 1 ‚â§ f x}).Nonempty := by"
  },
  {
    "full_name": "MeasureTheory.Measure.smul_measure_isMulInvariant_le_of_isCompact_closure",
    "file_path": "Mathlib/MeasureTheory/Measure/Haar/Unique.lean",
    "teorema": "lemma MeasureTheory.Measure.smul_measure_isMulInvariant_le_of_isCompact_closure (G : Type u_1) (s : Set G) (Œº : Measure G) : Œº'.haarScalarFactor Œº ‚Ä¢ Œº s ‚â§ Œº' s := by"
  },
  {
    "full_name": "isComplete_iff_ultrafilter",
    "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean",
    "teorema": "theorem isComplete_iff_ultrafilter (s : Set Œ±) (Œ± : Type u) : IsComplete s ‚Üî ‚àÄ (l : Ultrafilter Œ±), Cauchy ‚Üël ‚Üí ‚Üël ‚â§ ùìü s ‚Üí ‚àÉ x ‚àà s, ‚Üël ‚â§ ùìù x := by"
  },
  {
    "full_name": "Subgroup.prod_top",
    "file_path": "Mathlib/Algebra/Group/Subgroup/Basic.lean",
    "teorema": "theorem Subgroup.prod_top (G : Type u_1) (K : Subgroup G) (N : Type u_5) (x : G √ó N) : x ‚àà K.prod ‚ä§ ‚Üî x ‚àà comap (MonoidHom.fst G N) K := by"
  },
  {
    "full_name": "CochainComplex.HomComplex.Cochain.add_comp",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean",
    "teorema": "theorem CochainComplex.HomComplex.Cochain.add_comp (C : Type u) (F : CochainComplex C ‚Ñ§) (G : CochainComplex C ‚Ñ§) (K : CochainComplex C ‚Ñ§) (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) (n‚ÇÅ : ‚Ñ§) (n‚ÇÅ‚ÇÇ : ‚Ñ§) (n‚ÇÇ : ‚Ñ§) (z‚ÇÅ : Cochain F G n‚ÇÅ) (z‚ÇÇ : Cochain G K n‚ÇÇ) : (z‚ÇÅ + z‚ÇÅ').comp z‚ÇÇ h = z‚ÇÅ.comp z‚ÇÇ h + z‚ÇÅ'.comp z‚ÇÇ h := by"
  },
  {
    "full_name": "Subalgebra.fg_bot_toSubmodule",
    "file_path": "Mathlib/RingTheory/Finiteness.lean",
    "teorema": "theorem Subalgebra.fg_bot_toSubmodule (R : Type u_3) : span R ‚Üë{1} = Subalgebra.toSubmodule ‚ä• := by"
  },
  {
    "full_name": "Int.ceil_sub_nat",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "theorem Int.ceil_sub_nat (a : Œ±) (n : ‚Ñï) (Œ± : Type u_2) : ‚åàa - ‚Üën‚åâ = ‚åàa‚åâ - ‚Üën := by"
  },
  {
    "full_name": "DirichletCharacter.primitiveCharacter_one",
    "file_path": "Mathlib/NumberTheory/DirichletCharacter/Basic.lean",
    "teorema": "lemma DirichletCharacter.primitiveCharacter_one : primitiveCharacter 1 = 1 := by"
  },
  {
    "full_name": "PowerSeries.coeff_mul",
    "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
    "teorema": "theorem PowerSeries.coeff_mul (R : Type u_1) (n : ‚Ñï) (œÜ : R‚ü¶X‚üß) (œà : R‚ü¶X‚üß) : (coeff R n) (œÜ * œà) = ‚àë p ‚àà antidiagonal n, (coeff R p.1) œÜ * (coeff R p.2) œà := by"
  },
  {
    "full_name": "SubMulAction.image_inclusion",
    "file_path": "Mathlib/GroupTheory/GroupAction/SubMulAction.lean",
    "teorema": "lemma SubMulAction.image_inclusion (M : Type u_1) (s : SubMulAction M Œ±) (Œ± : Type u_2) : Set.range ‚áës.inclusion = s.carrier := by"
  },
  {
    "full_name": "CategoryTheory.exact_kernel_Œπ",
    "file_path": "Mathlib/Algebra/Homology/Exact.lean",
    "teorema": "theorem CategoryTheory.exact_kernel_Œπ (A : V) (B : V) (V : Type u) (f : A ‚ü∂ B) : Exact (kernel.Œπ f) f := by"
  },
  {
    "full_name": "Finset.filter_congr_decidable",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma Finset.filter_congr_decidable (p : Œ± ‚Üí Prop) (s : Finset Œ±) (Œ± : Type u_1) : filter p s = filter p s := by"
  },
  {
    "full_name": "Nat.floor_zero",
    "file_path": "Mathlib/Algebra/Order/Floor.lean",
    "teorema": "lemma Nat.floor_zero : ‚åä0‚åã‚Çä = 0 := by"
  },
  {
    "full_name": "exists_sum_eq_one_iff_pairwise_coprime'",
    "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
    "teorema": "lemma exists_sum_eq_one_iff_pairwise_coprime' (I : Type v) (R : Type u) (s : I ‚Üí R) : (‚àÉ Œº, ‚àë i : I, Œº i * ‚àè j ‚àà {i}·∂ú, s j = 1) ‚Üî Pairwise (IsCoprime on s) := by"
  },
  {
    "full_name": "OpenSubgroup.isClosed",
    "file_path": "Mathlib/Topology/Algebra/OpenSubgroup.lean",
    "teorema": "lemma OpenSubgroup.isClosed (G : Type u_1) (U : OpenSubgroup G) : IsClosed ‚ÜëU := by"
  },
  {
    "full_name": "inv_eq_one_divp",
    "file_path": "Mathlib/Algebra/Group/Units.lean",
    "teorema": "lemma inv_eq_one_divp (u : Œ±À£) : ‚Üëu‚Åª¬π = 1 /‚Çö u := by"
  },
  {
    "full_name": "AddSubgroup.int_mul_mem",
    "file_path": "Mathlib/Algebra/Ring/Subring/Basic.lean",
    "teorema": "lemma AddSubgroup.int_mul_mem (G : AddSubgroup R) (R : Type u) (g : R) (k : ‚Ñ§) : ‚Üëk * g ‚àà G := by"
  },
  {
    "full_name": "ModularForm.smul_slash",
    "file_path": "Mathlib/NumberTheory/ModularForms/SlashActions.lean",
    "teorema": "lemma ModularForm.smul_slash (A : ‚Ü•GL(2, ‚Ñù)‚Å∫) (c : Œ±) (f : ‚Ñç ‚Üí ‚ÑÇ) (k : ‚Ñ§) (Œ± : Type u_1) : (c ‚Ä¢ f) ‚à£[k]A = c ‚Ä¢ f ‚à£[k]A := by"
  },
  {
    "full_name": "Matroid.restrict_eq_self_iff",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "teorema": "theorem Matroid.restrict_eq_self_iff (M : Matroid Œ±) (R : Set Œ±) (Œ± : Type u_1) : R = M.E := by"
  },
  {
    "full_name": "Polynomial.iterate_derivative_map",
    "file_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
    "teorema": "theorem Polynomial.iterate_derivative_map (R : Type u) (S : Type v) (f : R ‚Üí+* S) (k : ‚Ñï) (p : R[X]) : (‚áëderivative)^[k] (map f p) = map f ((‚áëderivative)^[k] p) := by"
  },
  {
    "full_name": "Mathlib.Tactic.Abel.subst_into_negg",
    "file_path": "Mathlib/Tactic/Abel.lean",
    "teorema": "lemma Mathlib.Tactic.Abel.subst_into_negg (a : Œ±) (t : Œ±) (Œ± : Type u_1) : -a = t := by"
  },
  {
    "full_name": "SimpleGraph.isAcyclic_iff_forall_edge_isBridge",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
    "teorema": "lemma SimpleGraph.isAcyclic_iff_forall_edge_isBridge (G : SimpleGraph V) (V : Type u) : G.IsAcyclic ‚Üî ‚àÄ ‚¶Ée : Sym2 V‚¶Ñ, e ‚àà G.edgeSet ‚Üí G.IsBridge e := by"
  },
  {
    "full_name": "Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Alternating.lean",
    "teorema": "theorem Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five (g : Perm (Fin 5)) : (g * g).IsThreeCycle := by"
  },
  {
    "full_name": "map_natCast_smul",
    "file_path": "Mathlib/Algebra/Module/Defs.lean",
    "teorema": "lemma map_natCast_smul (F : Type u_9) (M : Type u_5) (a : M) (f : F) (x : ‚Ñï) : f (‚Üëx ‚Ä¢ a) = ‚Üëx ‚Ä¢ f a := by"
  },
  {
    "full_name": "Equiv.Perm.closure_cycle_adjacent_swap",
    "file_path": "Mathlib/GroupTheory/Perm/Closure.lean",
    "teorema": "theorem Equiv.Perm.closure_cycle_adjacent_swap (x : Œ±) (Œ± : Type u_2) (œÉ : Perm Œ±) : closure {œÉ, swap x (œÉ x)} = ‚ä§ := by"
  },
  {
    "full_name": "MeasureTheory.condexpL1_of_aestronglyMeasurable'",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean",
    "teorema": "theorem MeasureTheory.condexpL1_of_aestronglyMeasurable' (F : Type u_3) (f : Œ± ‚Üí F') (hm : m ‚â§ m0) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚Üë‚Üë(condexpL1 hm Œº f) =·∂†[ae Œº] f := by"
  },
  {
    "full_name": "Nat.Prime.five_le_of_ne_two_of_ne_three",
    "file_path": "Mathlib/Data/Nat/Prime.lean",
    "teorema": "lemma Nat.Prime.five_le_of_ne_two_of_ne_three (p : ‚Ñï) : 5 ‚â§ p := by"
  },
  {
    "full_name": "RingHom.finiteType_holdsForLocalizationAway",
    "file_path": "Mathlib/RingTheory/RingHom/FiniteType.lean",
    "teorema": "theorem RingHom.finiteType_holdsForLocalizationAway : HoldsForLocalizationAway @FiniteType := by"
  },
  {
    "full_name": "List.count_le_count_map",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Count.lean",
    "teorema": "theorem List.count_le_count_map (f : Œ± ‚Üí Œ≤) (l : List Œ±) (x : Œ±) (Œ± : Type u_2) (Œ≤ : Type u_1) : count x l ‚â§ count (f x) (map f l) := by"
  },
  {
    "full_name": "Complex.nnnorm_nat",
    "file_path": "Mathlib/Analysis/Complex/Basic.lean",
    "teorema": "lemma Complex.nnnorm_nat (n : ‚Ñï) : ‚Üë‚Äñ‚Üën‚Äñ‚Çä = ‚Üë‚Üën := by"
  },
  {
    "full_name": "HasFPowerSeriesOnBall.uniform_geometric_approx",
    "file_path": "Mathlib/Analysis/Analytic/Basic.lean",
    "teorema": "lemma HasFPowerSeriesOnBall.uniform_geometric_approx (E : Type u_2) (F : Type u_3) (f : E ‚Üí F) (p : FormalMultilinearSeries ùïú E F) (r : ‚Ñù‚â•0‚àû) (x : E) (ùïú : Type u_1) : ‚àÉ a ‚àà Ioo 0 1, ‚àÉ C > 0, ‚àÄ y ‚àà Metric.ball 0 ‚Üër', ‚àÄ (n : ‚Ñï), ‚Äñf (x + y) - p.partialSum n y‚Äñ ‚â§ C * a ^ n := by"
  },
  {
    "full_name": "RatFunc.div_smul",
    "file_path": "Mathlib/FieldTheory/RatFunc/Basic.lean",
    "teorema": "theorem RatFunc.div_smul (K : Type u) (R : Type u_1) (c : R) (p : K[X]) (q : K[X]) : (algebraMap K[X] (RatFunc K)) (c ‚Ä¢ p) / (algebraMap K[X] (RatFunc K)) q = c ‚Ä¢ ((algebraMap K[X] (RatFunc K)) p / (algebraMap K[X] (RatFunc K)) q) := by"
  },
  {
    "full_name": "IsCauSeq.geo_series_const",
    "file_path": "Mathlib/Algebra/Order/CauSeq/BigOperators.lean",
    "teorema": "lemma IsCauSeq.geo_series_const (a : Œ±) (x : Œ±) (Œ± : Type u_1) : IsCauSeq abs fun m => ‚àë n ‚àà range m, a * x ^ n := by"
  },
  {
    "full_name": "MvPolynomial.isWeightedHomogeneous_monomial",
    "file_path": "Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean",
    "teorema": "lemma MvPolynomial.isWeightedHomogeneous_monomial (M : Type u_2) (R : Type u_1) (d : œÉ ‚Üí‚ÇÄ ‚Ñï) (m : M) (r : R) (w : œÉ ‚Üí M) (œÉ : Type u_3) : IsWeightedHomogeneous w ((monomial d) r) m := by"
  },
  {
    "full_name": "HurwitzZeta.hurwitzZetaEven_one_sub_two_mul_nat",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaValues.lean",
    "teorema": "theorem HurwitzZeta.hurwitzZetaEven_one_sub_two_mul_nat (k : ‚Ñï) (x : ‚Ñù) : hurwitzZetaEven (‚Üëx) (1 - 2 * ‚Üëk) = -1 / (2 * ‚Üëk) * Polynomial.eval (‚Üëx) (Polynomial.map (algebraMap ‚Ñö ‚ÑÇ) (Polynomial.bernoulli (2 * k))) := by"
  },
  {
    "full_name": "Real.cos_pos_of_le_one",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "lemma Real.cos_pos_of_le_one (x : ‚Ñù) : |x| ^ 4 * (5 / 96) + x ^ 2 / 2 ‚â§ 1 * (5 / 96) + 1 / 2 := by"
  },
  {
    "full_name": "Projectivization.independent_iff",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Independence.lean",
    "teorema": "lemma Projectivization.independent_iff (K : Type u_2) (V : Type u_3) (f : Œπ ‚Üí ‚Ñô K V) (Œπ : Type u_1) : Independent f ‚Üî LinearIndependent K (Projectivization.rep ‚àò f) := by"
  },
  {
    "full_name": "affineCombination_eq_centerMass",
    "file_path": "Mathlib/Analysis/Convex/Combination.lean",
    "teorema": "theorem affineCombination_eq_centerMass (E : Type u_3) (R : Type u_1) (p : Œπ ‚Üí E) (t : Finset Œπ) (w : Œπ ‚Üí R) (Œπ : Type u_8) : (affineCombination R t p) w = t.centerMass w p := by"
  },
  {
    "full_name": "equivShrink_symm_sub",
    "file_path": "Mathlib/Logic/Small/Group.lean",
    "teorema": "theorem equivShrink_symm_sub (x : Shrink.{u_2, u_1} Œ±) (y : Shrink.{u_2, u_1} Œ±) (Œ± : Type u_1) : (equivShrink Œ±).symm (x - y) = (equivShrink Œ±).symm x - (equivShrink Œ±).symm y := by"
  },
  {
    "full_name": "Set.inter_compl_nonempty_iff",
    "file_path": "Mathlib/Data/Set/Basic.lean",
    "teorema": "lemma Set.inter_compl_nonempty_iff (s : Set Œ±) (t : Set Œ±) (u : Set Œ±) (x : Œ±) (Œ± : Type u) : x ‚àà s ‚àß x ‚àâ t ‚Üî x ‚àà s ‚à© t·∂ú := by"
  },
  {
    "full_name": "Ideal.finsuppTotal_apply",
    "file_path": "Mathlib/RingTheory/Ideal/Operations.lean",
    "teorema": "theorem Ideal.finsuppTotal_apply (I : Ideal R) (M : Type u_2) (R : Type u_3) (f : Œπ ‚Üí‚ÇÄ ‚Ü•I) (v : Œπ ‚Üí M) (Œπ : Type u_1) : (finsuppTotal Œπ M I v) f = f.sum fun i x => ‚Üëx ‚Ä¢ v i := by"
  },
  {
    "full_name": "MeasureTheory.martingale_of_condexp_sub_eq_zero_nat",
    "file_path": "Mathlib/Probability/Martingale/Basic.lean",
    "teorema": "theorem MeasureTheory.martingale_of_condexp_sub_eq_zero_nat (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (m0 : MeasurableSpace Œ©) (Œ© : Type u_1) (Œº : Measure Œ©) (ùí¢ : Filtration ‚Ñï m0) : Martingale f ùí¢ Œº := by"
  },
  {
    "full_name": "ContinuousLinearEquiv.symm_toLinearEquiv",
    "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean",
    "teorema": "theorem ContinuousLinearEquiv.symm_toLinearEquiv (M‚ÇÅ : Type u_4) (M‚ÇÇ : Type u_6) (R‚ÇÅ : Type u_1) (R‚ÇÇ : Type u_2) (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ) : e.symm.toLinearEquiv = e.symm := by"
  },
  {
    "full_name": "Fin.list_succ",
    "file_path": ".lake/packages/batteries/Batteries/Data/Fin/Lemmas.lean",
    "teorema": "theorem Fin.list_succ (n : Nat) : list (n + 1) = 0 :: List.map succ (list n) := by"
  },
  {
    "full_name": "WittVector.truncateFun_neg",
    "file_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
    "teorema": "theorem WittVector.truncateFun_neg (R : Type u_1) (n : ‚Ñï) (x : ùïé R) : truncateFun n (-x) = -truncateFun n x := by"
  },
  {
    "full_name": "Valuation.RankOne.zero_of_hom_zero",
    "file_path": "Mathlib/RingTheory/Valuation/RankOne.lean",
    "teorema": "theorem Valuation.RankOne.zero_of_hom_zero (x : Œì‚ÇÄ) (Œì‚ÇÄ : Type u_2) : x = 0 := by"
  },
  {
    "full_name": "List.foldl_range_subset_of_range_subset",
    "file_path": "Mathlib/Data/List/Lemmas.lean",
    "teorema": "theorem List.foldl_range_subset_of_range_subset (a : Œ±) (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (g : Œ± ‚Üí Œ≥ ‚Üí Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) : Set.range (foldl f a) ‚äÜ Set.range (foldl g a) := by"
  },
  {
    "full_name": "Polynomial.smeval_mul_X",
    "file_path": "Mathlib/Algebra/Polynomial/Smeval.lean",
    "teorema": "lemma Polynomial.smeval_mul_X (R : Type u_1) (S : Type u_2) (p : R[X]) (x : S) : (p * X).smeval x = p.smeval x * x := by"
  },
  {
    "full_name": "Equiv.Perm.sameCycle_pow_right",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean",
    "teorema": "theorem Equiv.Perm.sameCycle_pow_right (f : Perm Œ±) (n : ‚Ñï) (x : Œ±) (y : Œ±) (Œ± : Type u_2) : f.SameCycle x ((f ^ n) y) ‚Üî f.SameCycle x y := by"
  },
  {
    "full_name": "MeasureTheory.Measure.integral_isMulLeftInvariant_isMulRightInvariant_combo",
    "file_path": "Mathlib/MeasureTheory/Measure/Haar/Unique.lean",
    "teorema": "lemma MeasureTheory.Measure.integral_isMulLeftInvariant_isMulRightInvariant_combo (G : Type u_1) (f : G ‚Üí ‚Ñù) (g : G ‚Üí ‚Ñù) (Œº : Measure G) (ŒΩ : Measure G) : ‚à´ (x : G), f x ‚àÇŒº = (‚à´ (y : G), f y * (‚à´ (z : G), g (z‚Åª¬π * y) ‚àÇŒΩ)‚Åª¬π ‚àÇŒΩ) * ‚à´ (x : G), g x ‚àÇŒº := by"
  },
  {
    "full_name": "ContinuousMap.toNNReal_neg_algebraMap",
    "file_path": "Mathlib/Topology/ContinuousFunction/UniqueCFC.lean",
    "teorema": "lemma ContinuousMap.toNNReal_neg_algebraMap (X : Type u_1) (r : ‚Ñù‚â•0) : (-(algebraMap ‚Ñù C(X, ‚Ñù)) ‚Üër).toNNReal = 0 := by"
  },
  {
    "full_name": "algebraMap_le_algebraMap",
    "file_path": "Mathlib/Algebra/Order/Module/Algebra.lean",
    "teorema": "lemma algebraMap_le_algebraMap (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : (algebraMap Œ± Œ≤) a‚ÇÅ ‚â§ (algebraMap Œ± Œ≤) a‚ÇÇ ‚Üî a‚ÇÅ ‚â§ a‚ÇÇ := by"
  },
  {
    "full_name": "Polynomial.degree_restriction",
    "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean",
    "teorema": "lemma Polynomial.degree_restriction (R : Type u) (p : R[X]) : p.restriction.degree = p.degree := by"
  },
  {
    "full_name": "AlgebraicGeometry.quasiSeparated_eq_affineProperty_diagonal",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/QuasiSeparated.lean",
    "teorema": "lemma AlgebraicGeometry.quasiSeparated_eq_affineProperty_diagonal : @QuasiSeparated = targetAffineLocally QuasiCompact.affineProperty.diagonal := by"
  },
  {
    "full_name": "Matrix.toBlocks‚ÇÅ‚ÇÅ_diagonal",
    "file_path": "Mathlib/Data/Matrix/Block.lean",
    "teorema": "lemma Matrix.toBlocks‚ÇÅ‚ÇÅ_diagonal (l : Type u_1) (m : Type u_2) (v : l ‚äï m ‚Üí Œ±) (Œ± : Type u_12) : (diagonal v).toBlocks‚ÇÅ‚ÇÅ = diagonal fun i => v (Sum.inl i) := by"
  },
  {
    "full_name": "Asymptotics.IsBigO.eq_zero_of_norm_pow",
    "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean",
    "teorema": "theorem Asymptotics.IsBigO.eq_zero_of_norm_pow (E : Type u_3) (F : Type u_4) (f : E'' ‚Üí F'') (x‚ÇÄ : E'') : f x‚ÇÄ = 0 := by"
  },
  {
    "full_name": "Set.compl_iInter‚ÇÇ",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "lemma Set.compl_iInter‚ÇÇ (s : (i : Œπ) ‚Üí Œ∫ i ‚Üí Set Œ±) (Œ± : Type u_1) (Œπ : Sort u_4) (Œ∫ : Œπ ‚Üí Sort u_7) : (‚ãÇ i, ‚ãÇ j, s i j)·∂ú = ‚ãÉ i, ‚ãÉ j, (s i j)·∂ú := by"
  },
  {
    "full_name": "Finset.disjoint_insert_erase",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma Finset.disjoint_insert_erase (a : Œ±) (s : Finset Œ±) (t : Finset Œ±) (Œ± : Type u_1) : _root_.Disjoint (s.erase a) (insert a t) ‚Üî _root_.Disjoint s t := by"
  },
  {
    "full_name": "Polynomial.Monic.comp_X_add_C",
    "file_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
    "teorema": "lemma Polynomial.Monic.comp_X_add_C (R : Type u) (p : R[X]) (r : R) : (p.comp (X + C r)).Monic := by"
  },
  {
    "full_name": "ONote.omega_le_oadd",
    "file_path": "Mathlib/SetTheory/Ordinal/Notation.lean",
    "teorema": "lemma ONote.omega_le_oadd (a : ONote) (e : ONote) (n : ‚Ñï+) : œâ ^ e.repr ‚â§ (e.oadd n a).repr := by"
  },
  {
    "full_name": "Submodule.empty_set_smul",
    "file_path": "Mathlib/Algebra/Module/Submodule/Pointwise.lean",
    "teorema": "theorem Submodule.empty_set_smul (M : Type u_3) (N : Submodule R M) (R : Type u_2) : ‚àÖ ‚Ä¢ N = ‚ä• := by"
  },
  {
    "full_name": "CategoryTheory.Functor.map_shiftFunctorComm_hom_app",
    "file_path": "Mathlib/CategoryTheory/Shift/CommShift.lean",
    "teorema": "lemma CategoryTheory.Functor.map_shiftFunctorComm_hom_app (B : Type u_5) (C : Type u_1) (D : Type u_2) (F : C ‚•§ D) (X : C) (a : B) (b : B) : F.map ((shiftFunctorComm C a b).hom.app X) = (F.commShiftIso b).hom.app ((shiftFunctor C a).obj X) ‚â´ (shiftFunctor D b).map ((F.commShiftIso a).hom.app X) ‚â´ (shiftFunctorComm D a b).hom.app (F.obj X) ‚â´ (shiftFunctor D a).map ((F.commShiftIso b).inv.app X) ‚â´ (F.commShiftIso a).inv.app ((shiftFunctor C b).obj X) := by"
  },
  {
    "full_name": "Trivialization.Prod.continuous_to_fun",
    "file_path": "Mathlib/Topology/FiberBundle/Constructions.lean",
    "teorema": "lemma Trivialization.Prod.continuous_to_fun (F‚ÇÅ : Type u_2) (F‚ÇÇ : Type u_4) (e‚ÇÅ : Trivialization F‚ÇÅ TotalSpace.proj) (e‚ÇÇ : Trivialization F‚ÇÇ TotalSpace.proj) : ContinuousOn (toFun' e‚ÇÅ e‚ÇÇ) (TotalSpace.proj ‚Åª¬π' (e‚ÇÅ.baseSet ‚à© e‚ÇÇ.baseSet)) := by"
  },
  {
    "full_name": "MeasureTheory.Measure.map_prod_map",
    "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
    "teorema": "theorem MeasureTheory.Measure.map_prod_map (f : Œ± ‚Üí Œ≤) (g : Œ≥ ‚Üí Œ¥) (Œ± : Type u_1) (Œ≤ : Type u_3) (Œ≥ : Type u_5) (Œ¥ : Type u_7) (Œºa : Measure Œ±) (Œºc : Measure Œ≥) : (map f Œºa).prod (map g Œºc) = map (Prod.map f g) (Œºa.prod Œºc) := by"
  },
  {
    "full_name": "Set.encard_eq_encard_iff_encard_diff_eq_encard_diff",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "lemma Set.encard_eq_encard_iff_encard_diff_eq_encard_diff (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) : s.encard = t.encard ‚Üî (s \\ t).encard = (t \\ s).encard := by"
  },
  {
    "full_name": "Monoid.PushoutI.NormalWord.ext",
    "file_path": "Mathlib/GroupTheory/PushoutI.lean",
    "teorema": "theorem Monoid.PushoutI.NormalWord.ext (G : Œπ ‚Üí Type u_2) (H : Type u_3) (d : Transversal œÜ) (w‚ÇÅ : NormalWord d) (w‚ÇÇ : NormalWord d) (Œπ : Type u_1) (œÜ : (i : Œπ) ‚Üí H ‚Üí* G i) : w‚ÇÅ = w‚ÇÇ := by"
  },
  {
    "full_name": "KaehlerDifferential.span_range_derivation",
    "file_path": "Mathlib/RingTheory/Kaehler/Basic.lean",
    "teorema": "lemma KaehlerDifferential.span_range_derivation (R : Type u) (S : Type v) : Submodule.span S (Set.range ‚áë(D R S)) = ‚ä§ := by"
  },
  {
    "full_name": "Complex.cos_eq_iff_quadratic",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean",
    "teorema": "theorem Complex.cos_eq_iff_quadratic (w : ‚ÑÇ) (z : ‚ÑÇ) : cos z = w ‚Üî cexp (z * I) ^ 2 - 2 * w * cexp (z * I) + 1 = 0 := by"
  },
  {
    "full_name": "norm_div_eq_zero_iff",
    "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean",
    "teorema": "theorem norm_div_eq_zero_iff (E : Type u_6) (a : E) (b : E) : ‚Äña / b‚Äñ = 0 ‚Üî a = b := by"
  },
  {
    "full_name": "LieAlgebra.IsKilling.chainLength_nsmul",
    "file_path": "Mathlib/Algebra/Lie/Weights/RootSystem.lean",
    "teorema": "lemma LieAlgebra.IsKilling.chainLength_nsmul (H : LieSubalgebra K L) (K : Type u_1) (L : Type u_2) (x : L) (Œ± : Weight K (‚Ü•H) L) (Œ≤ : Weight K (‚Ü•H) L) : chainLength Œ± Œ≤ ‚Ä¢ x = ‚ÅÖcoroot Œ±, x‚ÅÜ := by"
  },
  {
    "full_name": "Option.bind_pmap",
    "file_path": "Mathlib/Data/Option/Basic.lean",
    "teorema": "theorem Option.bind_pmap (H : ‚àÄ (a : Œ±), a ‚àà x ‚Üí p a) (f : (a : Œ±) ‚Üí p a ‚Üí Œ≤) (g : Œ≤ ‚Üí Option Œ≥) (p : Œ± ‚Üí Prop) (x : Option Œ±) (Œ± : Type u_5) (Œ≤ : Type u_6) (Œ≥ : Type u_6) : pmap f x H >>= g = x.pbind fun a h => g (f a ‚ãØ) := by"
  },
  {
    "full_name": "PerfectPairing.apply_apply_toDualRight_symm",
    "file_path": "Mathlib/LinearAlgebra/PerfectPairing.lean",
    "teorema": "theorem PerfectPairing.apply_apply_toDualRight_symm (M : Type u_2) (N : Type u_3) (R : Type u_1) (f : Dual R M) (p : PerfectPairing R M N) (x : M) : (p x) (p.toDualRight.symm f) = f x := by"
  },
  {
    "full_name": "NNReal.strictConcaveOn_rpow",
    "file_path": "Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean",
    "teorema": "lemma NNReal.strictConcaveOn_rpow (p : ‚Ñù) : StrictConcaveOn ‚Ñù‚â•0 univ fun x => x ^ p := by"
  },
  {
    "full_name": "MeasureTheory.iUnion_spanningSets",
    "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean",
    "teorema": "lemma MeasureTheory.iUnion_spanningSets (Œ± : Type u_1) (Œº : Measure Œ±) : ‚ãÉ i, spanningSets Œº i = univ := by"
  },
  {
    "full_name": "Polynomial.rootMultiplicity_expand",
    "file_path": "Mathlib/Algebra/Polynomial/Expand.lean",
    "teorema": "theorem Polynomial.rootMultiplicity_expand (R : Type u) (f : R[X]) (p : ‚Ñï) (r : R) : rootMultiplicity r ((expand R p) f) = p * rootMultiplicity (r ^ p) f := by"
  },
  {
    "full_name": "List.span_eq_take_drop",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "lemma List.span_eq_take_drop (l : List Œ±) (p : Œ± ‚Üí Bool) (Œ± : Type u) : span p l = (takeWhile p l, dropWhile p l) := by"
  },
  {
    "full_name": "SimpleGraph.triangleRemovalBound_pos",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Triangle/Removal.lean",
    "teorema": "theorem SimpleGraph.triangleRemovalBound_pos (Œµ : ‚Ñù) : 0 < triangleRemovalBound Œµ := by"
  },
  {
    "full_name": "Fin.card_fintype_uIcc",
    "file_path": "Mathlib/Order/Interval/Finset/Fin.lean",
    "teorema": "theorem Fin.card_fintype_uIcc (a : Fin n) (b : Fin n) (n : ‚Ñï) : Fintype.card ‚Üë(Set.uIcc a b) = (‚Üë‚Üëb - ‚Üë‚Üëa).natAbs + 1 := by"
  },
  {
    "full_name": "CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.isIso_hom",
    "file_path": "Mathlib/CategoryTheory/Functor/KanExtension/Pointwise.lean",
    "teorema": "theorem CategoryTheory.Functor.LeftExtension.IsPointwiseLeftKanExtension.isIso_hom (C : Type u_1) (D : Type u_2) (E : L.LeftExtension F) (F : C ‚•§ H) (H : Type u_3) (L : C ‚•§ D) : IsIso E.hom := by"
  },
  {
    "full_name": "WittVector.mul_coeff_zero",
    "file_path": "Mathlib/RingTheory/WittVector/Defs.lean",
    "teorema": "lemma WittVector.mul_coeff_zero (R : Type u_1) (x : ùïé R) (y : ùïé R) : (x * y).coeff 0 = x.coeff 0 * y.coeff 0 := by"
  },
  {
    "full_name": "ArithmeticFunction.vonMangoldt_apply_one",
    "file_path": "Mathlib/NumberTheory/VonMangoldt.lean",
    "teorema": "lemma ArithmeticFunction.vonMangoldt_apply_one : Œõ 1 = 0 := by"
  },
  {
    "full_name": "List.get?_zero_scanl",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "lemma List.get?_zero_scanl (b : Œ≤) (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (l : List Œ±) (Œ± : Type u) (Œ≤ : Type v) : (scanl f b l).get? 0 = some b := by"
  },
  {
    "full_name": "CategoryTheory.Limits.Concrete.to_product_injective_of_isLimit",
    "file_path": "Mathlib/CategoryTheory/Limits/ConcreteCategory.lean",
    "teorema": "lemma CategoryTheory.Limits.Concrete.to_product_injective_of_isLimit (C : Type u) (D : Cone F) (F : J ‚•§ C) (J : Type w) : Function.Injective fun x j => (D.œÄ.app j) x := by"
  },
  {
    "full_name": "essSup_map_measure",
    "file_path": "Mathlib/MeasureTheory/Function/EssSup.lean",
    "teorema": "lemma essSup_map_measure (f : Œ± ‚Üí Œ≥) (g : Œ≥ ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œº : Measure Œ±) : essSup g (Measure.map f Œº) = essSup (g ‚àò f) Œº := by"
  },
  {
    "full_name": "PFun.mem_dom",
    "file_path": "Mathlib/Data/PFun.lean",
    "teorema": "lemma PFun.mem_dom (f : Œ± ‚Üí. Œ≤) (x : Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : x ‚àà f.Dom ‚Üî ‚àÉ y, y ‚àà f x := by"
  },
  {
    "full_name": "tfae_of_isNoetherianRing_of_localRing_of_isDomain",
    "file_path": "Mathlib/RingTheory/DiscreteValuationRing/TFAE.lean",
    "teorema": "theorem tfae_of_isNoetherianRing_of_localRing_of_isDomain (R : Type u_1) : [IsPrincipalIdealRing R, ValuationRing R, IsDedekindDomain R, := by"
  },
  {
    "full_name": "PadicInt.pow_p_dvd_int_iff",
    "file_path": "Mathlib/NumberTheory/Padics/PadicIntegers.lean",
    "teorema": "theorem PadicInt.pow_p_dvd_int_iff (a : ‚Ñ§) (n : ‚Ñï) (p : ‚Ñï) : ‚Üëp ^ n ‚à£ ‚Üëa ‚Üî ‚Üëp ^ n ‚à£ a := by"
  },
  {
    "full_name": "CategoryTheory.NonPreadditiveAbelian.diag_œÉ",
    "file_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
    "teorema": "lemma CategoryTheory.NonPreadditiveAbelian.diag_œÉ (C : Type u) (X : C) : diag X ‚â´ œÉ = 0 := by"
  },
  {
    "full_name": "AffineSubspace.direction_affineSpan_insert",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean",
    "teorema": "theorem AffineSubspace.direction_affineSpan_insert (P : Type u_3) (k : Type u_1) (p1 : P) (p2 : P) (s : AffineSubspace k P) : (affineSpan k (insert p2 ‚Üës)).direction = Submodule.span k {p2 -·µ• p1} ‚äî s.direction := by"
  },
  {
    "full_name": "Even.sub_odd",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "lemma Even.sub_odd (a : Œ±) (b : Œ±) (Œ± : Type u_2) : Odd (a - b) := by"
  },
  {
    "full_name": "UpperSet.sdiff_singleton",
    "file_path": "Mathlib/Order/UpperLower/Basic.lean",
    "teorema": "lemma UpperSet.sdiff_singleton (a : Œ±) (s : UpperSet Œ±) (Œ± : Type u_1) : s.sdiff {a} = s.erase a := by"
  },
  {
    "full_name": "Set.nonempty_Ico_sdiff",
    "file_path": "Mathlib/Algebra/Order/Interval/Set/Group.lean",
    "teorema": "lemma Set.nonempty_Ico_sdiff (dx : Œ±) (dy : Œ±) (x : Œ±) (y : Œ±) (Œ± : Type u_1) : Nonempty ‚Üë(Ico x (x + dx) \\ Ico y (y + dy)) := by"
  },
  {
    "full_name": "Besicovitch.card_le_multiplicity",
    "file_path": "Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean",
    "teorema": "theorem Besicovitch.card_le_multiplicity (E : Type u_1) (s : Finset E) : s.card ‚â§ multiplicity E := by"
  },
  {
    "full_name": "Polynomial.derivative_rootMultiplicity_of_root",
    "file_path": "Mathlib/Algebra/Polynomial/FieldDivision.lean",
    "teorema": "theorem Polynomial.derivative_rootMultiplicity_of_root (R : Type u) (p : R[X]) (t : R) : rootMultiplicity t (derivative p) = rootMultiplicity t p - 1 := by"
  },
  {
    "full_name": "hasSum_one_div_nat_pow_mul_cos",
    "file_path": "Mathlib/NumberTheory/ZetaValues.lean",
    "teorema": "lemma hasSum_one_div_nat_pow_mul_cos (k : ‚Ñï) (x : ‚Ñù) : HasSum (fun n => 1 / ‚Üën ^ (2 * k) * Real.cos (2 * œÄ * ‚Üën * x)) ((-1) ^ (k + 1) * (2 * œÄ) ^ (2 * k) / 2 / ‚Üë(2 * k)! * Polynomial.eval x (Polynomial.map (algebraMap ‚Ñö ‚Ñù) (Polynomial.bernoulli (2 * k)))) := by"
  },
  {
    "full_name": "ProbabilityTheory.cond_empty",
    "file_path": "Mathlib/Probability/ConditionalProbability.lean",
    "teorema": "lemma ProbabilityTheory.cond_empty (Œ© : Type u_1) (Œº : Measure Œ©) : Œº[|‚àÖ] = 0 := by"
  },
  {
    "full_name": "ByteArray.get_append_left",
    "file_path": ".lake/packages/batteries/Batteries/Data/ByteArray.lean",
    "teorema": "lemma ByteArray.get_append_left (a : ByteArray) (b : ByteArray) (i : Nat) : (a ++ b)[i] = a[i] := by"
  },
  {
    "full_name": "SatisfiesM_Option_eq",
    "file_path": ".lake/packages/batteries/Batteries/Classes/SatisfiesM.lean",
    "teorema": "theorem SatisfiesM_Option_eq (p : Œ±‚úù ‚Üí Prop) (x : Option Œ±‚úù) : SatisfiesM p x ‚Üí ‚àÄ (a : Œ±‚úù), x = some a ‚Üí p a := by"
  },
  {
    "full_name": "DirectSum.isInternal_ne_bot_iff",
    "file_path": "Mathlib/Algebra/DirectSum/Module.lean",
    "teorema": "theorem DirectSum.isInternal_ne_bot_iff (A : Œπ ‚Üí Submodule R M) (M : Type u_1) (R : Type u) (Œπ : Type v) : (IsInternal fun i => A ‚Üëi) ‚Üî IsInternal A := by"
  },
  {
    "full_name": "one_lt_mul_self_iff",
    "file_path": "Mathlib/Algebra/Order/Monoid/Defs.lean",
    "teorema": "lemma one_lt_mul_self_iff (a : Œ±) (Œ± : Type u_1) : ¬¨1 < a * a := by"
  },
  {
    "full_name": "Multiset.filter_congr",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.filter_congr (_l : List Œ±) (p : Œ± ‚Üí Prop) (q : Œ± ‚Üí Prop) (Œ± : Type u_1) : ‚àÄ x ‚àà _l, decide (p x) = decide (q x) := by"
  },
  {
    "full_name": "MeasureTheory.condexpL1CLM_indicatorConst",
    "file_path": "Mathlib/MeasureTheory/Function/ConditionalExpectation/CondexpL1.lean",
    "teorema": "lemma MeasureTheory.condexpL1CLM_indicatorConst (F : Type u_3) (hm : m ‚â§ m0) (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚ä§) (m : MeasurableSpace Œ±) (m0 : MeasurableSpace Œ±) (s : Set Œ±) (x : F') (Œ± : Type u_1) (Œº : Measure Œ±) : (condexpL1CLM F' hm Œº) ‚Üë(simpleFunc.indicatorConst 1 hs hŒºs x) = (condexpInd F' hm Œº s) x := by"
  },
  {
    "full_name": "LinearMap.toMatrix‚ÇÇ_mul_basis_toMatrix",
    "file_path": "Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean",
    "teorema": "theorem LinearMap.toMatrix‚ÇÇ_mul_basis_toMatrix (B : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] R) (M‚ÇÅ : Type u_5) (M‚ÇÇ : Type u_6) (R : Type u_1) (b‚ÇÅ : Basis n R M‚ÇÅ) (b‚ÇÇ : Basis m R M‚ÇÇ) (c‚ÇÅ : Basis n' R M‚ÇÅ) (c‚ÇÇ : Basis m' R M‚ÇÇ) (m : Type u_10) (n : Type u_9) : (b‚ÇÅ.toMatrix ‚áëc‚ÇÅ)·µÄ * (toMatrix‚ÇÇ b‚ÇÅ b‚ÇÇ) B * b‚ÇÇ.toMatrix ‚áëc‚ÇÇ = (toMatrix‚ÇÇ c‚ÇÅ c‚ÇÇ) B := by"
  },
  {
    "full_name": "List.prefix_concat_iff",
    "file_path": "Mathlib/Data/List/Infix.lean",
    "teorema": "theorem List.prefix_concat_iff (a : Œ±) (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (Œ± : Type u_1) : l‚ÇÅ <+: l‚ÇÇ ++ [a] ‚Üî l‚ÇÅ = l‚ÇÇ ++ [a] ‚à® l‚ÇÅ <+: l‚ÇÇ := by"
  },
  {
    "full_name": "Real.isCauSeq_iff_lift",
    "file_path": "Mathlib/Data/Real/Archimedean.lean",
    "teorema": "theorem Real.isCauSeq_iff_lift (f : ‚Ñï ‚Üí ‚Ñö) (i : ‚Ñï) (j : ‚Ñï) (Œµ : ‚Ñù) : |(fun i => ‚Üë(f i)) j - (fun i => ‚Üë(f i)) i| < Œµ := by"
  },
  {
    "full_name": "CategoryTheory.Subobject.symm_apply_mem_iff_mem_image",
    "file_path": "Mathlib/CategoryTheory/Subobject/Lattice.lean",
    "teorema": "lemma CategoryTheory.Subobject.symm_apply_mem_iff_mem_image (e : Œ± ‚âÉ Œ≤) (x : Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : e (e.symm x) = x := by"
  },
  {
    "full_name": "forall‚ÇÉ_true_iff",
    "file_path": "Mathlib/Logic/Basic.lean",
    "teorema": "theorem forall‚ÇÉ_true_iff (Œ± : Sort u_1) (Œ≤ : Œ± ‚Üí Sort u_3) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort u_4) : (‚àÄ (a : Œ±) (b : Œ≤ a), Œ≥ a b ‚Üí True) ‚Üî True := by"
  },
  {
    "full_name": "Complex.sin_ofReal_im",
    "file_path": "Mathlib/Data/Complex/Exponential.lean",
    "teorema": "theorem Complex.sin_ofReal_im (x : ‚Ñù) : (sin ‚Üëx).im = 0 := by"
  },
  {
    "full_name": "DFA.pumping_lemma",
    "file_path": "Mathlib/Computability/DFA.lean",
    "teorema": "theorem DFA.pumping_lemma (M : DFA Œ± œÉ) (x : List Œ±) (Œ± : Type u) (œÉ : Type v) : ‚àÉ a b c, x = a ++ b ++ c ‚àß a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts := by"
  },
  {
    "full_name": "Finset.forall_mem_cons",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma Finset.forall_mem_cons (a : Œ±) (h : a ‚àâ s) (p : Œ± ‚Üí Prop) (s : Finset Œ±) (Œ± : Type u_1) : (‚àÄ x ‚àà cons a s h, p x) ‚Üî p a ‚àß ‚àÄ x ‚àà s, p x := by"
  },
  {
    "full_name": "groupCohomology.toCocycles_comp_isoOneCocycles_hom",
    "file_path": "Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean",
    "teorema": "lemma groupCohomology.toCocycles_comp_isoOneCocycles_hom (A : Rep k G) (G : Type u) (k : Type u) : toCocycles A 0 1 ‚â´ (isoOneCocycles A).hom = (zeroCochainsLequiv A).toModuleIso.hom ‚â´ ModuleCat.ofHom (shortComplexH1 A).moduleCatToCycles := by"
  },
  {
    "full_name": "ContextFreeGrammar.Derives.append_right",
    "file_path": "Mathlib/Computability/ContextFreeGrammar.lean",
    "teorema": "theorem ContextFreeGrammar.Derives.append_right (T : Type uT) (g : ContextFreeGrammar T) (p : List (Symbol T g.NT)) (v : List (Symbol T g.NT)) (w : List (Symbol T g.NT)) : g.Derives (v ++ p) (w ++ p) := by"
  },
  {
    "full_name": "continuous_finprod",
    "file_path": "Mathlib/Topology/Algebra/Monoid.lean",
    "teorema": "lemma continuous_finprod (M : Type u_3) (X : Type u_5) (f : Œπ ‚Üí X ‚Üí M) (Œπ : Type u_1) : Continuous fun x => ‚àè·∂† (i : Œπ), f i x := by"
  },
  {
    "full_name": "surjective_of_isSwap_of_isPretransitive",
    "file_path": "Mathlib/GroupTheory/Perm/ClosureSwap.lean",
    "teorema": "lemma surjective_of_isSwap_of_isPretransitive (G : Type u_1) (Œ± : Type u_2) : Function.Surjective ‚áë(toPermHom G Œ±) := by"
  },
  {
    "full_name": "ZMod.charpoly_pow_card",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/FiniteField.lean",
    "teorema": "lemma ZMod.charpoly_pow_card (M : Matrix n n (ZMod p)) (n : Type u_1) (p : ‚Ñï) : (M ^ p).charpoly = M.charpoly := by"
  },
  {
    "full_name": "CategoryTheory.pullbackShiftFunctorAdd'_inv_app",
    "file_path": "Mathlib/CategoryTheory/Shift/Pullback.lean",
    "teorema": "theorem CategoryTheory.pullbackShiftFunctorAdd'_inv_app (B : Type u_3) (b‚ÇÅ : B) (b‚ÇÇ : B) (b‚ÇÉ : B) : b‚ÇÅ + b‚ÇÇ = b‚ÇÉ := by"
  },
  {
    "full_name": "ArithmeticFunction.sum_moebius_mul_log_eq",
    "file_path": "Mathlib/NumberTheory/VonMangoldt.lean",
    "teorema": "lemma ArithmeticFunction.sum_moebius_mul_log_eq (n : ‚Ñï) : ‚àë d ‚àà n.divisors, ‚Üë(Œº d) * log d = -Œõ n := by"
  },
  {
    "full_name": "fourierIntegral_gaussian_innerProductSpace",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean",
    "teorema": "theorem fourierIntegral_gaussian_innerProductSpace (V : Type u_1) (b : ‚ÑÇ) (w : V) : ùìï (fun v => cexp (-b * ‚Üë‚Äñv‚Äñ ^ 2)) w = (‚ÜëœÄ / b) ^ (‚Üë(FiniteDimensional.finrank ‚Ñù V) / 2) * cexp (-‚ÜëœÄ ^ 2 * ‚Üë‚Äñw‚Äñ ^ 2 / b) := by"
  },
  {
    "full_name": "Set.PairwiseDisjoint.image_finset_of_le",
    "file_path": "Mathlib/Data/Finset/Pairwise.lean",
    "teorema": "lemma Set.PairwiseDisjoint.image_finset_of_le (f : Œπ ‚Üí Œ±) (g : Œπ ‚Üí Œπ) (s : Finset Œπ) (Œ± : Type u_1) (Œπ : Type u_2) : (‚Üë(Finset.image g s)).PairwiseDisjoint f := by"
  },
  {
    "full_name": "Pretrivialization.mem_source",
    "file_path": "Mathlib/Topology/FiberBundle/Trivialization.lean",
    "teorema": "theorem Pretrivialization.mem_source (B : Type u_2) (F : Type u_3) (Z : Type u_5) (e : Pretrivialization F proj) (proj : Z ‚Üí B) (x : Z) : x ‚àà e.source ‚Üî proj x ‚àà e.baseSet := by"
  },
  {
    "full_name": "CategoryTheory.Iso.cancel_iso_hom_left",
    "file_path": "Mathlib/CategoryTheory/Iso.lean",
    "teorema": "lemma CategoryTheory.Iso.cancel_iso_hom_left (C : Type u) (X : C) (Y : C) (Z : C) (f : X ‚âÖ Y) (g : Y ‚ü∂ Z) : f.hom ‚â´ g = f.hom ‚â´ g' ‚Üî g = g' := by"
  },
  {
    "full_name": "Finset.card_insert_of_not_mem",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "theorem Finset.card_insert_of_not_mem (a : Œ±) (s : Finset Œ±) (Œ± : Type u_1) : (insert a s).card = s.card + 1 := by"
  },
  {
    "full_name": "Equiv.Perm.card_support_swap",
    "file_path": "Mathlib/GroupTheory/Perm/Support.lean",
    "teorema": "theorem Equiv.Perm.card_support_swap (x : Œ±) (y : Œ±) (Œ± : Type u_1) : (x ::‚Çò y ::‚Çò 0).Nodup := by"
  },
  {
    "full_name": "IsSelfAdjoint.spectralRadius_eq_nnnorm",
    "file_path": "Mathlib/Analysis/NormedSpace/Star/Spectrum.lean",
    "teorema": "theorem IsSelfAdjoint.spectralRadius_eq_nnnorm (A : Type u_1) (a : A) : spectralRadius ‚ÑÇ a = ‚Üë‚Äña‚Äñ‚Çä := by"
  },
  {
    "full_name": "Complex.abs_arg_lt_pi_div_two_iff",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean",
    "teorema": "theorem Complex.abs_arg_lt_pi_div_two_iff (z : ‚ÑÇ) : |z.arg| < œÄ / 2 ‚Üî 0 < z.re ‚à® z = 0 := by"
  },
  {
    "full_name": "ZFSet.toSet_equiv_aux",
    "file_path": "Mathlib/SetTheory/ZFC/Basic.lean",
    "teorema": "theorem ZFSet.toSet_equiv_aux (s : Set ZFSet) (x : ZFSet) : (mk (PSet.mk (Shrink.{u, u + 1} ‚Üës) fun x => Quotient.out ‚Üë((equivShrink ‚Üës).symm x))).toSet = s := by"
  },
  {
    "full_name": "Submodule.finset_inf_coe",
    "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean",
    "teorema": "theorem Submodule.finset_inf_coe (M : Type u_3) (R : Type u_1) (p : Œπ ‚Üí Submodule R M) (s : Finset Œπ) (Œπ : Type u_4) : ‚Üë(s.inf p) = ‚ãÇ i ‚àà s, ‚Üë(p i) := by"
  },
  {
    "full_name": "PartialHomeomorph.extend_symm_preimage_inter_range_eventuallyEq",
    "file_path": "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean",
    "teorema": "theorem PartialHomeomorph.extend_symm_preimage_inter_range_eventuallyEq (E : Type u_2) (H : Type u_4) (I : ModelWithCorners ùïú E H) (M : Type u_3) (f : PartialHomeomorph M H) (s : Set M) (x : M) (ùïú : Type u_1) : ‚Üë(f.extend I).symm ‚Åª¬π' s ‚à© range ‚ÜëI =·∂†[ùìù (‚Üë(f.extend I) x)] ‚Üë(f.extend I) '' s := by"
  },
  {
    "full_name": "OrthogonalFamily.summable_of_lp",
    "file_path": "Mathlib/Analysis/InnerProductSpace/l2Space.lean",
    "teorema": "lemma OrthogonalFamily.summable_of_lp (E : Type u_3) (G : Œπ ‚Üí Type u_4) (V : (i : Œπ) ‚Üí G i ‚Üí‚Çó·µ¢[ùïú] E) (f : ‚Ü•(lp G 2)) (Œπ : Type u_1) (ùïú : Type u_2) : Summable fun i => (V i) (‚Üëf i) := by"
  },
  {
    "full_name": "Nat.nth_of_card_le",
    "file_path": "Mathlib/Data/Nat/Nth.lean",
    "teorema": "theorem Nat.nth_of_card_le (n : ‚Ñï) (p : ‚Ñï ‚Üí Prop) : nth p n = 0 := by"
  },
  {
    "full_name": "IsKleinFour.not_isCyclic",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/KleinFour.lean",
    "teorema": "lemma IsKleinFour.not_isCyclic : False := by"
  },
  {
    "full_name": "Real.two_mul_arctan_inv_3_add_arctan_inv_7",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean",
    "teorema": "lemma Real.two_mul_arctan_inv_3_add_arctan_inv_7 : 2 * arctan 3‚Åª¬π + arctan 7‚Åª¬π = œÄ / 4 := by"
  },
  {
    "full_name": "Polynomial.support_smul",
    "file_path": "Mathlib/Algebra/Polynomial/Coeff.lean",
    "teorema": "lemma Polynomial.support_smul (R : Type u) (S : Type v) (p : R[X]) (r : S) : (r ‚Ä¢ p).support ‚äÜ p.support := by"
  },
  {
    "full_name": "EuclideanGeometry.Sphere.two_zsmul_oangle_eq",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Sphere.lean",
    "teorema": "lemma EuclideanGeometry.Sphere.two_zsmul_oangle_eq (P : Type u_2) (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) : 2 ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÇ p‚ÇÑ = 2 ‚Ä¢ ‚à° p‚ÇÅ p‚ÇÉ p‚ÇÑ := by"
  },
  {
    "full_name": "IsLindelof.compl_mem_sets",
    "file_path": "Mathlib/Topology/Compactness/Lindelof.lean",
    "teorema": "lemma IsLindelof.compl_mem_sets (X : Type u) (f : Filter X) : s·∂ú ‚àà f := by"
  },
  {
    "full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.quasiIso_iff",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/QuasiIso.lean",
    "teorema": "lemma CategoryTheory.ShortComplex.LeftHomologyMapData.quasiIso_iff (C : Type u_2) (S‚ÇÅ : ShortComplex C) (S‚ÇÇ : ShortComplex C) (h‚ÇÅ : S‚ÇÅ.LeftHomologyData) (h‚ÇÇ : S‚ÇÇ.LeftHomologyData) (Œ≥ : LeftHomologyMapData œÜ h‚ÇÅ h‚ÇÇ) (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ) : QuasiIso œÜ ‚Üî IsIso Œ≥.œÜH := by"
  },
  {
    "full_name": "Turing.TM1to1.stepAux_read",
    "file_path": "Mathlib/Computability/TuringMachine.lean",
    "teorema": "theorem Turing.TM1to1.stepAux_read (L : ListBlank Œì) (R : ListBlank Œì) (dec : Vector Bool n ‚Üí Œì) (enc : Œì ‚Üí Vector Bool n) (enc0 : enc default = Vector.replicate n false) (f : Œì ‚Üí Stmt Bool Œõ' œÉ) (n : ‚Ñï) (v : œÉ) (Œì : Type u_1) (Œõ : Type u_2) (œÉ : Type u_3) : stepAux (read dec f) v (trTape' enc0 L R) = stepAux (f R.head) v (trTape' enc0 L R) := by"
  },
  {
    "full_name": "Subgroup.index_iInf_ne_zero",
    "file_path": "Mathlib/GroupTheory/Index.lean",
    "teorema": "lemma Subgroup.index_iInf_ne_zero (G : Type u_1) (f : Œπ ‚Üí Subgroup G) (Œπ : Type u_2) : (‚®Ö i, f i).index ‚â† 0 := by"
  },
  {
    "full_name": "Matrix.fromBlocks_submatrix_sum_swap_sum_swap",
    "file_path": "Mathlib/Data/Matrix/Block.lean",
    "teorema": "theorem Matrix.fromBlocks_submatrix_sum_swap_sum_swap (A : Matrix n l Œ±) (B : Matrix n m Œ±) (C : Matrix o l Œ±) (D : Matrix o m Œ±) (l : Type u_14) (m : Type u_15) (n : Type u_16) (o : Type u_17) (Œ± : Type u_18) : (fromBlocks A B C D).submatrix Sum.swap Sum.swap = fromBlocks D C B A := by"
  },
  {
    "full_name": "sphere_ext_iff",
    "file_path": "Mathlib/Geometry/Manifold/Instances/Sphere.lean",
    "teorema": "theorem sphere_ext_iff (u : ‚Üë(sphere 0 1)) (v : ‚Üë(sphere 0 1)) : u = v ‚Üî ‚ü™‚Üëu, ‚Üëv‚ü´_‚Ñù = 1 := by"
  },
  {
    "full_name": "Polynomial.Chebyshev.T_sub_two",
    "file_path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean",
    "teorema": "lemma Polynomial.Chebyshev.T_sub_two (R : Type u_1) (n : ‚Ñ§) : T R (n - 2) = 2 * X * T R (n - 1) - T R n := by"
  },
  {
    "full_name": "CategoryTheory.constant_of_preserves_morphisms",
    "file_path": "Mathlib/CategoryTheory/IsConnected.lean",
    "teorema": "theorem CategoryTheory.constant_of_preserves_morphisms (F : J ‚Üí Œ±) (J : Type u‚ÇÅ) (j : J) (Œ± : Type u‚ÇÇ) : F j = F j' := by"
  },
  {
    "full_name": "ENNReal.inv_top",
    "file_path": "Mathlib/Data/ENNReal/Inv.lean",
    "teorema": "theorem ENNReal.inv_top (a : ‚Ñù‚â•0‚àû) (b : ‚Ñù‚â•0‚àû) : a ‚àà {b | 1 ‚â§ ‚ä§ * b} := by"
  },
  {
    "full_name": "CharP.natCast_eq_natCast'",
    "file_path": "Mathlib/Algebra/CharP/Defs.lean",
    "teorema": "lemma CharP.natCast_eq_natCast' (a : ‚Ñï) (b : ‚Ñï) : ‚Üëa = ‚Üëb := by"
  },
  {
    "full_name": "List.getElem?_enumFrom",
    "file_path": "Mathlib/Data/List/Enum.lean",
    "teorema": "lemma List.getElem?_enumFrom (a : Œ±) (l : List Œ±) (n : ‚Ñï) (Œ± : Type u_1) : (enumFrom n (a :: l))[0]? = Option.map (fun a => (n + 0, a)) (a :: l)[0]? := by"
  },
  {
    "full_name": "Real.isBigO_exp_comp_exp_comp",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
    "teorema": "lemma Real.isBigO_exp_comp_exp_comp (f : Œ± ‚Üí ‚Ñù) (g : Œ± ‚Üí ‚Ñù) (l : Filter Œ±) (x : ‚Ñù) (Œ± : Type u_1) : (IsBoundedUnder (fun x x_1 => x ‚â§ x_1) l fun x => ‚Äñrexp (f x)‚Äñ / ‚Äñrexp (g x)‚Äñ) ‚Üî IsBoundedUnder (fun x x_1 => x ‚â§ x_1) l (f - g) := by"
  },
  {
    "full_name": "star_ne_zero",
    "file_path": "Mathlib/Algebra/Star/Basic.lean",
    "teorema": "lemma star_ne_zero (R : Type u) (x : R) : star x ‚â† 0 ‚Üî x ‚â† 0 := by"
  },
  {
    "full_name": "CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_le",
    "file_path": "Mathlib/AlgebraicTopology/SimplicialObject.lean",
    "teorema": "lemma CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_le (C : Type u) (X : CosimplicialObject C) (i : Fin (n + 2)) (j : Fin (n + 1)) (n : ‚Ñï) : X.Œ¥ i.castSucc ‚â´ X.œÉ j.succ = X.œÉ j ‚â´ X.Œ¥ i := by"
  },
  {
    "full_name": "Finset.image_add_left_Icc",
    "file_path": "Mathlib/Algebra/Order/Interval/Finset.lean",
    "teorema": "lemma Finset.image_add_left_Icc (a : Œ±) (b : Œ±) (c : Œ±) (Œ± : Type u_2) : image (fun x => c + x) (Icc a b) = Icc (c + a) (c + b) := by"
  },
  {
    "full_name": "IsPrimitiveRoot.norm_eq_neg_one_pow",
    "file_path": "Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean",
    "teorema": "theorem IsPrimitiveRoot.norm_eq_neg_one_pow (K : Type u) (L : Type v) (Œ∂ : L) : (Algebra.norm K) Œ∂ = (-1) ^ FiniteDimensional.finrank K L := by"
  },
  {
    "full_name": "QPF.suppPreservation_iff_liftpPreservation",
    "file_path": "Mathlib/Data/QPF/Univariate/Basic.lean",
    "teorema": "lemma QPF.suppPreservation_iff_liftpPreservation : SuppPreservation ‚Üî LiftpPreservation := by"
  },
  {
    "full_name": "SimpleGraph.IsAcyclic.path_unique",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean",
    "teorema": "theorem SimpleGraph.IsAcyclic.path_unique (G : SimpleGraph V) (V : Type u) (p : G.Path v w) (q : G.Path v w) (v : V) (w : V) : p = q := by"
  },
  {
    "full_name": "StructureGroupoid.LocalInvariantProp.liftPropWithinAt_indep_chart_source_aux",
    "file_path": "Mathlib/Geometry/Manifold/LocalInvariantProperties.lean",
    "teorema": "lemma StructureGroupoid.LocalInvariantProp.liftPropWithinAt_indep_chart_source_aux (H : Type u_1) (M : Type u_2) (P : (H ‚Üí H') ‚Üí Set H ‚Üí H ‚Üí Prop) (e : PartialHomeomorph M H) (g : M ‚Üí H') (s : Set M) (x : M) : P (g ‚àò ‚Üëe.symm) (‚Üëe.symm ‚Åª¬π' s) (‚Üëe x) ‚Üî P (g ‚àò ‚Üëe'.symm) (‚Üëe'.symm ‚Åª¬π' s) (‚Üëe' x) := by"
  },
  {
    "full_name": "CategoryTheory.CostructuredArrow.homMk'_mk_comp",
    "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean",
    "teorema": "theorem CategoryTheory.CostructuredArrow.homMk'_mk_comp (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (S : C ‚•§ D) (T : D) (Y : C) (f : S.obj Y ‚ü∂ T) (g : Y' ‚ü∂ Y) : mk (S.map (g' ‚â´ g) ‚â´ (mk f).hom) = mk (S.map g' ‚â´ (mk (S.map g ‚â´ f)).hom) := by"
  },
  {
    "full_name": "Finset.prod_range_div",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "theorem Finset.prod_range_div (M : Type u_6) (f : ‚Ñï ‚Üí M) (n : ‚Ñï) : ‚àè i ‚àà range n, f (i + 1) / f i = f n / f 0 := by"
  },
  {
    "full_name": "Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Transvection.lean",
    "teorema": "theorem Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux (M : Matrix n n ùïú) (n : Type) (ùïú : Type u_3) : ‚àÉ L L' D, (List.map toMatrix L).prod * M * (List.map toMatrix L').prod = diagonal D := by"
  },
  {
    "full_name": "Submonoid.pow_exponent_eq_one",
    "file_path": "Mathlib/GroupTheory/Exponent.lean",
    "teorema": "lemma Submonoid.pow_exponent_eq_one (G : Type u) (S : Submonoid G) (g : G) : g ^ exponent ‚Ü•S = 1 := by"
  },
  {
    "full_name": "Submonoid.LocalizationMap.ext",
    "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean",
    "teorema": "lemma Submonoid.LocalizationMap.ext (M : Type u_1) (N : Type u_2) (S : Submonoid M) (f : S.LocalizationMap N) (g : S.LocalizationMap N) : f = g := by"
  },
  {
    "full_name": "CanonicallyOrderedCommSemiring.mul_pos",
    "file_path": "Mathlib/Algebra/Order/Ring/Canonical.lean",
    "teorema": "lemma CanonicallyOrderedCommSemiring.mul_pos (a : Œ±) (b : Œ±) (Œ± : Type u) : 0 < a * b ‚Üî 0 < a ‚àß 0 < b := by"
  },
  {
    "full_name": "Polynomial.isNilpotent_iff",
    "file_path": "Mathlib/RingTheory/Polynomial/Nilpotent.lean",
    "teorema": "lemma Polynomial.isNilpotent_iff (P : R[X]) (R : Type u_1) : IsNilpotent P ‚Üî ‚àÄ (i : ‚Ñï), IsNilpotent (P.coeff i) := by"
  },
  {
    "full_name": "Real.Wallis.tendsto_W_nhds_pi_div_two",
    "file_path": "Mathlib/Data/Real/Pi/Wallis.lean",
    "teorema": "lemma Real.Wallis.tendsto_W_nhds_pi_div_two : Tendsto W atTop (ùìù (œÄ / 2)) := by"
  },
  {
    "full_name": "minpolyDiv_eq_of_isIntegrallyClosed",
    "file_path": "Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean",
    "teorema": "theorem minpolyDiv_eq_of_isIntegrallyClosed (K : Type u_3) (R : Type u_1) (S : Type u_2) (x : S) : minpolyDiv R x = minpolyDiv K x := by"
  },
  {
    "full_name": "Module.Ray.units_smul_of_pos",
    "file_path": "Mathlib/LinearAlgebra/Ray.lean",
    "teorema": "lemma Module.Ray.units_smul_of_pos (M : Type u_2) (R : Type u_1) (u : RÀ£) (v : Ray R M) : u ‚Ä¢ v = v := by"
  },
  {
    "full_name": "Profinite.NobelingProof.projRestricts_eq_id",
    "file_path": "Mathlib/Topology/Category/Profinite/Nobeling.lean",
    "teorema": "theorem Profinite.NobelingProof.projRestricts_eq_id (C : Set (I ‚Üí Bool)) (I : Type u) : ProjRestricts C ‚ãØ = id := by"
  },
  {
    "full_name": "Functor.Comp.map_pure",
    "file_path": "Mathlib/Control/Applicative.lean",
    "teorema": "lemma Functor.Comp.map_pure (f : Œ± ‚Üí Œ≤) (x : Œ±) (Œ± : Type v) (Œ≤ : Type v) : (f <$> pure x).run = (pure (f x)).run := by"
  },
  {
    "full_name": "AlgebraicGeometry.IsClosedImmersion.respectsIso",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/ClosedImmersion.lean",
    "teorema": "theorem AlgebraicGeometry.IsClosedImmersion.respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by"
  },
  {
    "full_name": "List.range'_append",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "lemma List.range'_append (m : Nat) (n : Nat) (s : Nat) (step : Nat) : range' s (m + 1) step ++ range' (s + step * (m + 1)) n step = range' s (n + (m + 1)) step := by"
  },
  {
    "full_name": "LieHom.le_ker_iff",
    "file_path": "Mathlib/Algebra/Lie/Submodule.lean",
    "teorema": "lemma LieHom.le_ker_iff (I : LieIdeal R L) (L : Type v) (R : Type u) (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') : I ‚â§ f.ker ‚Üî ‚àÄ x ‚àà I, f x = 0 := by"
  },
  {
    "full_name": "ENNReal.rpow_neg_one",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "teorema": "theorem ENNReal.rpow_neg_one (x : ‚Ñù‚â•0‚àû) : x ^ (-1) = x‚Åª¬π := by"
  },
  {
    "full_name": "integrable_mul_cexp_neg_mul_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean",
    "teorema": "theorem integrable_mul_cexp_neg_mul_sq (b : ‚ÑÇ) : Integrable (fun x => ‚Üëx * cexp (-b * ‚Üëx ^ 2)) volume := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_edist_lt_top",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "lemma MeasureTheory.lintegral_edist_lt_top (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) : ‚à´‚Åª (a : Œ±), edist (f a) (0 a) ‚àÇŒº < ‚ä§ ‚àß ‚à´‚Åª (a : Œ±), edist (g a) (0 a) ‚àÇŒº < ‚ä§ := by"
  },
  {
    "full_name": "Commute.div_add_div",
    "file_path": "Mathlib/Algebra/Field/Basic.lean",
    "teorema": "lemma Commute.div_add_div (a : Œ±) (b : Œ±) (c : Œ±) (d : Œ±) (Œ± : Type u_1) : a / b + c / d = (a * d + b * c) / (b * d) := by"
  },
  {
    "full_name": "List.self_eq_append_right",
    "file_path": "Mathlib/Data/List/Basic.lean",
    "teorema": "lemma List.self_eq_append_right (x : List Œ±) (y : List Œ±) (Œ± : Type u) : x = x ++ y ‚Üî y = [] := by"
  },
  {
    "full_name": "MonoidHom.restrict_mrange",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Operations.lean",
    "teorema": "lemma MonoidHom.restrict_mrange (M : Type u_1) (N : Type u_2) (S : Submonoid M) (f : M ‚Üí* N) : mrange (f.restrict S) = map f S := by"
  },
  {
    "full_name": "Complex.I_mul_re",
    "file_path": "Mathlib/Data/Complex/Basic.lean",
    "teorema": "theorem Complex.I_mul_re (z : ‚ÑÇ) : (I * z).re = -z.im := by"
  },
  {
    "full_name": "TensorProduct.finsuppRight_symm_apply_single",
    "file_path": "Mathlib/LinearAlgebra/DirectSum/Finsupp.lean",
    "teorema": "lemma TensorProduct.finsuppRight_symm_apply_single (M : Type u_2) (N : Type u_3) (R : Type u_1) (i : Œπ) (m : M) (n : N) (Œπ : Type u_4) : (finsuppRight R M N Œπ).symm (Finsupp.single i (m ‚äó‚Çú[R] n)) = m ‚äó‚Çú[R] Finsupp.single i n := by"
  },
  {
    "full_name": "CategoryTheory.NormalEpiCategory.mono_of_zero_kernel",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/NormalMono/Equalizers.lean",
    "teorema": "theorem CategoryTheory.NormalEpiCategory.mono_of_zero_kernel (C : Type u_1) (X : C) (Y : C) (f : X ‚ü∂ Y) : 0 ‚â´ f = 0 := by"
  },
  {
    "full_name": "left_le_lineMap_iff_le",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Ordered.lean",
    "teorema": "lemma left_le_lineMap_iff_le (E : Type u_2) (a : E) (b : E) (k : Type u_1) (r : k) : a ‚â§ (lineMap a b) r ‚Üî (lineMap a b) 0 ‚â§ (lineMap a b) r := by"
  },
  {
    "full_name": "irrational_sqrt_natCast_iff",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "lemma irrational_sqrt_natCast_iff (n : ‚Ñï) : Irrational ‚àö‚Üën ‚Üî ¬¨IsSquare n := by"
  },
  {
    "full_name": "zpow_induction_right",
    "file_path": "Mathlib/Algebra/Group/Basic.lean",
    "teorema": "theorem zpow_induction_right (G : Type u_3) (P : G ‚Üí Prop) (g : G) (n : ‚Ñ§) : P (g ^ n) := by"
  },
  {
    "full_name": "Bimod.whisker_assoc_bimod",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Bimod.lean",
    "teorema": "lemma Bimod.whisker_assoc_bimod (C : Type u‚ÇÅ) (M : Bimod W X) (N : Bimod X Y) (P : Bimod Y Z) (W : Mon_ C) (X : Mon_ C) (Y : Mon_ C) (Z : Mon_ C) (f : N ‚ü∂ N') : whiskerRight (M.whiskerLeft f) P = (M.associatorBimod N P).hom ‚â´ M.whiskerLeft (whiskerRight f P) ‚â´ (M.associatorBimod N' P).inv := by"
  },
  {
    "full_name": "Ordnode.Valid'.node4L_lemma‚ÇÇ",
    "file_path": "Mathlib/Data/Ordmap/Ordset.lean",
    "teorema": "theorem Ordnode.Valid'.node4L_lemma‚ÇÇ (c : ‚Ñï) (d : ‚Ñï) : c ‚â§ 3 * d := by"
  },
  {
    "full_name": "List.isSubperm_iff",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "teorema": "lemma List.isSubperm_iff (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (Œ± : Type u_1) : l‚ÇÅ.isSubperm l‚ÇÇ = true ‚Üî l‚ÇÅ <+~ l‚ÇÇ := by"
  },
  {
    "full_name": "gold_sub_goldConj",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "teorema": "lemma gold_sub_goldConj : œÜ - œà = ‚àö5 := by"
  },
  {
    "full_name": "Polynomial.lifts_iff_ringHom_rangeS",
    "file_path": "Mathlib/Algebra/Polynomial/Lifts.lean",
    "teorema": "theorem Polynomial.lifts_iff_ringHom_rangeS (R : Type u) (S : Type v) (f : R ‚Üí+* S) (p : S[X]) : p ‚àà lifts f ‚Üî p ‚àà (mapRingHom f).rangeS := by"
  },
  {
    "full_name": "FirstOrder.Ring.realize_zero",
    "file_path": "Mathlib/ModelTheory/Algebra/Ring/Basic.lean",
    "teorema": "theorem FirstOrder.Ring.realize_zero (R : Type u_2) (v : Œ± ‚Üí R) (Œ± : Type u_1) : Term.realize v 0 = 0 := by"
  },
  {
    "full_name": "Real.cos_eq_sqrt_one_sub_sin_sq",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
    "teorema": "lemma Real.cos_eq_sqrt_one_sub_sin_sq (x : ‚Ñù) : cos x = ‚àö(1 - sin x ^ 2) := by"
  },
  {
    "full_name": "ContinuousMultilinearMap.toMultilinearMap_injective",
    "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean",
    "teorema": "lemma ContinuousMultilinearMap.toMultilinearMap_injective (M‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ) (M‚ÇÇ : Type w‚ÇÇ) (R : Type u) (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) (g : MultilinearMap R M‚ÇÅ M‚ÇÇ) (hf : Continuous f.toFun) (hg : Continuous g.toFun) (Œπ : Type v) : { toMultilinearMap := f, cont := hf } = { toMultilinearMap := g, cont := hg } := by"
  },
  {
    "full_name": "EsakiaHom.cancel_left",
    "file_path": "Mathlib/Topology/Order/Hom/Esakia.lean",
    "teorema": "theorem EsakiaHom.cancel_left (a : Œ±) (f‚ÇÅ : EsakiaHom Œ± Œ≤) (f‚ÇÇ : EsakiaHom Œ± Œ≤) (g : EsakiaHom Œ≤ Œ≥) (Œ± : Type u_2) (Œ≤ : Type u_3) (Œ≥ : Type u_4) : g (f‚ÇÅ a) = g (f‚ÇÇ a) := by"
  },
  {
    "full_name": "Multiset.rel_of_forall",
    "file_path": "Mathlib/Data/Multiset/Basic.lean",
    "teorema": "lemma Multiset.rel_of_forall (m1 : Multiset Œ±) (m2 : Multiset Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : Rel r m1 m2 := by"
  },
  {
    "full_name": "MeasureTheory.Measure.QuasiMeasurePreserving.liminf_preimage_iterate_ae_eq",
    "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
    "teorema": "lemma MeasureTheory.Measure.QuasiMeasurePreserving.liminf_preimage_iterate_ae_eq (f : Œ± ‚Üí Œ±) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : liminf (fun n => (preimage f)^[n] s) atTop =·µê[Œº] s := by"
  },
  {
    "full_name": "CategoryTheory.GradedObject.mapBifunctorRightUnitor_inv_naturality",
    "file_path": "Mathlib/CategoryTheory/GradedObject/Unitor.lean",
    "teorema": "theorem CategoryTheory.GradedObject.mapBifunctorRightUnitor_inv_naturality (C : Type u_1) (D : Type u_2) (F : D ‚•§ C ‚•§ D) (I : Type u_3) (J : Type u_4) (X : GradedObject J D) (Y : C) (e : F.flip.obj Y ‚âÖ ùü≠ D) (hp : ‚àÄ (j : J), p (j, 0) = j) (p : J √ó I ‚Üí J) (œÜ : X ‚ü∂ X') : œÜ ‚â´ (mapBifunctorRightUnitor F Y e p hp X').inv = (mapBifunctorRightUnitor F Y e p hp X).inv ‚â´ mapBifunctorMapMap F p œÜ (ùüô ((single‚ÇÄ I).obj Y)) := by"
  },
  {
    "full_name": "ENNReal.Tendsto.const_mul",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "lemma ENNReal.Tendsto.const_mul (a : ‚Ñù‚â•0‚àû) (b : ‚Ñù‚â•0‚àû) (f : Filter Œ±) (m : Œ± ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) : Tendsto (fun b => a * m b) f (ùìù (a * b)) := by"
  },
  {
    "full_name": "Complex.contDiff_exp",
    "file_path": "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean",
    "teorema": "lemma Complex.contDiff_exp (ùïú : Type u_1) : ‚àÄ {n : ‚Ñï‚àû}, ContDiff ùïú n cexp := by"
  },
  {
    "full_name": "Polynomial.sum_fin",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "lemma Polynomial.sum_fin (R : Type u) (S : Type v) (f : ‚Ñï ‚Üí R ‚Üí S) (n : ‚Ñï) (p : R[X]) : ‚àë i : Fin n, f (‚Üëi) (p.coeff ‚Üëi) = p.sum f := by"
  },
  {
    "full_name": "Finset.orderEmbOfCardLe_mem",
    "file_path": "Mathlib/Data/Finset/Sort.lean",
    "teorema": "lemma Finset.orderEmbOfCardLe_mem (a : Fin k) (h : k ‚â§ s.card) (k : ‚Ñï) (s : Finset Œ±) (Œ± : Type u_1) : (s.orderEmbOfCardLe h) a ‚àà s := by"
  },
  {
    "full_name": "Polynomial.rootSet_maps_to'",
    "file_path": "Mathlib/Algebra/Polynomial/Roots.lean",
    "teorema": "lemma Polynomial.rootSet_maps_to' (S : Type u_1) (T : Type w) (f : S ‚Üí‚Çê[T] S') (p : T[X]) (x : S) : f x ‚àà p.rootSet S' := by"
  },
  {
    "full_name": "one_div_lt_one_div_of_neg_of_lt",
    "file_path": "Mathlib/Algebra/Order/Field/Basic.lean",
    "teorema": "lemma one_div_lt_one_div_of_neg_of_lt (a : Œ±) (b : Œ±) (Œ± : Type u_2) : 1 / b < 1 / a := by"
  },
  {
    "full_name": "CategoryTheory.Sieve.functor_galoisConnection",
    "file_path": "Mathlib/CategoryTheory/Sites/Sieves.lean",
    "teorema": "lemma CategoryTheory.Sieve.functor_galoisConnection (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (F : C ‚•§ D) : GaloisConnection (functorPushforward F) (functorPullback F) := by"
  },
  {
    "full_name": "CategoryTheory.Cat.rightUnitor_inv_app",
    "file_path": "Mathlib/CategoryTheory/Category/Cat.lean",
    "teorema": "theorem CategoryTheory.Cat.rightUnitor_inv_app (B : Cat) (C : Cat) (F : B ‚ü∂ C) (X : ‚ÜëB) : F.obj X = (F ‚â´ ùüô C).obj X := by"
  },
  {
    "full_name": "Convex.mem_extremePoints_iff_mem_diff_convexHull_diff",
    "file_path": "Mathlib/Analysis/Convex/Extreme.lean",
    "teorema": "theorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (A : Set E) (E : Type u_2) (x : E) (ùïú : Type u_1) : x ‚àà extremePoints ùïú A ‚Üî x ‚àà A \\ (convexHull ùïú) (A \\ {x}) := by"
  },
  {
    "full_name": "Nat.eq_prod_primes_mul_sq_of_mem_smoothNumbers",
    "file_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
    "teorema": "lemma Nat.eq_prod_primes_mul_sq_of_mem_smoothNumbers (k : ‚Ñï) (n : ‚Ñï) : ‚àÉ s ‚àà k.primesBelow.powerset, ‚àÉ m, n = m ^ 2 * s.prod id := by"
  },
  {
    "full_name": "Fintype.isPrimePow_card_of_field",
    "file_path": "Mathlib/FieldTheory/Cardinality.lean",
    "teorema": "theorem Fintype.isPrimePow_card_of_field (Œ± : Type u_1) : IsPrimePow ‚ÄñŒ±‚Äñ := by"
  },
  {
    "full_name": "TopologicalSpace.secondCountableTopology_induced",
    "file_path": "Mathlib/Topology/Bases.lean",
    "teorema": "theorem TopologicalSpace.secondCountableTopology_induced (Œ± : Type u) : SecondCountableTopology Œ± := by"
  },
  {
    "full_name": "HomologicalComplex.homologyŒπ_singleObjOpcyclesSelfIso_inv",
    "file_path": "Mathlib/Algebra/Homology/SingleHomology.lean",
    "teorema": "theorem HomologicalComplex.homologyŒπ_singleObjOpcyclesSelfIso_inv (A : C) (C : Type u) (c : ComplexShape Œπ) (j : Œπ) (Œπ : Type u_1) : ((single C c j).obj A).homologyŒπ j ‚â´ (singleObjOpcyclesSelfIso c j A).inv = (singleObjHomologySelfIso c j A).hom := by"
  },
  {
    "full_name": "CategoryTheory.Adjunction.Localization.Œ∑_app",
    "file_path": "Mathlib/CategoryTheory/Localization/Adjunction.lean",
    "teorema": "lemma CategoryTheory.Adjunction.Localization.Œ∑_app (C‚ÇÅ : Type u_1) (C‚ÇÇ : Type u_2) (D‚ÇÅ : Type u_3) (D‚ÇÇ : Type u_4) (F : C‚ÇÇ ‚•§ C‚ÇÅ) (G : C‚ÇÅ ‚•§ C‚ÇÇ) (L‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (L‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (W‚ÇÇ : MorphismProperty C‚ÇÇ) (X‚ÇÇ : C‚ÇÇ) (adj : G ‚ä£ F) : (Œ∑ adj L‚ÇÅ L‚ÇÇ W‚ÇÇ G' F').app (L‚ÇÇ.obj X‚ÇÇ) = G'.map ((CatCommSq.iso F L‚ÇÇ L‚ÇÅ F').inv.app X‚ÇÇ) ‚â´ (CatCommSq.iso G L‚ÇÅ L‚ÇÇ G').inv.app (F.obj X‚ÇÇ) ‚â´ L‚ÇÇ.map (adj.counit.app X‚ÇÇ) := by"
  },
  {
    "full_name": "pathComponent_subset_component",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "teorema": "lemma pathComponent_subset_component (X : Type u_1) (h : y ‚àà pathComponent x) (x : X) (y : X) : (Joined.somePath h) 0 = x := by"
  },
  {
    "full_name": "Module.Finite.of_localizationSpan_finite'",
    "file_path": "Mathlib/RingTheory/Localization/Finiteness.lean",
    "teorema": "lemma Module.Finite.of_localizationSpan_finite' (M : Type w) (R : Type u) : Finite R M := by"
  },
  {
    "full_name": "Int.negOnePow_eq_neg_one_iff",
    "file_path": "Mathlib/Algebra/Ring/NegOnePow.lean",
    "teorema": "lemma Int.negOnePow_eq_neg_one_iff (n : ‚Ñ§) : n.negOnePow = -1 ‚Üî Odd n := by"
  },
  {
    "full_name": "Rat.normalize_eq_mkRat",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "teorema": "lemma Rat.normalize_eq_mkRat (den : Nat) (den_nz : den ‚â† 0) (num : Int) : normalize num den den_nz = mkRat num den := by"
  },
  {
    "full_name": "Finsupp.support_indicator_subset",
    "file_path": "Mathlib/Data/Finsupp/Indicator.lean",
    "teorema": "theorem Finsupp.support_indicator_subset (f : (i : Œπ) ‚Üí i ‚àà s ‚Üí Œ±) (i : Œπ) (s : Finset Œπ) (Œ± : Type u_2) (Œπ : Type u_1) : ‚Üë(indicator s f).support ‚äÜ ‚Üës := by"
  },
  {
    "full_name": "IsSelfAdjoint.mem_spectrum_eq_re",
    "file_path": "Mathlib/Analysis/NormedSpace/Star/Spectrum.lean",
    "teorema": "lemma IsSelfAdjoint.mem_spectrum_eq_re (z : ‚ÑÇ) : z = ‚Üëz.re := by"
  },
  {
    "full_name": "CategoryTheory.Limits.biproduct.lift_desc",
    "file_path": "Mathlib/CategoryTheory/Preadditive/Biproducts.lean",
    "teorema": "lemma CategoryTheory.Limits.biproduct.lift_desc (C : Type u) (J : Type) (T : C) (U : C) (f : J ‚Üí C) (g : (j : J) ‚Üí T ‚ü∂ f j) (h : (j : J) ‚Üí f j ‚ü∂ U) : lift g ‚â´ desc h = ‚àë j : J, g j ‚â´ h j := by"
  },
  {
    "full_name": "CliffordAlgebra.evenOdd_mul_le",
    "file_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Grading.lean",
    "teorema": "lemma CliffordAlgebra.evenOdd_mul_le (M : Type u_2) (Q : QuadraticForm R M) (R : Type u_1) (i : ZMod 2) (j : ZMod 2) : evenOdd Q i * evenOdd Q j ‚â§ evenOdd Q (i + j) := by"
  },
  {
    "full_name": "Polynomial.content_X_mul",
    "file_path": "Mathlib/RingTheory/Polynomial/Content.lean",
    "teorema": "theorem Polynomial.content_X_mul (R : Type u_1) (p : R[X]) : (X * p).content = p.content := by"
  },
  {
    "full_name": "PadicSeq.norm_zero_iff",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNumbers.lean",
    "teorema": "lemma PadicSeq.norm_zero_iff (f : PadicSeq p) (p : ‚Ñï) : f.norm = 0 ‚Üî f ‚âà 0 := by"
  },
  {
    "full_name": "Finset.piecewise_univ",
    "file_path": "Mathlib/Data/Finset/Piecewise.lean",
    "teorema": "lemma Finset.piecewise_univ (f : (i : Œπ) ‚Üí œÄ i) (g : (i : Œπ) ‚Üí œÄ i) (Œπ : Type u_1) (œÄ : Œπ ‚Üí Sort u_2) : univ.piecewise f g = f := by"
  },
  {
    "full_name": "MeasureTheory.integrable_inv_smul_measure",
    "file_path": "Mathlib/MeasureTheory/Function/L1Space.lean",
    "teorema": "theorem MeasureTheory.integrable_inv_smul_measure (c : ‚Ñù‚â•0‚àû) : c‚Åª¬π ‚â† 0 := by"
  },
  {
    "full_name": "sub_pow_expChar_pow",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "teorema": "lemma sub_pow_expChar_pow (R : Type u) (n : ‚Ñï) (q : ‚Ñï) (x : R) (y : R) : (x - y) ^ q ^ n = x ^ q ^ n - y ^ q ^ n := by"
  },
  {
    "full_name": "tsub_tsub_eq_min",
    "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
    "teorema": "theorem tsub_tsub_eq_min (a : Œ±) (b : Œ±) (Œ± : Type u_1) : a - (a - b) = min a b := by"
  },
  {
    "full_name": "LinearMap.surjective_of_injective",
    "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean",
    "teorema": "lemma LinearMap.surjective_of_injective (K : Type u) (V : Type v) (f : V ‚Üí‚Çó[K] V) : Surjective ‚áëf := by"
  },
  {
    "full_name": "Finset.le_card_of_inj_on_range",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "lemma Finset.le_card_of_inj_on_range (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) (s : Finset Œ±) (Œ± : Type u_1) : ‚àÄ a ‚àà range n, f a ‚àà s := by"
  },
  {
    "full_name": "padicNorm.int_eq_one_iff",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
    "teorema": "theorem padicNorm.int_eq_one_iff (m : ‚Ñ§) (p : ‚Ñï) : padicNorm p ‚Üëm = 1 ‚Üî ¬¨‚Üëp ‚à£ m := by"
  },
  {
    "full_name": "List.rtake_nil",
    "file_path": "Mathlib/Data/List/DropRight.lean",
    "teorema": "lemma List.rtake_nil (n : ‚Ñï) : [].rtake n = [] := by"
  },
  {
    "full_name": "Submodule.mem_smul_top_iff",
    "file_path": "Mathlib/RingTheory/Ideal/Operations.lean",
    "teorema": "theorem Submodule.mem_smul_top_iff (I : Ideal R) (M : Type v) (N : Submodule R M) (R : Type u) (x : ‚Ü•N) : x ‚àà I ‚Ä¢ ‚ä§ ‚Üî ‚Üëx ‚àà I ‚Ä¢ N := by"
  },
  {
    "full_name": "lowerSemicontinuousWithinAt_iff_le_liminf",
    "file_path": "Mathlib/Topology/Semicontinuous.lean",
    "teorema": "lemma lowerSemicontinuousWithinAt_iff_le_liminf (f : Œ± ‚Üí Œ≥) (s : Set Œ±) (x : Œ±) (Œ± : Type u_1) (Œ≥ : Type u_3) : LowerSemicontinuousWithinAt f s x ‚Üî f x ‚â§ liminf f (ùìù[s] x) := by"
  },
  {
    "full_name": "Finset.filter_and_not",
    "file_path": "Mathlib/Data/Finset/Basic.lean",
    "teorema": "lemma Finset.filter_and_not (p : Œ± ‚Üí Prop) (q : Œ± ‚Üí Prop) (s : Finset Œ±) (Œ± : Type u_1) : filter (fun a => p a ‚àß ¬¨q a) s = filter p s \\ filter q s := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.withDensity_sub_add_cancel",
    "file_path": "Mathlib/Probability/Kernel/WithDensity.lean",
    "teorema": "theorem ProbabilityTheory.kernel.withDensity_sub_add_cancel (f : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (g : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ∫ : ‚Ü•(kernel Œ± Œ≤)) : (withDensity Œ∫ fun a x => f a x - g a x) + withDensity Œ∫ g = withDensity Œ∫ f := by"
  },
  {
    "full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLift_p1",
    "file_path": "Mathlib/AlgebraicGeometry/Pullbacks.lean",
    "teorema": "theorem AlgebraicGeometry.Scheme.Pullback.gluedLift_p1 (X : Scheme) (Y : Scheme) (Z : Scheme) (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (s : PullbackCone f g) (ùí∞ : X.OpenCover) : gluedLift ùí∞ f g s ‚â´ p1 ùí∞ f g = s.fst := by"
  },
  {
    "full_name": "Mathlib.Tactic.Ring.neg_zero",
    "file_path": "Mathlib/Tactic/Ring/Basic.lean",
    "teorema": "theorem Mathlib.Tactic.Ring.neg_zero : -0 = 0 := by"
  },
  {
    "full_name": "Relation.transGen_eq_self",
    "file_path": "Mathlib/Logic/Relation.lean",
    "teorema": "theorem Relation.transGen_eq_self (a : Œ±) (b : Œ±) (r : Œ± ‚Üí Œ± ‚Üí Prop) (Œ± : Type u_1) : r a b := by"
  },
  {
    "full_name": "Nat.factorization_lt",
    "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
    "teorema": "theorem Nat.factorization_lt (n : ‚Ñï) (p : ‚Ñï) : n.factorization p < n := by"
  },
  {
    "full_name": "Cardinal.ofENat_mul_aleph0",
    "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean",
    "teorema": "lemma Cardinal.ofENat_mul_aleph0 (m : ‚Ñï‚àû) : ‚Üëm * ‚Ñµ‚ÇÄ = ‚Ñµ‚ÇÄ := by"
  },
  {
    "full_name": "Hyperreal.st_eq_sSup",
    "file_path": "Mathlib/Data/Real/Hyperreal.lean",
    "teorema": "theorem Hyperreal.st_eq_sSup (x : ‚Ñù*) : x.st = sSup {y | ‚Üëy < x} := by"
  },
  {
    "full_name": "one_le_of_le_mul_left",
    "file_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
    "teorema": "lemma one_le_of_le_mul_left (a : Œ±) (Œ± : Type u_1) : 1 * ?m.21939 ‚â§ a * ?m.21939 := by"
  },
  {
    "full_name": "Complex.re_neg_ne_zero_of_one_lt_re",
    "file_path": "Mathlib/Data/Complex/Abs.lean",
    "teorema": "theorem Complex.re_neg_ne_zero_of_one_lt_re (s : ‚ÑÇ) : -s.re < 0 := by"
  },
  {
    "full_name": "Irrational.of_int_mul",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "teorema": "lemma Irrational.of_int_mul (m : ‚Ñ§) (x : ‚Ñù) : Irrational (‚Üë‚Üëm * x) := by"
  },
  {
    "full_name": "MeasureTheory.integral_comp_smul_deriv_Ioi",
    "file_path": "Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean",
    "teorema": "lemma MeasureTheory.integral_comp_smul_deriv_Ioi (E : Type u_1) (a : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí E) : ‚à´ (x : ‚Ñù) in Ioi a, f' x ‚Ä¢ (g ‚àò f) x = ‚à´ (u : ‚Ñù) in Ioi (f a), g u := by"
  },
  {
    "full_name": "Matrix.vec2_eq",
    "file_path": "Mathlib/Data/Matrix/Notation.lean",
    "teorema": "theorem Matrix.vec2_eq (a‚ÇÄ : Œ±) (a‚ÇÅ : Œ±) (b‚ÇÄ : Œ±) (b‚ÇÅ : Œ±) (Œ± : Type u) : ![a‚ÇÄ, a‚ÇÅ] = ![b‚ÇÄ, b‚ÇÅ] := by"
  },
  {
    "full_name": "List.range'_eq_nil",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "teorema": "lemma List.range'_eq_nil (n : Nat) (s : Nat) (step : Nat) : range' s n step = [] ‚Üî n = 0 := by"
  },
  {
    "full_name": "Nat.even_add'",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "teorema": "lemma Nat.even_add' (m : ‚Ñï) (n : ‚Ñï) : Even (m + n) ‚Üî (Odd m ‚Üî Odd n) := by"
  },
  {
    "full_name": "CategoryTheory.Iso.trans_conjAut",
    "file_path": "Mathlib/CategoryTheory/Conj.lean",
    "teorema": "theorem CategoryTheory.Iso.trans_conjAut (C : Type u) (X : C) (Y : C) (Z : C) (f : Aut X) (Œ± : X ‚âÖ Y) (Œ≤ : Y ‚âÖ Z) : (Œ± ‚â™‚â´ Œ≤).conjAut f = Œ≤.conjAut (Œ±.conjAut f) := by"
  },
  {
    "full_name": "Complex.not_le_iff",
    "file_path": "Mathlib/Data/Complex/Order.lean",
    "teorema": "theorem Complex.not_le_iff (w : ‚ÑÇ) (z : ‚ÑÇ) : ¬¨z ‚â§ w ‚Üî w.re < z.re ‚à® z.im ‚â† w.im := by"
  },
  {
    "full_name": "LinearMap.nilRank_le_card",
    "file_path": "Mathlib/Algebra/Module/LinearMap/Polynomial.lean",
    "teorema": "theorem LinearMap.nilRank_le_card (L : Type u_2) (M : Type u_3) (R : Type u_1) (Œπ : Type u_5) (œÜ : L ‚Üí‚Çó[R] Module.End R M) : œÜ.nilRank ‚â§ Fintype.card Œπ := by"
  },
  {
    "full_name": "MeasureTheory.setLIntegral_tilted'",
    "file_path": "Mathlib/MeasureTheory/Measure/Tilted.lean",
    "teorema": "theorem MeasureTheory.setLIntegral_tilted' (f : Œ± ‚Üí ‚Ñù) (g : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Set Œ±) (Œ± : Type u_1) (Œº : Measure Œ±) : ‚à´‚Åª (x : Œ±) in s, g x ‚àÇŒº.tilted f = ‚à´‚Åª (x : Œ±) in s, ENNReal.ofReal (rexp (f x) / ‚à´ (x : Œ±), rexp (f x) ‚àÇŒº) * g x ‚àÇŒº := by"
  },
  {
    "full_name": "NumberField.Units.dirichletUnitTheorem.exists_unit",
    "file_path": "Mathlib/NumberTheory/NumberField/Units/DirichletTheorem.lean",
    "teorema": "theorem NumberField.Units.dirichletUnitTheorem.exists_unit (K : Type u_1) (w‚ÇÅ : InfinitePlace K) : ‚àÉ u, ‚àÄ (w : InfinitePlace K), w ‚â† w‚ÇÅ ‚Üí Real.log (w ((algebraMap (ùìû K) K) ‚Üëu)) < 0 := by"
  },
  {
    "full_name": "CategoryTheory.BraidedCategory.hexagon_forward_inv",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Braided/Basic.lean",
    "teorema": "theorem CategoryTheory.BraidedCategory.hexagon_forward_inv (C : Type u) (X : C) (Y : C) (Z : C) : (Œ±_ Y Z X).inv ‚â´ (Œ≤_ X (Y ‚äó Z)).inv ‚â´ (Œ±_ X Y Z).inv = Y ‚óÅ (Œ≤_ X Z).inv ‚â´ (Œ±_ Y X Z).inv ‚â´ (Œ≤_ X Y).inv ‚ñ∑ Z := by"
  },
  {
    "full_name": "ProbabilityTheory.absolutelyContinuous_cond_univ",
    "file_path": "Mathlib/Probability/ConditionalProbability.lean",
    "teorema": "theorem ProbabilityTheory.absolutelyContinuous_cond_univ (Œ© : Type u_1) (Œº : Measure Œ©) : Œº ‚â™ Œº[|univ] := by"
  },
  {
    "full_name": "multiplicity.le_multiplicity_map",
    "file_path": "Mathlib/RingTheory/Multiplicity.lean",
    "teorema": "lemma multiplicity.le_multiplicity_map (F : Type u_3) (a : Œ±) (b : Œ±) (f : F) (n : ‚Ñï) (Œ± : Type u_1) : a ^ n ‚à£ b ‚Üí f a ^ n ‚à£ f b := by"
  },
  {
    "full_name": "IsClosedMap.of_nonempty",
    "file_path": "Mathlib/Topology/Maps.lean",
    "teorema": "theorem IsClosedMap.of_nonempty (X : Type u_1) (Y : Type u_2) (f : X ‚Üí Y) : IsClosedMap f := by"
  },
  {
    "full_name": "TypeVec.dropFun_prod",
    "file_path": "Mathlib/Data/TypeVec.lean",
    "teorema": "lemma TypeVec.dropFun_prod (f : Œ± ‚üπ Œ≤) (n : ‚Ñï) (Œ± : TypeVec.{u_1} (n + 1)) (Œ≤ : TypeVec.{u_1} (n + 1)) : dropFun (f ‚äó' f') = (dropFun f ‚äó' dropFun f') := by"
  },
  {
    "full_name": "ContDiff.div_const",
    "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean",
    "teorema": "theorem ContDiff.div_const (E : Type uE) (c : ùïú') (f : E ‚Üí ùïú') (n : ‚Ñï‚àû) (x : E) (ùïú : Type u_1) : ContDiff ùïú n fun x => f x / c := by"
  },
  {
    "full_name": "AffineMap.image_vsub_image",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean",
    "teorema": "theorem AffineMap.image_vsub_image (P1 : Type u_3) (P2 : Type u_5) (f : P1 ‚Üí·µÉ[k] P2) (k : Type u_1) (s : Set P1) (t : Set P1) : ‚áëf '' s -·µ• ‚áëf '' t = ‚áëf.linear '' (s -·µ• t) := by"
  },
  {
    "full_name": "Real.log_of_pos",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "teorema": "lemma Real.log_of_pos (hx : 0 < x) (x : ‚Ñù) : log x = expOrderIso.symm ‚ü®x, hx‚ü© := by"
  },
  {
    "full_name": "ENNReal.pow_eq_top_iff",
    "file_path": "Mathlib/Data/ENNReal/Operations.lean",
    "teorema": "theorem ENNReal.pow_eq_top_iff (a : ‚Ñù‚â•0‚àû) (n : ‚Ñï) : a ^ n = ‚ä§ ‚Üî a = ‚ä§ ‚àß n ‚â† 0 := by"
  },
  {
    "full_name": "Path.Homotopy.transReflReparamAux_zero",
    "file_path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean",
    "teorema": "theorem Path.Homotopy.transReflReparamAux_zero : transReflReparamAux 0 = 0 := by"
  },
  {
    "full_name": "List.rotate_eq_iff",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "teorema": "lemma List.rotate_eq_iff (l : List Œ±) (n : ‚Ñï) (Œ± : Type u) : l.rotate n = l' ‚Üî l = l'.rotate (l'.length - n % l'.length) := by"
  },
  {
    "full_name": "Function.Injective.mem_finset_image",
    "file_path": "Mathlib/Data/Finset/Image.lean",
    "teorema": "lemma Function.Injective.mem_finset_image (a : Œ±) (f : Œ± ‚Üí Œ≤) (s : Finset Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : f a ‚àà image f s ‚Üî a ‚àà s := by"
  },
  {
    "full_name": "ENNReal.iSup_zero_eq_zero",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "teorema": "lemma ENNReal.iSup_zero_eq_zero : ‚®Ü x, 0 = 0 := by"
  },
  {
    "full_name": "Matrix.vec2_add",
    "file_path": "Mathlib/Data/Matrix/Notation.lean",
    "teorema": "theorem Matrix.vec2_add (a‚ÇÄ : Œ±) (a‚ÇÅ : Œ±) (b‚ÇÄ : Œ±) (b‚ÇÅ : Œ±) (Œ± : Type u) : ![a‚ÇÄ, a‚ÇÅ] + ![b‚ÇÄ, b‚ÇÅ] = ![a‚ÇÄ + b‚ÇÄ, a‚ÇÅ + b‚ÇÅ] := by"
  },
  {
    "full_name": "Fintype.card_range_le",
    "file_path": "Mathlib/Data/Fintype/Card.lean",
    "teorema": "lemma Fintype.card_range_le (a : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_4) (Œ≤ : Type u_5) : f a ‚àà Set.range f := by"
  },
  {
    "full_name": "nilpotent_iff_lowerCentralSeries",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "teorema": "theorem nilpotent_iff_lowerCentralSeries (G : Type u_1) : Group.IsNilpotent G ‚Üî ‚àÉ n, lowerCentralSeries G n = ‚ä• := by"
  },
  {
    "full_name": "IsCompactlyGenerated.BooleanGenerators.mem_of_isAtom_of_le_sSup_atoms",
    "file_path": "Mathlib/Order/BooleanGenerators.lean",
    "teorema": "theorem IsCompactlyGenerated.BooleanGenerators.mem_of_isAtom_of_le_sSup_atoms (S : Set Œ±) (a : Œ±) (Œ± : Type u_1) : a ‚àà S := by"
  },
  {
    "full_name": "smul_sphere",
    "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean",
    "teorema": "theorem smul_sphere (E : Type u_2) (c : ùïú) (r : ‚Ñù) (x : E) (ùïú : Type u_1) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) (‚Äñc‚Äñ * r) := by"
  },
  {
    "full_name": "CategoryTheory.Idempotents.Karoubi.id_eq",
    "file_path": "Mathlib/CategoryTheory/Idempotents/Karoubi.lean",
    "teorema": "lemma CategoryTheory.Idempotents.Karoubi.id_eq (C : Type u_1) (P : Karoubi C) : P.p = P.p ‚â´ P.p ‚â´ P.p := by"
  },
  {
    "full_name": "PowerSeries.order_add_of_order_eq",
    "file_path": "Mathlib/RingTheory/PowerSeries/Order.lean",
    "teorema": "theorem PowerSeries.order_add_of_order_eq (R : Type u_1) (œÜ : R‚ü¶X‚üß) (œà : R‚ü¶X‚üß) : (œÜ + œà).order = œÜ.order ‚äì œà.order := by"
  },
  {
    "full_name": "Set.image2_iInter‚ÇÇ_subset_right",
    "file_path": "Mathlib/Data/Set/Lattice.lean",
    "teorema": "lemma Set.image2_iInter‚ÇÇ_subset_right (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : Set Œ±) (t : (i : Œπ) ‚Üí Œ∫ i ‚Üí Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œπ : Sort u_4) (Œ∫ : Œπ ‚Üí Sort u_7) : image2 f s (‚ãÇ i, ‚ãÇ j, t i j) ‚äÜ ‚ãÇ i, ‚ãÇ j, image2 f s (t i j) := by"
  },
  {
    "full_name": "Polynomial.le_natDegree_of_ne_zero",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "teorema": "lemma Polynomial.le_natDegree_of_ne_zero (R : Type u) (n : ‚Ñï) (p : R[X]) : n ‚â§ p.natDegree := by"
  },
  {
    "full_name": "Orientation.eq_or_eq_neg",
    "file_path": "Mathlib/LinearAlgebra/Orientation.lean",
    "teorema": "theorem Orientation.eq_or_eq_neg (M : Type u_2) (R : Type u_1) (x‚ÇÅ : Orientation R M Œπ) (x‚ÇÇ : Orientation R M Œπ) (Œπ : Type u_3) : x‚ÇÅ = x‚ÇÇ ‚à® x‚ÇÅ = -x‚ÇÇ := by"
  },
  {
    "full_name": "IsCompact.nhdsSet_prod_eq",
    "file_path": "Mathlib/Topology/Compactness/Compact.lean",
    "teorema": "theorem IsCompact.nhdsSet_prod_eq (X : Type u) (Y : Type v) (s : Set X) (t : Set Y) : ùìùÀ¢ (s √óÀ¢ t) = ùìùÀ¢ s √óÀ¢ ùìùÀ¢ t := by"
  },
  {
    "full_name": "FirstOrder.Language.Substructure.lift_card_closure_le_card_term",
    "file_path": "Mathlib/ModelTheory/Substructures.lean",
    "teorema": "lemma FirstOrder.Language.Substructure.lift_card_closure_le_card_term (L : Language) (M : Type w) (s : Set M) : lift.{max u w, w} #‚Ü•((closure L).toFun s) ‚â§ #(L.Term ‚Üës) := by"
  },
  {
    "full_name": "Set.exists_lt_mem_inter_of_not_pairwiseDisjoint",
    "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean",
    "teorema": "lemma Set.exists_lt_mem_inter_of_not_pairwiseDisjoint (f : Œπ ‚Üí Set Œ±) (s : Set Œπ) (Œ± : Type u_1) (Œπ : Type u_4) : ‚àÉ i ‚àà s, ‚àÉ j ‚àà s, i < j ‚àß ‚àÉ x, x ‚àà f i ‚à© f j := by"
  },
  {
    "full_name": "Set.encard_univ_coe",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "theorem Set.encard_univ_coe (s : Set Œ±) (Œ± : Type u_1) : univ.encard = s.encard := by"
  },
  {
    "full_name": "HomologicalComplex.kernel_eq_kernel",
    "file_path": "Mathlib/Algebra/Homology/HomologicalComplex.lean",
    "teorema": "theorem HomologicalComplex.kernel_eq_kernel (C : HomologicalComplex V c) (V : Type u) (c : ComplexShape Œπ) (i : Œπ) (j : Œπ) (Œπ : Type u_1) : kernelSubobject (C.d i j) = kernelSubobject (C.d i j') := by"
  },
  {
    "full_name": "CategoryTheory.simple_of_isSimpleOrder_subobject",
    "file_path": "Mathlib/CategoryTheory/Simple.lean",
    "teorema": "lemma CategoryTheory.simple_of_isSimpleOrder_subobject (C : Type u) (X : C) : Simple X := by"
  },
  {
    "full_name": "LinearMap.range_coprod",
    "file_path": "Mathlib/LinearAlgebra/Prod.lean",
    "teorema": "lemma LinearMap.range_coprod (M : Type v) (M‚ÇÇ : Type w) (M‚ÇÉ : Type y) (R : Type u) (f : M ‚Üí‚Çó[R] M‚ÇÉ) (g : M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ) (x : M‚ÇÉ) : x ‚àà range (f.coprod g) ‚Üî x ‚àà range f ‚äî range g := by"
  },
  {
    "full_name": "CategoryTheory.IsCodetecting.isCoseparating",
    "file_path": "Mathlib/CategoryTheory/Generator.lean",
    "teorema": "theorem CategoryTheory.IsCodetecting.isCoseparating (C : Type u‚ÇÅ) (ùí¢ : Set C) : IsCodetecting ùí¢ ‚Üí IsCoseparating ùí¢ := by"
  },
  {
    "full_name": "Cardinal.sum_lt_of_isRegular",
    "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean",
    "teorema": "lemma Cardinal.sum_lt_of_isRegular (c : Cardinal.{u}) (Œπ : Type u) : lift.{u, u} #Œπ < c := by"
  },
  {
    "full_name": "TensorPower.mul_one",
    "file_path": "Mathlib/LinearAlgebra/TensorPower.lean",
    "teorema": "theorem TensorPower.mul_one (M : Type u_2) (R : Type u_1) (a : ‚®Ç[R]^n M) (n : ‚Ñï) : (cast R M ‚ãØ) (GradedMonoid.GMul.mul a GradedMonoid.GOne.one) = a := by"
  },
  {
    "full_name": "edist_pi_le_iff",
    "file_path": "Mathlib/Topology/EMetricSpace/Basic.lean",
    "teorema": "theorem edist_pi_le_iff (d : ‚Ñù‚â•0‚àû) (f : (b : Œ≤) ‚Üí œÄ b) (g : (b : Œ≤) ‚Üí œÄ b) (Œ≤ : Type v) (œÄ : Œ≤ ‚Üí Type u_2) : (‚àÄ b ‚àà Finset.univ, edist (f b) (g b) ‚â§ d) ‚Üî ‚àÄ (b : Œ≤), edist (f b) (g b) ‚â§ d := by"
  },
  {
    "full_name": "CategoryTheory.Functor.cofinal_of_isTerminal_colimit_comp_yoneda",
    "file_path": "Mathlib/CategoryTheory/Limits/Final.lean",
    "teorema": "lemma CategoryTheory.Functor.cofinal_of_isTerminal_colimit_comp_yoneda (C : Type v) (D : Type u‚ÇÅ) (F : C ‚•§ D) : F.Final := by"
  },
  {
    "full_name": "CategoryTheory.Presheaf.imageSieve_app",
    "file_path": "Mathlib/CategoryTheory/Sites/LocallySurjective.lean",
    "teorema": "theorem CategoryTheory.Presheaf.imageSieve_app (A : Type u') (C : Type u) (F : C·µí·µñ ‚•§ A) (G : C·µí·µñ ‚•§ A) (U : C) (f : F ‚ü∂ G) (s : (forget A).obj (F.obj { unop := U })) : imageSieve f ((f.app { unop := U }) s) = ‚ä§ := by"
  },
  {
    "full_name": "ContinuousMultilinearMap.range_toUniformOnFun",
    "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Topology.lean",
    "teorema": "lemma ContinuousMultilinearMap.range_toUniformOnFun (ùïú : Type u_1) : range toUniformOnFun = {f | Continuous ((toFun {s | IsVonNBounded ùïú s}) f) ‚àß := by"
  },
  {
    "full_name": "ArithmeticFunction.ppow_zero",
    "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean",
    "teorema": "lemma ArithmeticFunction.ppow_zero (R : Type u_1) (f : ArithmeticFunction R) : f.ppow 0 = ‚ÜëŒ∂ := by"
  },
  {
    "full_name": "WithBot.monotone_map_iff",
    "file_path": "Mathlib/Order/WithBot.lean",
    "teorema": "lemma WithBot.monotone_map_iff (a : Œ±) (f : Œ± ‚Üí Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : ((Monotone fun a => map f ‚Üëa) ‚àß ‚àÄ (x : Œ±), map f ‚ä• ‚â§ map f ‚Üëx) ‚Üî Monotone f := by"
  },
  {
    "full_name": "AddCircle.coe_image_Ioc_eq",
    "file_path": "Mathlib/Topology/Instances/AddCircle.lean",
    "teorema": "lemma AddCircle.coe_image_Ioc_eq (a : ùïú) (p : ùïú) (ùïú : Type u_1) : QuotientAddGroup.mk '' Ioc a (a + p) = univ := by"
  },
  {
    "full_name": "Polynomial.cyclotomic_prime_pow_mul_X_pow_sub_one",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
    "teorema": "theorem Polynomial.cyclotomic_prime_pow_mul_X_pow_sub_one (R : Type u_1) (k : ‚Ñï) (p : ‚Ñï) : cyclotomic (p ^ (k + 1)) R * (X ^ p ^ k - 1) = X ^ p ^ (k + 1) - 1 := by"
  },
  {
    "full_name": "MeasureTheory.SimpleFunc.setToSimpleFunc_nonneg",
    "file_path": "Mathlib/MeasureTheory/Integral/SetToL1.lean",
    "teorema": "lemma MeasureTheory.SimpleFunc.setToSimpleFunc_nonneg (G : Type u_5) (T : Set Œ± ‚Üí G' ‚ÜíL[‚Ñù] G'') (f : Œ± ‚Üí‚Çõ G') (Œ± : Type u_1) : 0 ‚â§ setToSimpleFunc T f := by"
  },
  {
    "full_name": "CategoryTheory.MorphismProperty.map_le_iff",
    "file_path": "Mathlib/CategoryTheory/MorphismProperty/Basic.lean",
    "teorema": "theorem CategoryTheory.MorphismProperty.map_le_iff (C : Type u) (D : Type u_1) (F : C ‚•§ D) (P : MorphismProperty C) (Q : MorphismProperty D) : P.map F ‚â§ Q ‚Üî P ‚â§ Q.inverseImage F := by"
  },
  {
    "full_name": "mul_mul_mul_comm",
    "file_path": "Mathlib/Algebra/Group/Basic.lean",
    "teorema": "lemma mul_mul_mul_comm (G : Type u_3) (a : G) (b : G) (c : G) (d : G) : a * b * (c * d) = a * c * (b * d) := by"
  },
  {
    "full_name": "MeasureTheory.condexp_min_stopping_time_ae_eq_restrict_le",
    "file_path": "Mathlib/Probability/Process/Stopping.lean",
    "teorema": "lemma MeasureTheory.condexp_min_stopping_time_ae_eq_restrict_le (E : Type u_4) (f : Œ© ‚Üí E) (hœÑ : IsStoppingTime ‚Ñ± œÑ) (m : MeasurableSpace Œ©) (Œ© : Type u_1) (Œπ : Type u_3) (Œº : Measure Œ©) (œÉ : Œ© ‚Üí Œπ) (œÑ : Œ© ‚Üí Œπ) (‚Ñ± : Filtration Œπ m) : Œº[f|‚ãØ.measurableSpace] =·∂†[ae (Œº.restrict {x | œÑ x ‚â§ œÉ x})] Œº[f|hœÑ.measurableSpace] := by"
  },
  {
    "full_name": "CategoryTheory.Limits.prod.diag_map",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
    "teorema": "theorem CategoryTheory.Limits.prod.diag_map (C : Type u) (X : C) (Y : C) (f : X ‚ü∂ Y) : diag X ‚â´ map f f = f ‚â´ diag Y := by"
  },
  {
    "full_name": "List.bind_append_perm",
    "file_path": "Mathlib/Data/List/Perm.lean",
    "teorema": "lemma List.bind_append_perm (f : Œ± ‚Üí List Œ≤) (g : Œ± ‚Üí List Œ≤) (l : List Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : l.bind f ++ l.bind g ~ l.bind fun x => f x ++ g x := by"
  },
  {
    "full_name": "LieIdeal.comap_bracket_le",
    "file_path": "Mathlib/Algebra/Lie/IdealOperations.lean",
    "teorema": "theorem LieIdeal.comap_bracket_le (J‚ÇÅ : LieIdeal R L') (J‚ÇÇ : LieIdeal R L') (L : Type v) (R : Type u) (f : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') : ‚ÅÖcomap f J‚ÇÅ, comap f J‚ÇÇ‚ÅÜ ‚â§ comap f ‚ÅÖJ‚ÇÅ, J‚ÇÇ‚ÅÜ := by"
  },
  {
    "full_name": "AList.union_comm_of_disjoint",
    "file_path": "Mathlib/Data/List/AList.lean",
    "teorema": "lemma AList.union_comm_of_disjoint (s‚ÇÅ : AList Œ≤) (s‚ÇÇ : AList Œ≤) (Œ± : Type u) (Œ≤ : Œ± ‚Üí Type v) : ‚àÄ (x : Œ±) (y : Œ≤ x), y ‚àà dlookup x (s‚ÇÅ ‚à™ s‚ÇÇ).entries ‚Üî y ‚àà dlookup x (s‚ÇÇ ‚à™ s‚ÇÅ).entries := by"
  },
  {
    "full_name": "ProbabilityTheory.kernel.integrable_densityProcess",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/Density.lean",
    "teorema": "theorem ProbabilityTheory.kernel.integrable_densityProcess (a : Œ±) (n : ‚Ñï) (s : Set Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œ∫ : ‚Ü•(kernel Œ± (Œ≥ √ó Œ≤))) (ŒΩ : ‚Ü•(kernel Œ± Œ≥)) : Integrable (fun x => densityProcess Œ∫ ŒΩ n a x s) (ŒΩ a) := by"
  },
  {
    "full_name": "WeierstrassCurve.Affine.addPolynomial_slope",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean",
    "teorema": "theorem WeierstrassCurve.Affine.addPolynomial_slope (F : Type u) (W : Affine F) (x‚ÇÅ : F) (x‚ÇÇ : F) (y‚ÇÅ : F) (y‚ÇÇ : F) : W.addPolynomial x‚ÇÅ y‚ÇÅ (W.slope x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ) = -((X - C x‚ÇÅ) * (X - C x‚ÇÇ) * (X - C (W.addX x‚ÇÅ x‚ÇÇ (W.slope x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ)))) := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.negDblY_of_Z_eq_zero",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.negDblY_of_Z_eq_zero (F : Type v) (P : Fin 3 ‚Üí R) (R : Type u) (W : Jacobian F) : W'.negDblY P = -(P x ^ 2) ^ 3 := by"
  },
  {
    "full_name": "Real.Angle.sin_eq_iff_eq_or_add_eq_pi",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "teorema": "lemma Real.Angle.sin_eq_iff_eq_or_add_eq_pi (Œ∏ : Angle) (œà : Angle) : Œ∏.sin = œà.sin ‚Üî Œ∏ = œà ‚à® Œ∏ + œà = ‚ÜëœÄ := by"
  },
  {
    "full_name": "EuclideanGeometry.cospherical_of_two_zsmul_oangle_eq_of_not_collinear",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Sphere.lean",
    "teorema": "theorem EuclideanGeometry.cospherical_of_two_zsmul_oangle_eq_of_not_collinear (P : Type u_2) (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) : Cospherical {p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ} := by"
  },
  {
    "full_name": "Language.map_kstar",
    "file_path": "Mathlib/Computability/Language.lean",
    "teorema": "lemma Language.map_kstar (f : Œ± ‚Üí Œ≤) (l : Language Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : (map f) l‚àó = ((map f) l)‚àó := by"
  },
  {
    "full_name": "List.forall‚ÇÇ_iff_zip",
    "file_path": "Mathlib/Data/List/Forall2.lean",
    "teorema": "lemma List.forall‚ÇÇ_iff_zip (R : Œ± ‚Üí Œ≤ ‚Üí Prop) (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ≤) (Œ± : Type u_1) (Œ≤ : Type u_2) : Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ := by"
  },
  {
    "full_name": "Submodule.map_equiv_eq_comap_symm",
    "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean",
    "teorema": "theorem Submodule.map_equiv_eq_comap_symm (K : Submodule R M) (M : Type u_5) (M‚ÇÇ : Type u_7) (R : Type u_1) (R‚ÇÇ : Type u_3) (e : M ‚âÉ‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ) : x‚úù ‚àà map (‚Üëe) K ‚Üî x‚úù ‚àà comap (‚Üëe.symm) K := by"
  },
  {
    "full_name": "Holor.sum_unitVec_mul_slice",
    "file_path": "Mathlib/Data/Holor.lean",
    "teorema": "theorem Holor.sum_unitVec_mul_slice (d : ‚Ñï) (ds : List ‚Ñï) (x : Holor Œ± (d :: ds)) (Œ± : Type) : ‚àë i ‚àà (Finset.range d).attach, unitVec d ‚Üëi ‚äó x.slice ‚Üëi ‚ãØ = x := by"
  },
  {
    "full_name": "Int.eq_zero_of_abs_lt_dvd",
    "file_path": "Mathlib/Data/Int/Order/Lemmas.lean",
    "teorema": "lemma Int.eq_zero_of_abs_lt_dvd (x : ‚Ñ§) : x = 0 := by"
  },
  {
    "full_name": "FreeMonoid.count_of",
    "file_path": "Mathlib/Algebra/FreeMonoid/Count.lean",
    "teorema": "lemma FreeMonoid.count_of (x : Œ±) (y : Œ±) (Œ± : Type u_1) : (count x) (of y) = Pi.mulSingle x (Multiplicative.ofAdd 1) y := by"
  },
  {
    "full_name": "MeasureTheory.smul_le_stoppedValue_hitting",
    "file_path": "Mathlib/Probability/Martingale/OptionalStopping.lean",
    "teorema": "lemma MeasureTheory.smul_le_stoppedValue_hitting (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (n : ‚Ñï) (Œ© : Type u_1) (Œµ : ‚Ñù‚â•0) (Œº : Measure Œ©) : Œµ ‚Ä¢ Œº {œâ | ‚ÜëŒµ ‚â§ (range (n + 1)).sup' ‚ãØ fun k => f k œâ} ‚â§ ENNReal.ofReal := by"
  },
  {
    "full_name": "Matrix.mul_transvection_apply_same",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Transvection.lean",
    "teorema": "lemma Matrix.mul_transvection_apply_same (M : Matrix n n R) (R : Type u‚ÇÇ) (a : n) (c : R) (i : n) (j : n) (n : Type u_1) : (M * transvection i j c) a j = M a j + c * M a i := by"
  },
  {
    "full_name": "CategoryTheory.BasedFunctor.w_obj",
    "file_path": "Mathlib/CategoryTheory/FiberedCategory/BasedCategory.lean",
    "teorema": "theorem CategoryTheory.BasedFunctor.w_obj (F : ùí≥ ‚•§·µá ùí¥) (a : ùí≥.obj) (ùíÆ : Type u‚ÇÅ) (ùí≥ : BasedCategory ùíÆ) (ùí¥ : BasedCategory ùíÆ) : ùí¥.p.obj (F.obj a) = ùí≥.p.obj a := by"
  },
  {
    "full_name": "Basis.mem_submodule_iff",
    "file_path": "Mathlib/LinearAlgebra/Basis.lean",
    "teorema": "theorem Basis.mem_submodule_iff (M : Type u_6) (P : Submodule R M) (R : Type u_3) (b : Basis Œπ R ‚Ü•P) (c : R) (i : Œπ) (x : M) (Œπ : Type u_1) : x ‚àà P ‚Üî ‚àÉ c, x = c.sum fun i x => x ‚Ä¢ ‚Üë(b i) := by"
  },
  {
    "full_name": "HahnSeries.isPWO_iUnion_support_powers",
    "file_path": "Mathlib/RingTheory/HahnSeries/Summable.lean",
    "teorema": "theorem HahnSeries.isPWO_iUnion_support_powers (R : Type u_2) (x : HahnSeries Œì R) (Œì : Type u_1) : (‚ãÉ n, (x ^ n).support).IsPWO := by"
  },
  {
    "full_name": "CategoryTheory.bijection_natural",
    "file_path": "Mathlib/CategoryTheory/Closed/Ideal.lean",
    "teorema": "theorem CategoryTheory.bijection_natural (A : C) (B : C) (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (X : D) (f : (reflector i).obj (A ‚®Ø B) ‚ü∂ X) (g : X ‚ü∂ X') (i : D ‚•§ C) : (bijection i A B X') (f ‚â´ g) = (bijection i A B X) f ‚â´ g := by"
  },
  {
    "full_name": "CategoryTheory.FreeBicategory.preinclusion_map‚ÇÇ",
    "file_path": "Mathlib/CategoryTheory/Bicategory/Coherence.lean",
    "teorema": "theorem CategoryTheory.FreeBicategory.preinclusion_map‚ÇÇ (B : Type u) (a : B) (b : B) (f : Discrete (Path a b)) (g : Discrete (Path a b)) (Œ∑ : f ‚ü∂ g) : (preinclusion B).map‚ÇÇ Œ∑ = eqToHom ‚ãØ := by"
  },
  {
    "full_name": "MeasureTheory.lintegral_iUnion_le",
    "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
    "teorema": "lemma MeasureTheory.lintegral_iUnion_le (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Œ≤ ‚Üí Set Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œº : Measure Œ±) : ‚à´‚Åª (a : Œ±) in ‚ãÉ i, s i, f a ‚àÇŒº ‚â§ ‚àë' (i : Œ≤), ‚à´‚Åª (a : Œ±) in s i, f a ‚àÇŒº := by"
  },
  {
    "full_name": "Nat.lt_pow_self",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "teorema": "lemma Nat.lt_pow_self (a : ‚Ñï) : 0 < a ^ 0 := by"
  },
  {
    "full_name": "IsCompactlyGenerated.BooleanGenerators.complementedLattice_of_sSup_eq_top",
    "file_path": "Mathlib/Order/BooleanGenerators.lean",
    "teorema": "lemma IsCompactlyGenerated.BooleanGenerators.complementedLattice_of_sSup_eq_top (Œ± : Type u_1) : ComplementedLattice Œ± := by"
  },
  {
    "full_name": "Real.hasDerivAt_negMulLog",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
    "teorema": "lemma Real.hasDerivAt_negMulLog (x : ‚Ñù) : HasDerivAt negMulLog (-log x - 1) x := by"
  },
  {
    "full_name": "CategoryTheory.isIso_of_fully_faithful",
    "file_path": "Mathlib/CategoryTheory/Functor/FullyFaithful.lean",
    "teorema": "theorem CategoryTheory.isIso_of_fully_faithful (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) (F : C ‚•§ D) (X : C) (Y : C) (f : X ‚ü∂ Y) : F.map (f ‚â´ F.preimage (inv (F.map f))) = F.map (ùüô X) := by"
  },
  {
    "full_name": "Polynomial.natTrailingDegree_eq_support_min'",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean",
    "teorema": "lemma Polynomial.natTrailingDegree_eq_support_min' (R : Type u) (p : R[X]) : p.natTrailingDegree = p.support.min' ‚ãØ := by"
  },
  {
    "full_name": "Nat.modEq_and_modEq_iff_modEq_mul",
    "file_path": "Mathlib/Data/Nat/ModEq.lean",
    "teorema": "theorem Nat.modEq_and_modEq_iff_modEq_mul (a : ‚Ñï) (b : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) : a ‚â° b [MOD m * n] := by"
  },
  {
    "full_name": "LinearMap.mulRight_mul",
    "file_path": "Mathlib/Algebra/Algebra/Bilinear.lean",
    "teorema": "lemma LinearMap.mulRight_mul (A : Type u_2) (R : Type u_1) (a : A) (b : A) : mulRight R (a * b) = mulRight R b ‚àò‚Çó mulRight R a := by"
  },
  {
    "full_name": "Lagrange.nodal_empty",
    "file_path": "Mathlib/LinearAlgebra/Lagrange.lean",
    "teorema": "lemma Lagrange.nodal_empty (R : Type u_1) (v : Œπ ‚Üí R) (Œπ : Type u_2) : nodal ‚àÖ v = 1 := by"
  },
  {
    "full_name": "mul_eq_mul_iff_eq_and_eq",
    "file_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
    "teorema": "theorem mul_eq_mul_iff_eq_and_eq (a : Œ±) (b : Œ±) (c : Œ±) (d : Œ±) (Œ± : Type u_1) : a * b = c * d ‚Üî a = c ‚àß b = d := by"
  },
  {
    "full_name": "LinearMap.proj_comp_stdBasis",
    "file_path": "Mathlib/LinearAlgebra/StdBasis.lean",
    "teorema": "theorem LinearMap.proj_comp_stdBasis (R : Type u_1) (i : Œπ) (j : Œπ) (Œπ : Type u_2) (œÜ : Œπ ‚Üí Type u_3) : proj i ‚àò‚Çó stdBasis R œÜ j = diag j i := by"
  },
  {
    "full_name": "frontier_Ioc",
    "file_path": "Mathlib/Topology/Order/DenselyOrdered.lean",
    "teorema": "theorem frontier_Ioc (a : Œ±) (b : Œ±) (Œ± : Type u_1) : frontier (Ioc a b) = {a, b} := by"
  },
  {
    "full_name": "MvQPF.wEquiv.refl",
    "file_path": "Mathlib/Data/QPF/Multivariate/Constructions/Fix.lean",
    "teorema": "theorem MvQPF.wEquiv.refl (F : TypeVec.{u} (n + 1) ‚Üí Type u) (n : ‚Ñï) (x : (P F).W Œ±) (Œ± : TypeVec.{u} n) : WEquiv x x := by"
  },
  {
    "full_name": "Quaternion.normSq_eq_zero",
    "file_path": "Mathlib/Algebra/Quaternion.lean",
    "teorema": "theorem Quaternion.normSq_eq_zero (R : Type u_1) (a : ‚Ñç[R]) : normSq a = 0 ‚Üî a = 0 := by"
  },
  {
    "full_name": "Filter.map_eval_pi",
    "file_path": "Mathlib/Order/Filter/Pi.lean",
    "teorema": "lemma Filter.map_eval_pi (f : (i : Œπ) ‚Üí Filter (Œ± i)) (i : Œπ) (Œ± : Œπ ‚Üí Type u_2) (Œπ : Type u_1) : map (eval i) (pi f) = f i := by"
  },
  {
    "full_name": "Set.encard_univ",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "teorema": "lemma Set.encard_univ (Œ± : Type u_3) : univ.encard = PartENat.withTopEquiv (PartENat.card Œ±) := by"
  },
  {
    "full_name": "InnerProductSpaceable.rat_prop",
    "file_path": "Mathlib/Analysis/InnerProductSpace/OfNorm.lean",
    "teorema": "theorem InnerProductSpaceable.rat_prop (E : Type u_2) (r : ‚Ñö) : InnerProductSpaceable.innerProp' E ‚Üër := by"
  },
  {
    "full_name": "AlgebraicTopology.DoldKan.Œì‚ÇÇN‚ÇÇToKaroubiIso_hom_app",
    "file_path": "Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean",
    "teorema": "lemma AlgebraicTopology.DoldKan.Œì‚ÇÇN‚ÇÇToKaroubiIso_hom_app (C : Type u_1) (X : SimplicialObject C) : Œì‚ÇÇN‚ÇÇToKaroubiIso.hom.app X = Œì‚ÇÇ.map (toKaroubiCompN‚ÇÇIsoN‚ÇÅ.hom.app X) := by"
  },
  {
    "full_name": "WeierstrassCurve.Jacobian.equation_iff",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean",
    "teorema": "lemma WeierstrassCurve.Jacobian.equation_iff (F : Type v) (P : Fin 3 ‚Üí R) (R : Type u) (W : Jacobian F) : W'.Equation P ‚Üî P y ^ 2 + W'.a‚ÇÅ * P x * P y * P z + W'.a‚ÇÉ * P y * P z ^ 3 - (P x ^ 3 + W'.a‚ÇÇ * P x ^ 2 * P z ^ 2 + W'.a‚ÇÑ * P x * P z ^ 4 + W'.a‚ÇÜ * P z ^ 6) = 0 := by"
  },
  {
    "full_name": "Real.Wallis.W_eq_factorial_ratio",
    "file_path": "Mathlib/Data/Real/Pi/Wallis.lean",
    "teorema": "lemma Real.Wallis.W_eq_factorial_ratio (n : ‚Ñï) : W n = 2 ^ (4 * n) * ‚Üën ! ^ 4 / (‚Üë(2 * n)! ^ 2 * (2 * ‚Üën + 1)) := by"
  },
  {
    "full_name": "uniformContinuous‚ÇÇ_curry",
    "file_path": "Mathlib/Topology/UniformSpace/Basic.lean",
    "teorema": "lemma uniformContinuous‚ÇÇ_curry (f : Œ± √ó Œ≤ ‚Üí Œ≥) (Œ± : Type ua) (Œ≤ : Type ub) (Œ≥ : Type uc) : UniformContinuous‚ÇÇ (curry f) ‚Üî UniformContinuous f := by"
  },
  {
    "full_name": "TruncatedWittVector.out_injective",
    "file_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
    "teorema": "lemma TruncatedWittVector.out_injective : Injective out := by"
  },
  {
    "full_name": "Finset.mem_image",
    "file_path": "Mathlib/Data/Finset/Image.lean",
    "teorema": "lemma Finset.mem_image (a : Œ±) (b : Œ≤) (f : Œ± ‚Üí Œ≤) (s : Finset Œ±) (Œ± : Type u_1) (Œ≤ : Type u_2) : b ‚àà image f s ‚Üî ‚àÉ a ‚àà s, f a = b := by"
  },
  {
    "full_name": "TensorProduct.map_pow",
    "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean",
    "teorema": "lemma TensorProduct.map_pow (M : Type u_4) (N : Type u_5) (R : Type u_1) (f : M ‚Üí‚Çó[R] M) (g : N ‚Üí‚Çó[R] N) (n : ‚Ñï) : map f g ^ n = map (f ^ n) (g ^ n) := by"
  },
  {
    "full_name": "Finset.filter_card_eq",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "teorema": "lemma Finset.filter_card_eq (p : Œ± ‚Üí Prop) (x : Œ±) (Œ± : Type u_1) : p x := by"
  },
  {
    "full_name": "ProbabilityTheory.hasFiniteIntegral_compProd_iff'",
    "file_path": "Mathlib/Probability/Kernel/IntegralCompProd.lean",
    "teorema": "theorem ProbabilityTheory.hasFiniteIntegral_compProd_iff' (E : Type u_4) (a : Œ±) (f : Œ≤ √ó Œ≥ ‚Üí E) (Œ± : Type u_1) (Œ≤ : Type u_2) (Œ≥ : Type u_3) (Œ∑ : ‚Ü•(kernel (Œ± √ó Œ≤) Œ≥)) (Œ∫ : ‚Ü•(kernel Œ± Œ≤)) : HasFiniteIntegral f ((Œ∫ ‚äó‚Çñ Œ∑) a) ‚Üî := by"
  },
  {
    "full_name": "isNoetherianRing_of_surjective",
    "file_path": "Mathlib/RingTheory/Noetherian.lean",
    "teorema": "theorem isNoetherianRing_of_surjective (S : Type u_2) : IsNoetherianRing S := by"
  },
  {
    "full_name": "RingHom.PropertyIsLocal.affine_openCover_TFAE",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean",
    "teorema": "theorem RingHom.PropertyIsLocal.affine_openCover_TFAE (P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop) (X : Scheme) (Y : Scheme) (f : X ‚ü∂ Y) : [sourceAffineLocally P f, := by"
  },
  {
    "full_name": "IsSelfAdjoint.coe_selfAdjointPart_apply",
    "file_path": "Mathlib/Algebra/Star/Module.lean",
    "teorema": "lemma IsSelfAdjoint.coe_selfAdjointPart_apply (A : Type u_2) (R : Type u_1) (x : A) : ‚Üë((selfAdjointPart R) x) = x := by"
  },
  {
    "full_name": "InnerProductGeometry.cos_angle_add_of_inner_eq_zero",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean",
    "teorema": "lemma InnerProductGeometry.cos_angle_add_of_inner_eq_zero (V : Type u_1) (x : V) (y : V) : Real.cos (angle x (x + y)) = ‚Äñx‚Äñ / ‚Äñx + y‚Äñ := by"
  },
  {
    "full_name": "continuousAt_of_locally_lipschitz",
    "file_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean",
    "teorema": "lemma continuousAt_of_locally_lipschitz (f : Œ± ‚Üí Œ≤) (x : Œ±) (Œ± : Type u) (Œ≤ : Type v) : ContinuousAt f x := by"
  },
  {
    "full_name": "orderBornology_isBounded",
    "file_path": "Mathlib/Topology/Order/Bornology.lean",
    "teorema": "lemma orderBornology_isBounded (s : Set Œ±) (Œ± : Type u_1) : IsBounded s ‚Üî BddBelow s ‚àß BddAbove s := by"
  },
  {
    "full_name": "MeasureTheory.OuterMeasure.coe_mkMetric",
    "file_path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean",
    "teorema": "theorem MeasureTheory.OuterMeasure.coe_mkMetric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) : ‚áë(mkMetric m) = ‚áë(Measure.mkMetric m) := by"
  },
  {
    "full_name": "LieSubalgebra.incl_range",
    "file_path": "Mathlib/Algebra/Lie/Subalgebra.lean",
    "teorema": "lemma LieSubalgebra.incl_range (K : LieSubalgebra R L) (L : Type v) (R : Type u) : K.incl.range = K := by"
  },
  {
    "full_name": "ClosedEmbedding.of_comp_iff",
    "file_path": "Mathlib/Topology/Maps.lean",
    "teorema": "lemma ClosedEmbedding.of_comp_iff (X : Type u_1) (Y : Type u_2) (Z : Type u_3) (f : X ‚Üí Y) (g : Y ‚Üí Z) : ClosedEmbedding (g ‚àò f) ‚Üî ClosedEmbedding f := by"
  },
  {
    "full_name": "IntermediateField.equivOfEq_rfl",
    "file_path": "Mathlib/FieldTheory/Adjoin.lean",
    "teorema": "lemma IntermediateField.equivOfEq_rfl : equivOfEq ‚ãØ = AlgEquiv.refl := by"
  },
  {
    "full_name": "CategoryTheory.Abelian.Pseudoelement.zero_apply",
    "file_path": "Mathlib/CategoryTheory/Abelian/Pseudoelements.lean",
    "teorema": "theorem CategoryTheory.Abelian.Pseudoelement.zero_apply (C : Type u) (P : C) (a : Pseudoelement P) : pseudoApply 0 ‚ü¶a'‚üß = 0 := by"
  },
  {
    "full_name": "symmDiff_top'",
    "file_path": "Mathlib/Order/SymmDiff.lean",
    "teorema": "theorem symmDiff_top' (a : Œ±) (Œ± : Type u_2) : a ‚àÜ ‚ä§ = Ôø¢a := by"
  },
  {
    "full_name": "mul_inv_lt_inv_mul_iff",
    "file_path": "Mathlib/Algebra/Order/Group/Defs.lean",
    "teorema": "lemma mul_inv_lt_inv_mul_iff (a : Œ±) (b : Œ±) (c : Œ±) (d : Œ±) (Œ± : Type u) : a * b‚Åª¬π < d‚Åª¬π * c ‚Üî d * a < c * b := by"
  },
  {
    "full_name": "CategoryTheory.pullbackShiftFunctorZero_hom_app",
    "file_path": "Mathlib/CategoryTheory/Shift/Pullback.lean",
    "teorema": "lemma CategoryTheory.pullbackShiftFunctorZero_hom_app (A : Type u_2) (B : Type u_3) (œÜ : A ‚Üí+ B) : 0 = œÜ 0 := by"
  },
  {
    "full_name": "Ideal.Filtration.Stable.exists_pow_smul_eq_of_ge",
    "file_path": "Mathlib/RingTheory/Filtration.lean",
    "teorema": "theorem Ideal.Filtration.Stable.exists_pow_smul_eq_of_ge (F : I.Filtration M) (I : Ideal R) (M : Type u) (R : Type u) : ‚àÉ n‚ÇÄ, ‚àÄ n ‚â• n‚ÇÄ, F.N n = I ^ (n - n‚ÇÄ) ‚Ä¢ F.N n‚ÇÄ := by"
  },
  {
    "full_name": "CategoryTheory.LocalizerMorphism.isEquivalence",
    "file_path": "Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean",
    "teorema": "lemma CategoryTheory.LocalizerMorphism.isEquivalence (D‚ÇÅ : Type u‚ÇÑ) (D‚ÇÇ : Type u‚ÇÖ) (G : D‚ÇÅ ‚•§ D‚ÇÇ) : G.IsEquivalence := by"
  },
  {
    "full_name": "Equiv.setOf_apply_symm_eq_image_setOf",
    "file_path": "Mathlib/Logic/Equiv/Set.lean",
    "teorema": "theorem Equiv.setOf_apply_symm_eq_image_setOf (e : Œ± ‚âÉ Œ≤) (p : Œ± ‚Üí Prop) (Œ± : Type u_1) (Œ≤ : Type u_2) : {b | p (e.symm b)} = ‚áëe '' {a | p a} := by"
  },
  {
    "full_name": "Finset.support_mulAntidiagonal_subset_mul",
    "file_path": "Mathlib/Data/Finset/MulAntidiagonal.lean",
    "teorema": "theorem Finset.support_mulAntidiagonal_subset_mul (a : Œ±) (s : Set Œ±) (t : Set Œ±) (Œ± : Type u_1) : a ‚àà s * t := by"
  },
  {
    "full_name": "List.Ico.filter_lt_of_ge",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "teorema": "theorem List.Ico.filter_lt_of_ge (l : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) : filter (fun x => decide (x < l)) (Ico n m) = Ico n l := by"
  },
  {
    "full_name": "isOpen_setOf_disjoint_nhds_nhds",
    "file_path": "Mathlib/Topology/Constructions.lean",
    "teorema": "theorem isOpen_setOf_disjoint_nhds_nhds : IsOpen {p | Disjoint (ùìù p.1) (ùìù p.2)} := by"
  },
  {
    "full_name": "Function.Surjective.nontrivial",
    "file_path": "Mathlib/Logic/Nontrivial/Defs.lean",
    "teorema": "theorem Function.Surjective.nontrivial (Œ± : Type u_1) : Nontrivial Œ± := by"
  },
  {
    "full_name": "Path.Homotopic.comp_prod_eq_prod_comp",
    "file_path": "Mathlib/Topology/Homotopy/Product.lean",
    "teorema": "lemma Path.Homotopic.comp_prod_eq_prod_comp (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (a‚ÇÉ : Œ±) (b‚ÇÅ : Œ≤) (b‚ÇÇ : Œ≤) (b‚ÇÉ : Œ≤) (q‚ÇÅ : Homotopic.Quotient a‚ÇÅ a‚ÇÇ) (q‚ÇÇ : Homotopic.Quotient b‚ÇÅ b‚ÇÇ) (r‚ÇÅ : Homotopic.Quotient a‚ÇÇ a‚ÇÉ) (r‚ÇÇ : Homotopic.Quotient b‚ÇÇ b‚ÇÉ) (Œ± : Type u_1) (Œ≤ : Type u_2) : prod q‚ÇÅ q‚ÇÇ ‚¨ù prod r‚ÇÅ r‚ÇÇ = prod (q‚ÇÅ ‚¨ù r‚ÇÅ) (q‚ÇÇ ‚¨ù r‚ÇÇ) := by"
  },
  {
    "full_name": "InnerProductGeometry.sin_eq_one_iff_angle_eq_pi_div_two",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "teorema": "theorem InnerProductGeometry.sin_eq_one_iff_angle_eq_pi_div_two (V : Type u_1) (x : V) (y : V) : sin (angle x y) = 1 ‚Üî angle x y = œÄ / 2 := by"
  },
  {
    "full_name": "IsLocallyConstant.tfae",
    "file_path": "Mathlib/Topology/LocallyConstant/Basic.lean",
    "teorema": "theorem IsLocallyConstant.tfae (X : Type u_1) (Y : Type u_2) (f : X ‚Üí Y) : [IsLocallyConstant f, ‚àÄ (x : X), ‚àÄ·∂† (x' : X) in ùìù x, f x' = f x, ‚àÄ (x : X), IsOpen {x' | f x' = f x}, := by"
  },
  {
    "full_name": "Real.continued_fraction_convergent_eq_convergent",
    "file_path": "Mathlib/NumberTheory/DiophantineApproximation.lean",
    "teorema": "lemma Real.continued_fraction_convergent_eq_convergent (n : ‚Ñï) (Œæ : ‚Ñù) : (GeneralizedContinuedFraction.of Œæ).convergents n = ‚Üë(Œæ.convergent n) := by"
  },
  {
    "full_name": "Affine.Simplex.sum_mongePointVSubFaceCentroidWeightsWithCircumcenter",
    "file_path": "Mathlib/Geometry/Euclidean/MongePoint.lean",
    "teorema": "theorem Affine.Simplex.sum_mongePointVSubFaceCentroidWeightsWithCircumcenter (i‚ÇÅ : Fin (n + 3)) (i‚ÇÇ : Fin (n + 3)) (n : ‚Ñï) : ‚àë i : PointsWithCircumcenterIndex (n + 2), mongePointVSubFaceCentroidWeightsWithCircumcenter i‚ÇÅ i‚ÇÇ i = 0 := by"
  },
  {
    "full_name": "Finset.prod_involution",
    "file_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
    "teorema": "lemma Finset.prod_involution (a : Œ±) (g : Œ± ‚Üí Œ≤) (s : Finset Œ±) (Œ± : Type u_3) (Œ≤ : Type u_4) : ‚àÄ (g : (a : Œ±) ‚Üí a ‚àà s ‚Üí Œ±), := by"
  },
  {
    "full_name": "CategoryTheory.InjectiveResolution.isoRightDerivedObj_hom_naturality",
    "file_path": "Mathlib/CategoryTheory/Abelian/RightDerived.lean",
    "teorema": "lemma CategoryTheory.InjectiveResolution.isoRightDerivedObj_hom_naturality (C : Type u) (D : Type u_1) (F : C ‚•§ D) (I : InjectiveResolution X) (J : InjectiveResolution Y) (X : C) (Y : C) (f : X ‚ü∂ Y) (n : ‚Ñï) (œÜ : I.cocomplex ‚ü∂ J.cocomplex) : (F.rightDerived n).map f ‚â´ (J.isoRightDerivedObj F n).hom = (I.isoRightDerivedObj F n).hom ‚â´ (F.mapHomologicalComplex (ComplexShape.up ‚Ñï) ‚ãô HomologicalComplex.homologyFunctor D (ComplexShape.up ‚Ñï) n).map œÜ := by"
  },
  {
    "full_name": "Nat.succ_descFactorial",
    "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
    "teorema": "theorem Nat.succ_descFactorial (n : ‚Ñï) : (n + 1 - 0) * (n + 1).descFactorial 0 = (n + 1) * n.descFactorial 0 := by"
  },
  {
    "full_name": "sSup_atoms_le_eq",
    "file_path": "Mathlib/Order/Atoms.lean",
    "teorema": "lemma sSup_atoms_le_eq (b : Œ±) (Œ± : Type u_2) : sSup {a | IsAtom a ‚àß a ‚â§ b} = b := by"
  },
  {
    "full_name": "Substring.Valid.valid",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "teorema": "lemma Substring.Valid.valid (l : List Char) (m : List Char) (r : List Char) : l ++ (m ++ r) = := by"
  },
  {
    "full_name": "MeasureTheory.lowerCrossingTime_lt_upperCrossingTime",
    "file_path": "Mathlib/Probability/Martingale/Upcrossing.lean",
    "teorema": "lemma MeasureTheory.lowerCrossingTime_lt_upperCrossingTime (N : ‚Ñï) (a : ‚Ñù) (b : ‚Ñù) (f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù) (n : ‚Ñï) (Œ© : Type u_1) (œâ : Œ©) : lowerCrossingTime a b f N n œâ < upperCrossingTime a b f N (n + 1) œâ := by"
  },
  {
    "full_name": "X_pow_mul_sub_C_irreducible",
    "file_path": "Mathlib/FieldTheory/KummerExtension.lean",
    "teorema": "lemma X_pow_mul_sub_C_irreducible (K : Type u) (a : K) (m : ‚Ñï) (n : ‚Ñï) : Irreducible (X ^ (n * m) - C a) := by"
  },
  {
    "full_name": "List.findIdx_le_length",
    "file_path": "Mathlib/Data/List/Indexes.lean",
    "teorema": "lemma List.findIdx_le_length (p : Œ± ‚Üí Bool) (xs : List Œ±) (Œ± : Type u) : findIdx p xs ‚â§ xs.length := by"
  },
  {
    "full_name": "Polynomial.eval‚ÇÇ_ofFinsupp",
    "file_path": "Mathlib/Algebra/Polynomial/Eval.lean",
    "teorema": "lemma Polynomial.eval‚ÇÇ_ofFinsupp (R : Type u) (S : Type v) (f : R ‚Üí+* S) (p : R[‚Ñï]) (x : S) : eval‚ÇÇ f x { toFinsupp := p } = (liftNC ‚Üëf ‚áë((powersHom S) x)) p := by"
  },
  {
    "full_name": "Subgroup.smul_opposite_image_mul_preimage'",
    "file_path": "Mathlib/Algebra/Group/Subgroup/Pointwise.lean",
    "teorema": "theorem Subgroup.smul_opposite_image_mul_preimage' (G : Type u_2) (g : G) (h : G·µê·µí·µñ) (s : Set G) : (fun y => h ‚Ä¢ y) '' ((fun x => g * x) ‚Åª¬π' s) = (fun x => g * x) ‚Åª¬π' ((fun y => h ‚Ä¢ y) '' s) := by"
  },
  {
    "full_name": "Basis.toMatrix_reindex'",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Basis.lean",
    "teorema": "lemma Basis.toMatrix_reindex' (M : Type u_6) (R : Type u_5) (b : Basis Œπ R M) (e : Œπ ‚âÉ Œπ') (v : Œπ' ‚Üí M) (Œπ : Type u_1) : (b.reindex e).toMatrix v = (reindexAlgEquiv R e) (b.toMatrix (v ‚àò ‚áëe)) := by"
  },
  {
    "full_name": "MvQPF.has_good_supp_iff",
    "file_path": "Mathlib/Data/QPF/Multivariate/Basic.lean",
    "teorema": "lemma MvQPF.has_good_supp_iff (F : TypeVec.{u} n ‚Üí Type u_1) (n : ‚Ñï) (x : F Œ±) (Œ± : TypeVec.{u} n) : (‚àÄ (p : (i : Fin2 n) ‚Üí Œ± i ‚Üí Prop), LiftP p x ‚Üî ‚àÄ (i : Fin2 n), ‚àÄ u ‚àà supp x i, p i u) ‚Üî ‚àÉ a f, abs ‚ü®a, f‚ü© = x ‚àß := by"
  },
  {
    "full_name": "Nat.bit1_eq_bit1",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "teorema": "lemma Nat.bit1_eq_bit1 (m : ‚Ñï) (n : ‚Ñï) : bit1 m = bit1 n := by"
  },
  {
    "full_name": "HNNExtension.NormalWord.unitsSMul_cancels_iff",
    "file_path": "Mathlib/GroupTheory/HNNExtension.lean",
    "teorema": "lemma HNNExtension.NormalWord.unitsSMul_cancels_iff (A : Subgroup G) (B : Subgroup G) (G : Type u_1) (d : TransversalPair G A B) (u : ‚Ñ§À£) (w : NormalWord d) (œÜ : ‚Ü•A ‚âÉ* ‚Ü•B) : Cancels (-u) (unitsSMul œÜ u w) ‚Üî ¬¨Cancels u w := by"
  },
  {
    "full_name": "Polynomial.monic_multiset_prod_of_monic",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "teorema": "lemma Polynomial.monic_multiset_prod_of_monic (R : Type u) (f : Œπ ‚Üí R[X]) (t : Multiset Œπ) (Œπ : Type y) : (Multiset.map f t).prod.Monic := by"
  },
  {
    "full_name": "intervalIntegral.integral_congr",
    "file_path": "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean",
    "teorema": "lemma intervalIntegral.integral_congr (E : Type u_3) (a : ‚Ñù) (b : ‚Ñù) (f : ‚Ñù ‚Üí E) (g : ‚Ñù ‚Üí E) (Œº : Measure ‚Ñù) : ‚à´ (x : ‚Ñù) in a..b, f x ‚àÇŒº = ‚à´ (x : ‚Ñù) in a..b, g x ‚àÇŒº := by"
  },
  {
    "full_name": "Real.diam_Ioc",
    "file_path": "Mathlib/Topology/Instances/ENNReal.lean",
    "teorema": "lemma Real.diam_Ioc (a : ‚Ñù) (b : ‚Ñù) : Metric.diam (Ioc a b) = b - a := by"
  }
]